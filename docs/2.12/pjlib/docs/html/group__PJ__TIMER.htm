<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Timer Heap Management. (2.12)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Timer Heap Management.<div class="ingroups"><a class="el" href="group__PJ__MISC.htm">Miscelaneous</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The timer scheduling implementation here is based on ACE library's ACE_Timer_Heap, with only little modification to suit our library's style (I even left most of the comments in the original source).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga79162cac576ae7615e5b690d1e5e4631"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga79162cac576ae7615e5b690d1e5e4631">pj_timer_id_t</a></td></tr>
<tr class="separator:ga79162cac576ae7615e5b690d1e5e4631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f6af5c2177565ccae9dcb50733f8c65"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga2f6af5c2177565ccae9dcb50733f8c65">pj_timer_heap_callback</a>(<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *timer_heap, struct <a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *entry)</td></tr>
<tr class="separator:ga2f6af5c2177565ccae9dcb50733f8c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab14375d4993080837ae1709c74796ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#gab14375d4993080837ae1709c74796ca7">pj_timer_heap_mem_size</a> (<a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> count)</td></tr>
<tr class="separator:gab14375d4993080837ae1709c74796ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23ecc3a7d6779be2183149da9a841d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#gac23ecc3a7d6779be2183149da9a841d5">pj_timer_heap_create</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> count, <a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> **ht)</td></tr>
<tr class="separator:gac23ecc3a7d6779be2183149da9a841d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdecba93d049eac4ea080246b674ff5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga6bdecba93d049eac4ea080246b674ff5">pj_timer_heap_destroy</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht)</td></tr>
<tr class="separator:ga6bdecba93d049eac4ea080246b674ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf7b50b4eeda50c860b21198b7de1f86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#gadf7b50b4eeda50c860b21198b7de1f86">pj_timer_heap_set_lock</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, <a class="el" href="group__PJ__BASIC.htm#ga3dc49084043901d31c7b12e5afc9fb2f">pj_lock_t</a> *lock, <a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> auto_del)</td></tr>
<tr class="separator:gadf7b50b4eeda50c860b21198b7de1f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae17c68c92defe06ebf9a8b15b129d83b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#gae17c68c92defe06ebf9a8b15b129d83b">pj_timer_heap_set_max_timed_out_per_poll</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, unsigned count)</td></tr>
<tr class="separator:gae17c68c92defe06ebf9a8b15b129d83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95852c5f154d79368516e0247f66e538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga95852c5f154d79368516e0247f66e538">pj_timer_entry_init</a> (<a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *entry, <a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> id, void *user_data, <a class="el" href="group__PJ__TIMER.htm#ga2f6af5c2177565ccae9dcb50733f8c65">pj_timer_heap_callback</a> *cb)</td></tr>
<tr class="separator:ga95852c5f154d79368516e0247f66e538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6141173e4d6f7f662857baf661ad366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#gac6141173e4d6f7f662857baf661ad366">pj_timer_entry_running</a> (<a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *entry)</td></tr>
<tr class="separator:gac6141173e4d6f7f662857baf661ad366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70651768f9361e9cda3c1d24fec924f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga70651768f9361e9cda3c1d24fec924f7">pj_timer_heap_schedule</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, <a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *entry, const <a class="el" href="structpj__time__val.htm">pj_time_val</a> *delay)</td></tr>
<tr class="separator:ga70651768f9361e9cda3c1d24fec924f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga317345c41a2db7958ad8dc0773a148b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga317345c41a2db7958ad8dc0773a148b2">pj_timer_heap_schedule_w_grp_lock</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, <a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *entry, const <a class="el" href="structpj__time__val.htm">pj_time_val</a> *delay, <a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> id_val, <a class="el" href="group__PJ__BASIC.htm#gadf42a33e518aa8df09d5a11429e8a41a">pj_grp_lock_t</a> *grp_lock)</td></tr>
<tr class="separator:ga317345c41a2db7958ad8dc0773a148b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga522fb9ade28878a32d7c76e4f90f35ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga522fb9ade28878a32d7c76e4f90f35ee">pj_timer_heap_cancel</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, <a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *entry)</td></tr>
<tr class="separator:ga522fb9ade28878a32d7c76e4f90f35ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ebea3047cb96236a8d78692c22f787e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga4ebea3047cb96236a8d78692c22f787e">pj_timer_heap_cancel_if_active</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, <a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *entry, <a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> id_val)</td></tr>
<tr class="separator:ga4ebea3047cb96236a8d78692c22f787e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d2e2c0a9fad51dc159848aa412c9b1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga0d2e2c0a9fad51dc159848aa412c9b1b">pj_timer_heap_count</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht)</td></tr>
<tr class="separator:ga0d2e2c0a9fad51dc159848aa412c9b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a76f7b7d14f3b4ae3dc1534ed57b05d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga6a76f7b7d14f3b4ae3dc1534ed57b05d">pj_timer_heap_earliest_time</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, <a class="el" href="structpj__time__val.htm">pj_time_val</a> *timeval)</td></tr>
<tr class="separator:ga6a76f7b7d14f3b4ae3dc1534ed57b05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga591fb436503b441ef00e6a4fe2a3117f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga591fb436503b441ef00e6a4fe2a3117f">pj_timer_heap_poll</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, <a class="el" href="structpj__time__val.htm">pj_time_val</a> *next_delay)</td></tr>
<tr class="separator:ga591fb436503b441ef00e6a4fe2a3117f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The timer scheduling implementation here is based on ACE library's ACE_Timer_Heap, with only little modification to suit our library's style (I even left most of the comments in the original source). </p>
<p>To quote the original quote in ACE_Timer_Heap_T class: </p><pre class="fragment"> This implementation uses a heap-based callout queue of
 absolute times.  Therefore, in the average and worst case,
 scheduling, canceling, and expiring timers is O(log N) (where
 N is the total number of timers).  In addition, we can also
 preallocate as many \a ACE_Timer_Nodes as there are slots in
 the heap.  This allows us to completely remove the need for
 dynamic memory allocation, which is important for real-time
 systems.
</pre><p>You can find the fine ACE library at: <a href="http://www.cs.wustl.edu/~schmidt/ACE.html">http://www.cs.wustl.edu/~schmidt/ACE.html</a></p>
<p>ACE is Copyright (C)1993-2006 Douglas C. Schmidt <a href="#" onclick="location.href='mai'+'lto:'+'d.s'+'ch'+'mid'+'t@'+'van'+'de'+'rbi'+'lt'+'.ed'+'u'; return false;">d.sch<span style="display: none;">.nosp@m.</span>midt<span style="display: none;">.nosp@m.</span>@vand<span style="display: none;">.nosp@m.</span>erbi<span style="display: none;">.nosp@m.</span>lt.ed<span style="display: none;">.nosp@m.</span>u</a></p>
<h1><a class="anchor" id="pj_timer_examples_sec"></a>
Examples</h1>
<p>For some examples on how to use the timer heap, please see the link below.</p>
<ul>
<li><a class="el" href="page_pjlib_timer_test.htm">Test: Timer</a> </li>
</ul>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga2f6af5c2177565ccae9dcb50733f8c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f6af5c2177565ccae9dcb50733f8c65">&#9670;&nbsp;</a></span>pj_timer_heap_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void pj_timer_heap_callback(<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *timer_heap, struct <a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *entry)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of callback function to be called by timer scheduler when a timer has expired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer_heap</td><td>The timer heap. </td></tr>
    <tr><td class="paramname">entry</td><td>Timer entry which timer's has expired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga79162cac576ae7615e5b690d1e5e4631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79162cac576ae7615e5b690d1e5e4631">&#9670;&nbsp;</a></span>pj_timer_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> <a class="el" href="group__PJ__TIMER.htm#ga79162cac576ae7615e5b690d1e5e4631">pj_timer_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type for internal timer ID. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga95852c5f154d79368516e0247f66e538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95852c5f154d79368516e0247f66e538">&#9670;&nbsp;</a></span>pj_timer_entry_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a>* pj_timer_entry_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__TIMER.htm#ga2f6af5c2177565ccae9dcb50733f8c65">pj_timer_heap_callback</a> *&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a timer entry. Application should call this function at least once before scheduling the entry to the timer heap, to properly initialize the timer entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The timer entry to be initialized. </td></tr>
    <tr><td class="paramname">id</td><td>Arbitrary ID assigned by the user/owner of this entry. Applications can use this ID to distinguish multiple timer entries that share the same callback and user_data. </td></tr>
    <tr><td class="paramname">user_data</td><td>User data to be associated with this entry. Applications normally will put the instance of object that owns the timer entry in this field. </td></tr>
    <tr><td class="paramname">cb</td><td>Callback function to be called when the timer elapses.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The timer entry itself. </dd></dl>

</div>
</div>
<a id="gac6141173e4d6f7f662857baf661ad366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6141173e4d6f7f662857baf661ad366">&#9670;&nbsp;</a></span>pj_timer_entry_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> pj_timer_entry_running </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries whether a timer entry is currently running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The timer entry to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_TRUE if the timer is running. PJ_FALSE if not. </dd></dl>

</div>
</div>
<a id="ga522fb9ade28878a32d7c76e4f90f35ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga522fb9ade28878a32d7c76e4f90f35ee">&#9670;&nbsp;</a></span>pj_timer_heap_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> pj_timer_heap_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancel a previously registered timer. This will also decrement the reference counter of the group lock associated with the timer entry, if the entry was scheduled with one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The timer heap. </td></tr>
    <tr><td class="paramname">entry</td><td>The entry to be cancelled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of timer cancelled, which should be one if the entry has really been registered, or zero if no timer was cancelled. </dd></dl>

</div>
</div>
<a id="ga4ebea3047cb96236a8d78692c22f787e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ebea3047cb96236a8d78692c22f787e">&#9670;&nbsp;</a></span>pj_timer_heap_cancel_if_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> pj_timer_heap_cancel_if_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&#160;</td>
          <td class="paramname"><em>id_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancel only if the previously registered timer is active. This will also decrement the reference counter of the group lock associated with the timer entry, if the entry was scheduled with one. In any case, set the "id" to the specified value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The timer heap. </td></tr>
    <tr><td class="paramname">entry</td><td>The entry to be cancelled. </td></tr>
    <tr><td class="paramname">id_val</td><td>Value to be set to "id"</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of timer cancelled, which should be one if the entry has really been registered, or zero if no timer was cancelled. </dd></dl>

</div>
</div>
<a id="ga0d2e2c0a9fad51dc159848aa412c9b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d2e2c0a9fad51dc159848aa412c9b1b">&#9670;&nbsp;</a></span>pj_timer_heap_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> pj_timer_heap_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of timer entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The timer heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of timer entries. </dd></dl>

</div>
</div>
<a id="gac23ecc3a7d6779be2183149da9a841d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac23ecc3a7d6779be2183149da9a841d5">&#9670;&nbsp;</a></span>pj_timer_heap_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_timer_heap_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> **&#160;</td>
          <td class="paramname"><em>ht</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a timer heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool where allocations in the timer heap will be allocated. The timer heap will dynamicly allocate more storate from the pool if the number of timer entries registered is more than the size originally requested when calling this function. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of timer entries to be supported initially. If the application registers more entries during runtime, then the timer heap will resize. </td></tr>
    <tr><td class="paramname">ht</td><td>Pointer to receive the created timer heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS, or the appropriate error code. </dd></dl>

</div>
</div>
<a id="ga6bdecba93d049eac4ea080246b674ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bdecba93d049eac4ea080246b674ff5">&#9670;&nbsp;</a></span>pj_timer_heap_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_timer_heap_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy the timer heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The timer heap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a76f7b7d14f3b4ae3dc1534ed57b05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a76f7b7d14f3b4ae3dc1534ed57b05d">&#9670;&nbsp;</a></span>pj_timer_heap_earliest_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_timer_heap_earliest_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__time__val.htm">pj_time_val</a> *&#160;</td>
          <td class="paramname"><em>timeval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the earliest time registered in the timer heap. The timer heap MUST have at least one timer being scheduled (application should use <a class="el" href="group__PJ__TIMER.htm#ga0d2e2c0a9fad51dc159848aa412c9b1b">pj_timer_heap_count()</a> before calling this function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The timer heap. </td></tr>
    <tr><td class="paramname">timeval</td><td>The time deadline of the earliest timer entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS, or PJ_ENOTFOUND if no entry is scheduled. </dd></dl>

</div>
</div>
<a id="gab14375d4993080837ae1709c74796ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab14375d4993080837ae1709c74796ca7">&#9670;&nbsp;</a></span>pj_timer_heap_mem_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> pj_timer_heap_mem_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate memory size required to create a timer heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of timer entries to be supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory size requirement in bytes. </dd></dl>

</div>
</div>
<a id="ga591fb436503b441ef00e6a4fe2a3117f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga591fb436503b441ef00e6a4fe2a3117f">&#9670;&nbsp;</a></span>pj_timer_heap_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned pj_timer_heap_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__time__val.htm">pj_time_val</a> *&#160;</td>
          <td class="paramname"><em>next_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Poll the timer heap, check for expired timers and call the callback for each of the expired timers.</p>
<p>Note: polling the timer heap is not necessary in Symbian. Please see <a class="el" href="group__PJ__SYMBIAN__OS.htm">Symbian OS Specific</a> for more info.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The timer heap. </td></tr>
    <tr><td class="paramname">next_delay</td><td>If this parameter is not NULL, it will be filled up with the time delay until the next timer elapsed, or PJ_MAXINT32 in the sec part if no entry exist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of timers expired. </dd></dl>

</div>
</div>
<a id="ga70651768f9361e9cda3c1d24fec924f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70651768f9361e9cda3c1d24fec924f7">&#9670;&nbsp;</a></span>pj_timer_heap_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_timer_heap_schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__time__val.htm">pj_time_val</a> *&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedule a timer entry which will expire AFTER the specified delay.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The timer heap. </td></tr>
    <tr><td class="paramname">entry</td><td>The entry to be registered. </td></tr>
    <tr><td class="paramname">delay</td><td>The interval to expire. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS, or the appropriate error code. </dd></dl>

</div>
</div>
<a id="ga317345c41a2db7958ad8dc0773a148b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga317345c41a2db7958ad8dc0773a148b2">&#9670;&nbsp;</a></span>pj_timer_heap_schedule_w_grp_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_timer_heap_schedule_w_grp_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__time__val.htm">pj_time_val</a> *&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&#160;</td>
          <td class="paramname"><em>id_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gadf42a33e518aa8df09d5a11429e8a41a">pj_grp_lock_t</a> *&#160;</td>
          <td class="paramname"><em>grp_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedule a timer entry which will expire AFTER the specified delay, and increment the reference counter of the group lock while the timer entry is active. The group lock reference counter will automatically be released after the timer callback is called or when the timer is cancelled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The timer heap. </td></tr>
    <tr><td class="paramname">entry</td><td>The entry to be registered. </td></tr>
    <tr><td class="paramname">delay</td><td>The interval to expire. </td></tr>
    <tr><td class="paramname">id_val</td><td>The value to be set to the "id" field of the timer entry once the timer is scheduled. </td></tr>
    <tr><td class="paramname">grp_lock</td><td>The group lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS, or the appropriate error code. </dd></dl>

</div>
</div>
<a id="gadf7b50b4eeda50c860b21198b7de1f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf7b50b4eeda50c860b21198b7de1f86">&#9670;&nbsp;</a></span>pj_timer_heap_set_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_timer_heap_set_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga3dc49084043901d31c7b12e5afc9fb2f">pj_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&#160;</td>
          <td class="paramname"><em>auto_del</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set lock object to be used by the timer heap. By default, the timer heap uses dummy synchronization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The timer heap. </td></tr>
    <tr><td class="paramname">lock</td><td>The lock object to be used for synchronization. </td></tr>
    <tr><td class="paramname">auto_del</td><td>If nonzero, the lock object will be destroyed when the timer heap is destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae17c68c92defe06ebf9a8b15b129d83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae17c68c92defe06ebf9a8b15b129d83b">&#9670;&nbsp;</a></span>pj_timer_heap_set_max_timed_out_per_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned pj_timer_heap_set_max_timed_out_per_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set maximum number of timed out entries to process in a single poll.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The timer heap. </td></tr>
    <tr><td class="paramname">count</td><td>Number of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old number. </dd></dl>

</div>
</div>
</div><!-- contents -->
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>
<!--#include virtual="/footer.html" -->
</BODY>
</HTML>
