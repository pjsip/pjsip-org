<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PJLIB Reference: Memory Pool Object (1.16)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>


<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.htm"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Memory Pool Object<br/>
<small>
[<a class="el" href="group__PJ__POOL__GROUP.htm">Fast Memory Pool</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>The memory pool is an opaque object created by pool factory. Application uses this object to request a memory chunk, by calling <a class="el" href="group__PJ__POOL.htm#ga865b3702766960869d1c58429e213cf4">pj_pool_alloc()</a>, <a class="el" href="group__PJ__POOL.htm#gadbfad2994a9bf4a86ce81f5726d4502c">pj_pool_calloc()</a>, or <a class="el" href="group__PJ__POOL.htm#ga4ecb4c956f18e49b20308ffd075b0b40">pj_pool_zalloc()</a>. When the application has finished using the pool, it must call <a class="el" href="group__PJ__POOL.htm#gade0f14f6635ecfccb576ec41c57fede5">pj_pool_release()</a> to free all the chunks previously allocated and release the pool back to the factory.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__block.htm">pj_pool_block</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga1c2e8be344e0e510145d5888636538be">PJ_POOL_SIZE</a>&nbsp;&nbsp;&nbsp;(sizeof(struct <a class="el" href="structpj__pool__t.htm">pj_pool_t</a>))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga83e2da94131c06db0b620d4fc65c6abb">PJ_POOL_ALIGNMENT</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga6763322fc7956e3c1aac87cb250f8b86">PJ_POOL_ALLOC_T</a>(pool, type)&nbsp;&nbsp;&nbsp;((type*)pj_pool_alloc(pool, sizeof(type)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga405d1dbb6728b1d1bd90ddadb9342b27">PJ_POOL_ZALLOC_T</a>(pool, type)&nbsp;&nbsp;&nbsp;((type*)pj_pool_zalloc(pool, sizeof(type)))</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#gaf58c3ba26a1314c0e0be103960ba4a5e">pj_pool_create</a> (<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, const char *name, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> initial_size, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> increment_size, <a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#gade0f14f6635ecfccb576ec41c57fede5">pj_pool_release</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#gabdba41c449585e8fa029d3196c713560">pj_pool_getobjname</a> (const <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga8bfe679642e35ec7f1f6704f55a1610c">pj_pool_reset</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga5442c928338775d194cc57c3fb7652a2">pj_pool_get_capacity</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga235684dba5b7eb06e2fe9a68a84acfb1">pj_pool_get_used_size</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga865b3702766960869d1c58429e213cf4">pj_pool_alloc</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#gadbfad2994a9bf4a86ce81f5726d4502c">pj_pool_calloc</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> count, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> elem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga4ecb4c956f18e49b20308ffd075b0b40">pj_pool_zalloc</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f8ba55c30ccab7f2ee3cc8115a57e0f"></a><!-- doxytag: member="PJ_POOL::pj_pool_alloc_from_block" ref="ga8f8ba55c30ccab7f2ee3cc8115a57e0f" args="(pj_pool_block *block, pj_size_t size)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pj_pool_alloc_from_block</b> (<a class="el" href="structpj__pool__block.htm">pj_pool_block</a> *block, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9fe735cd37593dd933d4c5d3a365e32e"></a><!-- doxytag: member="PJ_POOL::pj_pool_allocate_find" ref="ga9fe735cd37593dd933d4c5d3a365e32e" args="(pj_pool_t *pool, pj_size_t size)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pj_pool_allocate_find</b> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The memory pool is an opaque object created by pool factory. Application uses this object to request a memory chunk, by calling <a class="el" href="group__PJ__POOL.htm#ga865b3702766960869d1c58429e213cf4">pj_pool_alloc()</a>, <a class="el" href="group__PJ__POOL.htm#gadbfad2994a9bf4a86ce81f5726d4502c">pj_pool_calloc()</a>, or <a class="el" href="group__PJ__POOL.htm#ga4ecb4c956f18e49b20308ffd075b0b40">pj_pool_zalloc()</a>. When the application has finished using the pool, it must call <a class="el" href="group__PJ__POOL.htm#gade0f14f6635ecfccb576ec41c57fede5">pj_pool_release()</a> to free all the chunks previously allocated and release the pool back to the factory. </p>
<p>A memory pool is initialized with an initial amount of memory, which is called a block. Pool can be configured to dynamically allocate more memory blocks when it runs out of memory.</p>
<p>The pool doesn't keep track of individual memory allocations by user, and the user doesn't have to free these indidual allocations. This makes memory allocation simple and very fast. All the memory allocated from the pool will be destroyed when the pool itself is destroyed.</p>
<h2><a class="anchor" id="PJ_POOL_THREADING_SEC"></a>
More on Threading Policies</h2>
<ul>
<li>By design, memory allocation from a pool is not thread safe. We assumed that a pool will be owned by an object, and thread safety should be handled by that object. Thus these functions are not thread safe:<ul>
<li><a class="el" href="group__PJ__POOL.htm#ga865b3702766960869d1c58429e213cf4">pj_pool_alloc</a>,</li>
<li><a class="el" href="group__PJ__POOL.htm#gadbfad2994a9bf4a86ce81f5726d4502c">pj_pool_calloc</a>,</li>
<li>and other pool statistic functions.</li>
</ul>
</li>
<li>Threading in the pool factory is decided by the policy set for the factory when it was created.</li>
</ul>
<h2><a class="anchor" id="PJ_POOL_EXAMPLES_SEC"></a>
Examples</h2>
<p>For some sample codes on how to use the pool, please see:</p>
<ul>
<li><a class="el" href="page_pjlib_pool_test.htm">Test: Pool</a> </li>
</ul>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga83e2da94131c06db0b620d4fc65c6abb"></a><!-- doxytag: member="pool.h::PJ_POOL_ALIGNMENT" ref="ga83e2da94131c06db0b620d4fc65c6abb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PJ_POOL_ALIGNMENT&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pool memory alignment (must be power of 2). </p>

</div>
</div>
<a class="anchor" id="ga6763322fc7956e3c1aac87cb250f8b86"></a><!-- doxytag: member="pool.h::PJ_POOL_ALLOC_T" ref="ga6763322fc7956e3c1aac87cb250f8b86" args="(pool, type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PJ_POOL_ALLOC_T</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">type</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>&nbsp;&nbsp;&nbsp;((type*)pj_pool_alloc(pool, sizeof(type)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro allocates memory from the pool and returns the instance of the specified type. It provides a stricker type safety than <a class="el" href="group__PJ__POOL.htm#ga865b3702766960869d1c58429e213cf4">pj_pool_alloc()</a> since the return value of this macro will be type-casted to the specified type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The pool </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of object to be allocated</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Memory buffer of the specified type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c2e8be344e0e510145d5888636538be"></a><!-- doxytag: member="pool.h::PJ_POOL_SIZE" ref="ga1c2e8be344e0e510145d5888636538be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PJ_POOL_SIZE&nbsp;&nbsp;&nbsp;(sizeof(struct <a class="el" href="structpj__pool__t.htm">pj_pool_t</a>))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Guidance on how much memory required for initial pool administrative data. </p>

</div>
</div>
<a class="anchor" id="ga405d1dbb6728b1d1bd90ddadb9342b27"></a><!-- doxytag: member="pool.h::PJ_POOL_ZALLOC_T" ref="ga405d1dbb6728b1d1bd90ddadb9342b27" args="(pool, type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PJ_POOL_ZALLOC_T</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">type</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>&nbsp;&nbsp;&nbsp;((type*)pj_pool_zalloc(pool, sizeof(type)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro allocates memory from the pool, zeroes the buffer, and returns the instance of the specified type. It provides a stricker type safety than <a class="el" href="group__PJ__POOL.htm#ga4ecb4c956f18e49b20308ffd075b0b40">pj_pool_zalloc()</a> since the return value of this macro will be type-casted to the specified type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The pool </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of object to be allocated</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Memory buffer of the specified type. </dd></dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gabffd362d92627d62c4498b7efe0ae62a"></a><!-- doxytag: member="pool.h::pj_pool_callback" ref="gabffd362d92627d62c4498b7efe0ae62a" args="(pj_pool_t *pool, pj_size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a>(<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The type for function to receive callback from the pool when it is unable to allocate memory. The elegant way to handle this condition is to throw exception, and this is what is expected by most of this library components. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga865b3702766960869d1c58429e213cf4"></a><!-- doxytag: member="pool.h::pj_pool_alloc" ref="ga865b3702766960869d1c58429e213cf4" args="(pj_pool_t *pool, pj_size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pj_pool_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate storage with the specified size from the pool. If there's no storage available in the pool, then the pool can allocate more blocks if the increment size is larger than the requested size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>the pool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the requested size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the allocated memory.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__PJ__POOL.htm#ga6763322fc7956e3c1aac87cb250f8b86">PJ_POOL_ALLOC_T</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadbfad2994a9bf4a86ce81f5726d4502c"></a><!-- doxytag: member="pool.h::pj_pool_calloc" ref="gadbfad2994a9bf4a86ce81f5726d4502c" args="(pj_pool_t *pool, pj_size_t count, pj_size_t elem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pj_pool_calloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>elem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate storage from the pool, and initialize it to zero. This function behaves like <a class="el" href="group__PJ__POOL.htm#ga865b3702766960869d1c58429e213cf4">pj_pool_alloc()</a>, except that the storage will be initialized to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>the pool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>the number of elements in the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>elem</em>&nbsp;</td><td>the size of individual element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the allocated memory. </dd></dl>

<p>Referenced by <a class="el" href="group__PJ__POOL.htm#ga4ecb4c956f18e49b20308ffd075b0b40">pj_pool_zalloc()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf58c3ba26a1314c0e0be103960ba4a5e"></a><!-- doxytag: member="pool.h::pj_pool_create" ref="gaf58c3ba26a1314c0e0be103960ba4a5e" args="(pj_pool_factory *factory, const char *name, pj_size_t initial_size, pj_size_t increment_size, pj_pool_callback *callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a>* pj_pool_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>increment_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new pool from the pool factory. This wrapper will call create_pool member of the pool factory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>factory</em>&nbsp;</td><td>The pool factory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to be assigned to the pool. The name should not be longer than PJ_MAX_OBJ_NAME (32 chars), or otherwise it will be truncated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>initial_size</em>&nbsp;</td><td>The size of initial memory blocks taken by the pool. Note that the pool will take 68+20 bytes for administrative area from this block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>increment_size</em>&nbsp;</td><td>the size of each additional blocks to be allocated when the pool is running out of memory. If user requests memory which is larger than this size, then an error occurs. Note that each time a pool allocates additional block, it needs PJ_POOL_SIZE more to store some administrative info. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Callback to be called when error occurs in the pool. If this value is NULL, then the callback from pool factory policy will be used. Note that when an error occurs during pool creation, the callback itself is not called. Instead, NULL will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The memory pool, or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5442c928338775d194cc57c3fb7652a2"></a><!-- doxytag: member="pool.h::pj_pool_get_capacity" ref="ga5442c928338775d194cc57c3fb7652a2" args="(pj_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> pj_pool_get_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the pool capacity, that is, the system storage that have been allocated by the pool, and have been used/will be used to allocate user requests. There's no guarantee that the returned value represent a single contiguous block, because the capacity may be spread in several blocks.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the capacity. </dd></dl>

</div>
</div>
<a class="anchor" id="ga235684dba5b7eb06e2fe9a68a84acfb1"></a><!-- doxytag: member="pool.h::pj_pool_get_used_size" ref="ga235684dba5b7eb06e2fe9a68a84acfb1" args="(pj_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> pj_pool_get_used_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the total size of user allocation request.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the total size. </dd></dl>

</div>
</div>
<a class="anchor" id="gabdba41c449585e8fa029d3196c713560"></a><!-- doxytag: member="pool.h::pj_pool_getobjname" ref="gabdba41c449585e8fa029d3196c713560" args="(const pj_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pj_pool_getobjname </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get pool object name.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pool name as NULL terminated string. </dd></dl>

</div>
</div>
<a class="anchor" id="gade0f14f6635ecfccb576ec41c57fede5"></a><!-- doxytag: member="pool.h::pj_pool_release" ref="gade0f14f6635ecfccb576ec41c57fede5" args="(pj_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_pool_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the pool back to pool factory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>Memory pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8bfe679642e35ec7f1f6704f55a1610c"></a><!-- doxytag: member="pool.h::pj_pool_reset" ref="ga8bfe679642e35ec7f1f6704f55a1610c" args="(pj_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_pool_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the pool to its state when it was initialized. This means that if additional blocks have been allocated during runtime, then they will be freed. Only the original block allocated during initialization is retained. This function will also reset the internal counters, such as pool capacity and used size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>the pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ecb4c956f18e49b20308ffd075b0b40"></a><!-- doxytag: member="pool.h::pj_pool_zalloc" ref="ga4ecb4c956f18e49b20308ffd075b0b40" args="(pj_pool_t *pool, pj_size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pj_pool_zalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate storage from the pool and initialize it to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The pool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size to be allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the allocated memory.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__PJ__POOL.htm#ga405d1dbb6728b1d1bd90ddadb9342b27">PJ_POOL_ZALLOC_T</a> </dd></dl>

<p>References <a class="el" href="group__PJ__POOL.htm#gadbfad2994a9bf4a86ce81f5726d4502c">pj_pool_calloc()</a>.</p>

</div>
</div>
</div>
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
