<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pj_pool_factory Struct Reference (2.13)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">pj_pool_factory Struct Reference<div class="ingroups"><a class="el" href="group__PJ__POOL__GROUP.htm">Fast Memory Pool</a> &raquo; <a class="el" href="group__PJ__POOL__FACTORY.htm">Pool Factory and Policy</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="pool_8h_source.htm">pool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a767d5e5bd2bf77fa6d10ef79b34e8e29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__factory.htm#a767d5e5bd2bf77fa6d10ef79b34e8e29">policy</a></td></tr>
<tr class="separator:a767d5e5bd2bf77fa6d10ef79b34e8e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2381d64670b2ac232aad718be4db91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__factory.htm#a4a2381d64670b2ac232aad718be4db91">create_pool</a> )(<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, const char *name, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> initial_size, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> increment_size, <a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *callback)</td></tr>
<tr class="separator:a4a2381d64670b2ac232aad718be4db91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab613ecd3620eaf7807cfc54d723df44b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__factory.htm#ab613ecd3620eaf7807cfc54d723df44b">release_pool</a> )(<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr class="separator:ab613ecd3620eaf7807cfc54d723df44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58915f2e3bf8e239dde371a247d5c99b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__factory.htm#a58915f2e3bf8e239dde371a247d5c99b">dump_status</a> )(<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, <a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> detail)</td></tr>
<tr class="separator:a58915f2e3bf8e239dde371a247d5c99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ebe7415a827ed489f3df87584d48bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__factory.htm#ae1ebe7415a827ed489f3df87584d48bf">on_block_alloc</a> )(<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td></tr>
<tr class="separator:ae1ebe7415a827ed489f3df87584d48bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0ab2d3ff39b22a95d5737b39fa86fe"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__factory.htm#a8b0ab2d3ff39b22a95d5737b39fa86fe">on_block_free</a> )(<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td></tr>
<tr class="separator:a8b0ab2d3ff39b22a95d5737b39fa86fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4ec9690707de7689e7254e234d920e"><td class="memItemLeft" align="right" valign="top"><a id="a2e4ec9690707de7689e7254e234d920e" name="a2e4ec9690707de7689e7254e234d920e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dummy</b></td></tr>
<tr class="separator:a2e4ec9690707de7689e7254e234d920e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This structure contains the declaration for pool factory interface.</p>
<p >Forward declaration for memory pool factory. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a4a2381d64670b2ac232aad718be4db91" name="a4a2381d64670b2ac232aad718be4db91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2381d64670b2ac232aad718be4db91">&#9670;&nbsp;</a></span>create_pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *(* pj_pool_factory::create_pool) (<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, const char *name, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> initial_size, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> increment_size, <a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *callback)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a new pool from the pool factory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The pool factory. </td></tr>
    <tr><td class="paramname">name</td><td>the name to be assigned to the pool. The name should not be longer than PJ_MAX_OBJ_NAME (32 chars), or otherwise it will be truncated. </td></tr>
    <tr><td class="paramname">initial_size</td><td>the size of initial memory blocks taken by the pool. Note that the pool will take 68+20 bytes for administrative area from this block. </td></tr>
    <tr><td class="paramname">increment_size</td><td>the size of each additional blocks to be allocated when the pool is running out of memory. If user requests memory which is larger than this size, then an error occurs. Note that each time a pool allocates additional block, it needs 20 bytes (equal to sizeof(pj_pool_block)) to store some administrative info. </td></tr>
    <tr><td class="paramname">callback</td><td>Cllback to be called when error occurs in the pool. Note that when an error occurs during pool creation, the callback itself is not called. Instead, NULL will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the memory pool, or NULL. </dd></dl>

</div>
</div>
<a id="a58915f2e3bf8e239dde371a247d5c99b" name="a58915f2e3bf8e239dde371a247d5c99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58915f2e3bf8e239dde371a247d5c99b">&#9670;&nbsp;</a></span>dump_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* pj_pool_factory::dump_status) (<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, <a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> detail)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Dump pool status to log.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The pool factory. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="group__PJ__POOL__FACTORY.htm#gac01712a96e2e33528f6b4e0c44c229b5">pj_pool_factory_dump()</a>.</p>

</div>
</div>
<a id="ae1ebe7415a827ed489f3df87584d48bf" name="ae1ebe7415a827ed489f3df87584d48bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ebe7415a827ed489f3df87584d48bf">&#9670;&nbsp;</a></span>on_block_alloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>(* pj_pool_factory::on_block_alloc) (<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This is optional callback to be called by allocation policy when it allocates a new memory block. The factory may use this callback for example to keep track of the total number of memory blocks currently allocated by applications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The pool factory. </td></tr>
    <tr><td class="paramname">size</td><td>Size requested by application.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUST return PJ_TRUE, otherwise the block allocation is cancelled. </dd></dl>

</div>
</div>
<a id="a8b0ab2d3ff39b22a95d5737b39fa86fe" name="a8b0ab2d3ff39b22a95d5737b39fa86fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0ab2d3ff39b22a95d5737b39fa86fe">&#9670;&nbsp;</a></span>on_block_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* pj_pool_factory::on_block_free) (<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This is optional callback to be called by allocation policy when it frees memory block. The factory may use this callback for example to keep track of the total number of memory blocks currently allocated by applications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The pool factory. </td></tr>
    <tr><td class="paramname">size</td><td>Size freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a767d5e5bd2bf77fa6d10ef79b34e8e29" name="a767d5e5bd2bf77fa6d10ef79b34e8e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767d5e5bd2bf77fa6d10ef79b34e8e29">&#9670;&nbsp;</a></span>policy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a> pj_pool_factory::policy</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Memory pool policy. </p>

</div>
</div>
<a id="ab613ecd3620eaf7807cfc54d723df44b" name="ab613ecd3620eaf7807cfc54d723df44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab613ecd3620eaf7807cfc54d723df44b">&#9670;&nbsp;</a></span>release_pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* pj_pool_factory::release_pool) (<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Release the pool to the pool factory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The pool factory. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="pool_8h_source.htm">pool.h</a></li>
<li><a class="el" href="pool__alt_8h_source.htm">pool_alt.h</a></li>
</ul>
</div><!-- contents -->
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>
<!--#include virtual="/footer.html" -->
</BODY>
</HTML>
