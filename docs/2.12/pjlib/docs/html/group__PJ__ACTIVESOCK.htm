<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Active socket I/O (2.12)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Active socket I/O<div class="ingroups"><a class="el" href="group__PJ__OS.htm">Operating System Dependent Functionality.</a> &raquo; <a class="el" href="group__PJ__IO.htm">Input/Output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Active socket performs active operations on socket.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__activesock__cb.htm">pj_activesock_cb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2374729a4261eb7a1e780110bcef2e37"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a></td></tr>
<tr class="separator:ga2374729a4261eb7a1e780110bcef2e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga58b5e99dfabf0c15aefc42db69beb2cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga58b5e99dfabf0c15aefc42db69beb2cb">pj_activesock_cfg_default</a> (<a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a> *cfg)</td></tr>
<tr class="separator:ga58b5e99dfabf0c15aefc42db69beb2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad8adb25f996f1ae75a2b1e98e15e584"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gaad8adb25f996f1ae75a2b1e98e15e584">pj_activesock_create</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a> sock, <a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> sock_type, const <a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a> *opt, <a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *ioqueue, const <a class="el" href="structpj__activesock__cb.htm">pj_activesock_cb</a> *cb, void *user_data, <a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> **p_asock)</td></tr>
<tr class="separator:gaad8adb25f996f1ae75a2b1e98e15e584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff5c0d4bb59a5085d2215b7530ace68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gafff5c0d4bb59a5085d2215b7530ace68">pj_activesock_create_udp</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, const <a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *addr, const <a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a> *opt, <a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *ioqueue, const <a class="el" href="structpj__activesock__cb.htm">pj_activesock_cb</a> *cb, void *user_data, <a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> **p_asock, <a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *bound_addr)</td></tr>
<tr class="separator:gafff5c0d4bb59a5085d2215b7530ace68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8a9253fe6327c82871e92f7e6bcd8d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gac8a9253fe6327c82871e92f7e6bcd8d6">pj_activesock_close</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock)</td></tr>
<tr class="separator:gac8a9253fe6327c82871e92f7e6bcd8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35500827f3657a40c07a62e2fd423917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga35500827f3657a40c07a62e2fd423917">pj_activesock_set_user_data</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, void *user_data)</td></tr>
<tr class="separator:ga35500827f3657a40c07a62e2fd423917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5a45c643541dbdd6d74a633fb28207d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gac5a45c643541dbdd6d74a633fb28207d">pj_activesock_get_user_data</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock)</td></tr>
<tr class="separator:gac5a45c643541dbdd6d74a633fb28207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5faf21c01d9a606aa014a2f2791183"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gaff5faf21c01d9a606aa014a2f2791183">pj_activesock_start_read</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, unsigned buff_size, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> flags)</td></tr>
<tr class="separator:gaff5faf21c01d9a606aa014a2f2791183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad392064eddce34de3a4d52a65ce94861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gad392064eddce34de3a4d52a65ce94861">pj_activesock_start_read2</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, unsigned buff_size, void *readbuf[], <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> flags)</td></tr>
<tr class="separator:gad392064eddce34de3a4d52a65ce94861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48dbb84c14a6a0f53adcda91d6d8ae1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga48dbb84c14a6a0f53adcda91d6d8ae1e">pj_activesock_start_recvfrom</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, unsigned buff_size, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> flags)</td></tr>
<tr class="separator:ga48dbb84c14a6a0f53adcda91d6d8ae1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5d12dc84bd0bd35027f104b3edc8437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gad5d12dc84bd0bd35027f104b3edc8437">pj_activesock_start_recvfrom2</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, unsigned buff_size, void *readbuf[], <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> flags)</td></tr>
<tr class="separator:gad5d12dc84bd0bd35027f104b3edc8437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1bc3760aa6b278e8ace0841a0fd7f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gaaa1bc3760aa6b278e8ace0841a0fd7f5">pj_activesock_send</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structsend__key.htm">send_key</a>, const void *data, <a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *size, unsigned flags)</td></tr>
<tr class="separator:gaaa1bc3760aa6b278e8ace0841a0fd7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39e1466848c1d13642a65f063423ae44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga39e1466848c1d13642a65f063423ae44">pj_activesock_sendto</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structsend__key.htm">send_key</a>, const void *data, <a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *size, unsigned flags, const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *addr, <a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> addr_len)</td></tr>
<tr class="separator:ga39e1466848c1d13642a65f063423ae44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea8588339a3981d944a8cf14847f1140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gaea8588339a3981d944a8cf14847f1140">pj_activesock_start_accept</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr class="separator:gaea8588339a3981d944a8cf14847f1140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85245f4b7bfd186a2e2f28611a343133"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga85245f4b7bfd186a2e2f28611a343133">pj_activesock_start_connect</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *remaddr, <a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> addr_len)</td></tr>
<tr class="separator:ga85245f4b7bfd186a2e2f28611a343133"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Active socket performs active operations on socket. </p>
<p>Active socket is a higher level abstraction to the ioqueue. It provides automation to socket operations which otherwise would have to be done manually by the applications. For example with socket recv(), recvfrom(), and accept() operations, application only needs to invoke these operation once, and it will be notified whenever data or incoming TCP connection (in the case of accept()) arrives. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga2374729a4261eb7a1e780110bcef2e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2374729a4261eb7a1e780110bcef2e37">&#9670;&nbsp;</a></span>pj_activesock_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> <a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This opaque structure describes the active socket. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga58b5e99dfabf0c15aefc42db69beb2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58b5e99dfabf0c15aefc42db69beb2cb">&#9670;&nbsp;</a></span>pj_activesock_cfg_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_activesock_cfg_default </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the active socket configuration with the default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>The configuration to be initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac8a9253fe6327c82871e92f7e6bcd8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8a9253fe6327c82871e92f7e6bcd8d6">&#9670;&nbsp;</a></span>pj_activesock_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&#160;</td>
          <td class="paramname"><em>asock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the active socket. This will unregister the socket from the ioqueue and ultimately close the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asock</td><td>The active socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a id="gaad8adb25f996f1ae75a2b1e98e15e584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad8adb25f996f1ae75a2b1e98e15e584">&#9670;&nbsp;</a></span>pj_activesock_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&#160;</td>
          <td class="paramname"><em>sock_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a> *&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *&#160;</td>
          <td class="paramname"><em>ioqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__activesock__cb.htm">pj_activesock_cb</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> **&#160;</td>
          <td class="paramname"><em>p_asock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the active socket for the specified socket. This will register the socket to the specified ioqueue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool to allocate memory from. </td></tr>
    <tr><td class="paramname">sock</td><td>The socket handle. </td></tr>
    <tr><td class="paramname">sock_type</td><td>Specify socket type, either <a class="el" href="group__PJ__SOCK.htm#gaaa5fa1293ffc11d0970811819b3828dc">pj_SOCK_DGRAM()</a> or <a class="el" href="group__PJ__SOCK.htm#gae224fbf8e8bd55b40030fcd8f9645291">pj_SOCK_STREAM()</a>. The active socket needs this information to handle connection closure for connection oriented sockets. </td></tr>
    <tr><td class="paramname">ioqueue</td><td>The ioqueue to use. </td></tr>
    <tr><td class="paramname">opt</td><td>Optional settings. When this setting is not specifed, the default values will be used. </td></tr>
    <tr><td class="paramname">cb</td><td>Pointer to structure containing application callbacks. </td></tr>
    <tr><td class="paramname">user_data</td><td>Arbitrary user data to be associated with this active socket. </td></tr>
    <tr><td class="paramname">p_asock</td><td>Pointer to receive the active socket instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a id="gafff5c0d4bb59a5085d2215b7530ace68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafff5c0d4bb59a5085d2215b7530ace68">&#9670;&nbsp;</a></span>pj_activesock_create_udp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_create_udp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a> *&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *&#160;</td>
          <td class="paramname"><em>ioqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__activesock__cb.htm">pj_activesock_cb</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> **&#160;</td>
          <td class="paramname"><em>p_asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *&#160;</td>
          <td class="paramname"><em>bound_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create UDP socket descriptor, bind it to the specified address, and create the active socket for the socket descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool to allocate memory from. </td></tr>
    <tr><td class="paramname">addr</td><td>Specifies the address family of the socket and the address where the socket should be bound to. If this argument is NULL, then AF_INET is assumed and the socket will be bound to any addresses and port. </td></tr>
    <tr><td class="paramname">opt</td><td>Optional settings. When this setting is not specifed, the default values will be used. </td></tr>
    <tr><td class="paramname">cb</td><td>Pointer to structure containing application callbacks. </td></tr>
    <tr><td class="paramname">user_data</td><td>Arbitrary user data to be associated with this active socket. </td></tr>
    <tr><td class="paramname">p_asock</td><td>Pointer to receive the active socket instance. </td></tr>
    <tr><td class="paramname">bound_addr</td><td>If this argument is specified, it will be filled with the bound address on return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a id="gac5a45c643541dbdd6d74a633fb28207d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5a45c643541dbdd6d74a633fb28207d">&#9670;&nbsp;</a></span>pj_activesock_get_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pj_activesock_get_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&#160;</td>
          <td class="paramname"><em>asock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the user data previously associated with this active socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asock</td><td>The active socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The user data. </dd></dl>

</div>
</div>
<a id="gaaa1bc3760aa6b278e8ace0841a0fd7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa1bc3760aa6b278e8ace0841a0fd7f5">&#9670;&nbsp;</a></span>pj_activesock_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&#160;</td>
          <td class="paramname"><em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *&#160;</td>
          <td class="paramname"><em>send_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send data using the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asock</td><td>The active socket. </td></tr>
    <tr><td class="paramname"><a class="el" href="structsend__key.htm">send_key</a></td><td>The operation key to send the data, which is useful if application wants to submit multiple pending send operations and want to track which exact data has been sent in the <em>on_data_sent()</em> callback. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. This data must remain valid until the data has been sent. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to be given to <a class="el" href="group__PJ__IOQUEUE.htm#gabf96d153949aeda0e7b9dbb742ffcda7">pj_ioqueue_send()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS if data has been sent immediately, or PJ_EPENDING if data cannot be sent immediately. In this case the <em>on_data_sent()</em> callback will be called when data is actually sent. Any other return value indicates error condition. </dd></dl>

</div>
</div>
<a id="ga39e1466848c1d13642a65f063423ae44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39e1466848c1d13642a65f063423ae44">&#9670;&nbsp;</a></span>pj_activesock_sendto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_sendto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&#160;</td>
          <td class="paramname"><em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *&#160;</td>
          <td class="paramname"><em>send_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&#160;</td>
          <td class="paramname"><em>addr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send datagram using the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asock</td><td>The active socket. </td></tr>
    <tr><td class="paramname"><a class="el" href="structsend__key.htm">send_key</a></td><td>The operation key to send the data, which is useful if application wants to submit multiple pending send operations and want to track which exact data has been sent in the <em>on_data_sent()</em> callback. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. This data must remain valid until the data has been sent. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to be given to <a class="el" href="group__PJ__IOQUEUE.htm#gabf96d153949aeda0e7b9dbb742ffcda7">pj_ioqueue_send()</a>. </td></tr>
    <tr><td class="paramname">addr</td><td>The destination address. </td></tr>
    <tr><td class="paramname">addr_len</td><td>The length of the address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS if data has been sent immediately, or PJ_EPENDING if data cannot be sent immediately. In this case the <em>on_data_sent()</em> callback will be called when data is actually sent. Any other return value indicates error condition. </dd></dl>

</div>
</div>
<a id="ga35500827f3657a40c07a62e2fd423917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35500827f3657a40c07a62e2fd423917">&#9670;&nbsp;</a></span>pj_activesock_set_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_set_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&#160;</td>
          <td class="paramname"><em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associate arbitrary data with the active socket. Application may inspect this data in the callbacks and associate it with higher level processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asock</td><td>The active socket. </td></tr>
    <tr><td class="paramname">user_data</td><td>The user data to be associated with the active socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a id="gaea8588339a3981d944a8cf14847f1140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea8588339a3981d944a8cf14847f1140">&#9670;&nbsp;</a></span>pj_activesock_start_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_start_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&#160;</td>
          <td class="paramname"><em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts asynchronous socket accept() operations on this active socket. Application must bind the socket before calling this function. This function will issue <em>async_cnt</em> number of asynchronous <em>accept()</em> operations to the socket and returns back to caller. Incoming connection on the socket will be reported back to application via the <em>on_accept_complete()</em> callback.</p>
<p>Application only needs to call this function once to initiate accept() operations. Further accept() operations will be done automatically by the active socket when <em>on_accept_complete()</em> callback returns non-zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asock</td><td>The active socket. </td></tr>
    <tr><td class="paramname">pool</td><td>Pool used to allocate some internal data for the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a id="ga85245f4b7bfd186a2e2f28611a343133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85245f4b7bfd186a2e2f28611a343133">&#9670;&nbsp;</a></span>pj_activesock_start_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_start_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&#160;</td>
          <td class="paramname"><em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *&#160;</td>
          <td class="paramname"><em>remaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&#160;</td>
          <td class="paramname"><em>addr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts asynchronous socket connect() operation for this socket. Once the connection is done (either successfully or not), the <em>on_connect_complete()</em> callback will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asock</td><td>The active socket. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate some internal data for the operation. </td></tr>
    <tr><td class="paramname">remaddr</td><td>Remote address. </td></tr>
    <tr><td class="paramname">addr_len</td><td>Length of the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS if connection can be established immediately, or PJ_EPENDING if connection cannot be established immediately. In this case the <em>on_connect_complete()</em> callback will be called when connection is complete. Any other return value indicates error condition. </dd></dl>

</div>
</div>
<a id="gaff5faf21c01d9a606aa014a2f2791183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff5faf21c01d9a606aa014a2f2791183">&#9670;&nbsp;</a></span>pj_activesock_start_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_start_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&#160;</td>
          <td class="paramname"><em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>buff_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts read operation on this active socket. This function will create <em>async_cnt</em> number of buffers (the <em>async_cnt</em> parameter was given in <em><a class="el" href="group__PJ__ACTIVESOCK.htm#gaad8adb25f996f1ae75a2b1e98e15e584">pj_activesock_create()</a></em> function) where each buffer is <em>buff_size</em> long. The buffers are allocated from the specified <em>pool</em>. Once the buffers are created, it then issues <em>async_cnt</em> number of asynchronous <em>recv()</em> operations to the socket and returns back to caller. Incoming data on the socket will be reported back to application via the <em>on_data_read()</em> callback.</p>
<p>Application only needs to call this function once to initiate read operations. Further read operations will be done automatically by the active socket when <em>on_data_read()</em> callback returns non-zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asock</td><td>The active socket. </td></tr>
    <tr><td class="paramname">pool</td><td>Pool used to allocate buffers for incoming data. </td></tr>
    <tr><td class="paramname">buff_size</td><td>The size of each buffer, in bytes. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to be given to <a class="el" href="group__PJ__IOQUEUE.htm#ga71e08c6414a6f0cd1c1d2fde267bccbe">pj_ioqueue_recv()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a id="gad392064eddce34de3a4d52a65ce94861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad392064eddce34de3a4d52a65ce94861">&#9670;&nbsp;</a></span>pj_activesock_start_read2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_start_read2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&#160;</td>
          <td class="paramname"><em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>buff_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>readbuf</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="group__PJ__ACTIVESOCK.htm#gaff5faf21c01d9a606aa014a2f2791183">pj_activesock_start_read()</a>, except that the application supplies the buffers for the read operation so that the acive socket does not have to allocate the buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asock</td><td>The active socket. </td></tr>
    <tr><td class="paramname">pool</td><td>Pool used to allocate buffers for incoming data. </td></tr>
    <tr><td class="paramname">buff_size</td><td>The size of each buffer, in bytes. </td></tr>
    <tr><td class="paramname">readbuf</td><td>Array of packet buffers, each has buff_size size. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to be given to <a class="el" href="group__PJ__IOQUEUE.htm#ga71e08c6414a6f0cd1c1d2fde267bccbe">pj_ioqueue_recv()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a id="ga48dbb84c14a6a0f53adcda91d6d8ae1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48dbb84c14a6a0f53adcda91d6d8ae1e">&#9670;&nbsp;</a></span>pj_activesock_start_recvfrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_start_recvfrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&#160;</td>
          <td class="paramname"><em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>buff_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="group__PJ__ACTIVESOCK.htm#gaff5faf21c01d9a606aa014a2f2791183">pj_activesock_start_read()</a>, except that this function is used only for datagram sockets, and it will trigger <em>on_data_recvfrom()</em> callback instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asock</td><td>The active socket. </td></tr>
    <tr><td class="paramname">pool</td><td>Pool used to allocate buffers for incoming data. </td></tr>
    <tr><td class="paramname">buff_size</td><td>The size of each buffer, in bytes. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to be given to <a class="el" href="group__PJ__IOQUEUE.htm#ga374d409596460c721e6c185e4a13f25d">pj_ioqueue_recvfrom()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a id="gad5d12dc84bd0bd35027f104b3edc8437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5d12dc84bd0bd35027f104b3edc8437">&#9670;&nbsp;</a></span>pj_activesock_start_recvfrom2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_start_recvfrom2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&#160;</td>
          <td class="paramname"><em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>buff_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>readbuf</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="group__PJ__ACTIVESOCK.htm#ga48dbb84c14a6a0f53adcda91d6d8ae1e">pj_activesock_start_recvfrom()</a> except that the recvfrom() operation takes the buffer from the argument rather than creating new ones.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asock</td><td>The active socket. </td></tr>
    <tr><td class="paramname">pool</td><td>Pool used to allocate buffers for incoming data. </td></tr>
    <tr><td class="paramname">buff_size</td><td>The size of each buffer, in bytes. </td></tr>
    <tr><td class="paramname">readbuf</td><td>Array of packet buffers, each has buff_size size. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to be given to <a class="el" href="group__PJ__IOQUEUE.htm#ga374d409596460c721e6c185e4a13f25d">pj_ioqueue_recvfrom()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>
<!--#include virtual="/footer.html" -->
</BODY>
</HTML>
