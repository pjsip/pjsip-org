<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Network Address Resolution (2.12)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Network Address Resolution<div class="ingroups"><a class="el" href="group__PJ__OS.htm">Operating System Dependent Functionality.</a> &raquo; <a class="el" href="group__PJ__IO.htm">Input/Output</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__hostent.htm">pj_hostent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__addrinfo.htm">pj_addrinfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4d04a8261523c8f3473946257c12ce5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pj__addr__resolve.htm#ga4d04a8261523c8f3473946257c12ce5b">h_addr</a>&#160;&#160;&#160;h_addr_list[0]</td></tr>
<tr class="separator:ga4d04a8261523c8f3473946257c12ce5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7c8264aa7743594d31766679dbae0b88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pj__addr__resolve.htm#ga7c8264aa7743594d31766679dbae0b88">pj_gethostbyname</a> (const <a class="el" href="structpj__str__t.htm">pj_str_t</a> *name, <a class="el" href="structpj__hostent.htm">pj_hostent</a> *he)</td></tr>
<tr class="separator:ga7c8264aa7743594d31766679dbae0b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410b1bd02dcabf108b129e95368beef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pj__addr__resolve.htm#ga410b1bd02dcabf108b129e95368beef4">pj_gethostip</a> (<a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> af, <a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *addr)</td></tr>
<tr class="separator:ga410b1bd02dcabf108b129e95368beef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5415309d403c80c47ddd0aba05d46136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pj__addr__resolve.htm#ga5415309d403c80c47ddd0aba05d46136">pj_getipinterface</a> (<a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> af, const <a class="el" href="structpj__str__t.htm">pj_str_t</a> *dst, <a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *itf_addr, <a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> allow_resolve, <a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *p_dst_addr)</td></tr>
<tr class="separator:ga5415309d403c80c47ddd0aba05d46136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a1ddbc8b068fad022db4661bcb9937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pj__addr__resolve.htm#gae9a1ddbc8b068fad022db4661bcb9937">pj_getdefaultipinterface</a> (<a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> af, <a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *addr)</td></tr>
<tr class="separator:gae9a1ddbc8b068fad022db4661bcb9937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf5df28bb11ef770eb4ef5cca7b8f9b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pj__addr__resolve.htm#gaaf5df28bb11ef770eb4ef5cca7b8f9b2">pj_getaddrinfo</a> (<a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> af, const <a class="el" href="structpj__str__t.htm">pj_str_t</a> *name, unsigned *count, <a class="el" href="structpj__addrinfo.htm">pj_addrinfo</a> ai[])</td></tr>
<tr class="separator:gaaf5df28bb11ef770eb4ef5cca7b8f9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module provides function to resolve Internet address of the specified host name. To resolve a particular host name, application can just call <a class="el" href="group__pj__addr__resolve.htm#ga7c8264aa7743594d31766679dbae0b88">pj_gethostbyname()</a>.</p>
<p>Example: </p><pre>
  ...
  <a class="el" href="structpj__hostent.htm">pj_hostent</a> he;
  pj_status_t rc;
  <a class="el" href="structpj__str__t.htm">pj_str_t</a> host = pj_str("host.example.com");</pre><pre>  rc = pj_gethostbyname( &amp;host, &amp;he);
  if (rc != PJ_SUCCESS) {
     char errbuf[80];
     pj_strerror( rc, errbuf, sizeof(errbuf));
     PJ_LOG(2,("sample", "Unable to resolve host, error=%s", errbuf));
     return rc;
  }</pre><pre>  // process address...
  addr.sin_addr.s_addr = *(pj_uint32_t*)he.h_addr;
  ...
</pre><p>It's pretty simple really... </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4d04a8261523c8f3473946257c12ce5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d04a8261523c8f3473946257c12ce5b">&#9670;&nbsp;</a></span>h_addr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define h_addr&#160;&#160;&#160;h_addr_list[0]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shortcut to h_addr_list[0] </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaf5df28bb11ef770eb4ef5cca7b8f9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf5df28bb11ef770eb4ef5cca7b8f9b2">&#9670;&nbsp;</a></span>pj_getaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_getaddrinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__str__t.htm">pj_str_t</a> *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__addrinfo.htm">pj_addrinfo</a>&#160;</td>
          <td class="paramname"><em>ai</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function translates the name of a service location (for example, a host name) and returns a set of addresses and associated information to be used in creating a socket with which to address the specified service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">af</td><td>The desired address family to query. Valid values are <a class="el" href="group__PJ__SOCK.htm#ga8ea303b95fe973432a361e47e0459086">pj_AF_INET()</a>, <a class="el" href="group__PJ__SOCK.htm#ga60a867be35581f776aa88156505309de">pj_AF_INET6()</a>, or <a class="el" href="group__PJ__SOCK.htm#ga70ea77cd531607c6c3ce586d6fbd007d">pj_AF_UNSPEC()</a>. </td></tr>
    <tr><td class="paramname">name</td><td>Descriptive name or an address string, such as host name. </td></tr>
    <tr><td class="paramname">count</td><td>On input, it specifies the number of elements in <em>ai</em> array. On output, this will be set with the number of address informations found for the specified name. </td></tr>
    <tr><td class="paramname">ai</td><td>Array of address info to be filled with the information about the host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS on success, or the appropriate error code. </dd></dl>

</div>
</div>
<a id="gae9a1ddbc8b068fad022db4661bcb9937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9a1ddbc8b068fad022db4661bcb9937">&#9670;&nbsp;</a></span>pj_getdefaultipinterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_getdefaultipinterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the IP address of the default interface. Default interface is the interface of the default route.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">af</td><td>The desired address family to query. Valid values are <a class="el" href="group__PJ__SOCK.htm#ga8ea303b95fe973432a361e47e0459086">pj_AF_INET()</a> or <a class="el" href="group__PJ__SOCK.htm#ga60a867be35581f776aa88156505309de">pj_AF_INET6()</a>. </td></tr>
    <tr><td class="paramname">addr</td><td>On successful resolution, the address family and address part of this socket address will be filled up with the host IP address, in network byte order. Other parts of the socket address are untouched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS on success, or the appropriate error code. </dd></dl>

</div>
</div>
<a id="ga7c8264aa7743594d31766679dbae0b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c8264aa7743594d31766679dbae0b88">&#9670;&nbsp;</a></span>pj_gethostbyname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_gethostbyname </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpj__str__t.htm">pj_str_t</a> *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__hostent.htm">pj_hostent</a> *&#160;</td>
          <td class="paramname"><em>he</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function fills the structure of type <a class="el" href="structpj__hostent.htm">pj_hostent</a> for a given host name. For host resolution function that also works with IPv6, please see <a class="el" href="group__pj__addr__resolve.htm#gaaf5df28bb11ef770eb4ef5cca7b8f9b2">pj_getaddrinfo()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Host name to resolve. Specifying IPv4 address here may fail on some platforms (e.g. Windows) </td></tr>
    <tr><td class="paramname">he</td><td>The <a class="el" href="structpj__hostent.htm">pj_hostent</a> structure to be filled. Note that the pointers in this structure points to temporary variables which value will be reset upon subsequent invocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS, or the appropriate error codes. </dd></dl>

</div>
</div>
<a id="ga410b1bd02dcabf108b129e95368beef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga410b1bd02dcabf108b129e95368beef4">&#9670;&nbsp;</a></span>pj_gethostip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_gethostip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resolve the primary IP address of local host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">af</td><td>The desired address family to query. Valid values are <a class="el" href="group__PJ__SOCK.htm#ga8ea303b95fe973432a361e47e0459086">pj_AF_INET()</a> or <a class="el" href="group__PJ__SOCK.htm#ga60a867be35581f776aa88156505309de">pj_AF_INET6()</a>. </td></tr>
    <tr><td class="paramname">addr</td><td>On successful resolution, the address family and address part of this socket address will be filled up with the host IP address, in network byte order. Other parts of the socket address are untouched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS on success, or the appropriate error code. </dd></dl>

</div>
</div>
<a id="ga5415309d403c80c47ddd0aba05d46136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5415309d403c80c47ddd0aba05d46136">&#9670;&nbsp;</a></span>pj_getipinterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_getipinterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__str__t.htm">pj_str_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *&#160;</td>
          <td class="paramname"><em>itf_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&#160;</td>
          <td class="paramname"><em>allow_resolve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *&#160;</td>
          <td class="paramname"><em>p_dst_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the interface IP address to send data to the specified destination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">af</td><td>The desired address family to query. Valid values are <a class="el" href="group__PJ__SOCK.htm#ga8ea303b95fe973432a361e47e0459086">pj_AF_INET()</a> or <a class="el" href="group__PJ__SOCK.htm#ga60a867be35581f776aa88156505309de">pj_AF_INET6()</a>. </td></tr>
    <tr><td class="paramname">dst</td><td>The destination host. </td></tr>
    <tr><td class="paramname">itf_addr</td><td>On successful resolution, the address family and address part of this socket address will be filled up with the host IP address, in network byte order. Other parts of the socket address should be ignored. </td></tr>
    <tr><td class="paramname">allow_resolve</td><td>If <em>dst</em> may contain hostname (instead of IP address), specify whether hostname resolution should be performed. If not, default interface address will be returned. </td></tr>
    <tr><td class="paramname">p_dst_addr</td><td>If not NULL, it will be filled with the IP address of the destination host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS on success, or the appropriate error code. </dd></dl>

</div>
</div>
</div><!-- contents -->
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>
<!--#include virtual="/footer.html" -->
</BODY>
</HTML>
