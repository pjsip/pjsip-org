<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PJLIB Reference: Caching Pool Factory (1.16)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>


<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.htm"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Caching Pool Factory<br/>
<small>
[<a class="el" href="group__PJ__POOL__GROUP.htm">Fast Memory Pool</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Caching pool is one sample implementation of pool factory where the factory can reuse memory to create a pool. Application defines what the maximum memory the factory can hold, and when a pool is released the factory decides whether to destroy the pool or to keep it for future use. If the total amount of memory in the internal cache is still within the limit, the factory will keep the pool in the internal cache, otherwise the pool will be destroyed, thus releasing the memory back to the system.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__caching__pool.htm">pj_caching_pool</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__CACHING__POOL.htm#gaab4b67d443e59e3da94eef050d3771e3">PJ_CACHING_POOL_ARRAY_SIZE</a>&nbsp;&nbsp;&nbsp;16</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__CACHING__POOL.htm#gafbf5400f191e2095240bc6472754e94f">pj_caching_pool_init</a> (<a class="el" href="structpj__caching__pool.htm">pj_caching_pool</a> *ch_pool, const <a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a> *policy, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> max_capacity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__CACHING__POOL.htm#ga4c912e7d9e08dae33c2fecea9f1949bc">pj_caching_pool_destroy</a> (<a class="el" href="structpj__caching__pool.htm">pj_caching_pool</a> *ch_pool)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Caching pool is one sample implementation of pool factory where the factory can reuse memory to create a pool. Application defines what the maximum memory the factory can hold, and when a pool is released the factory decides whether to destroy the pool or to keep it for future use. If the total amount of memory in the internal cache is still within the limit, the factory will keep the pool in the internal cache, otherwise the pool will be destroyed, thus releasing the memory back to the system. </p>
<p>// PJ_POOL_FACTORY </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaab4b67d443e59e3da94eef050d3771e3"></a><!-- doxytag: member="pool.h::PJ_CACHING_POOL_ARRAY_SIZE" ref="gaab4b67d443e59e3da94eef050d3771e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PJ_CACHING_POOL_ARRAY_SIZE&nbsp;&nbsp;&nbsp;16</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of unique sizes, to be used as index to the free list. Each pool in the free list is organized by it's size. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga4c912e7d9e08dae33c2fecea9f1949bc"></a><!-- doxytag: member="pool.h::pj_caching_pool_destroy" ref="ga4c912e7d9e08dae33c2fecea9f1949bc" args="(pj_caching_pool *ch_pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_caching_pool_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__caching__pool.htm">pj_caching_pool</a> *&nbsp;</td>
          <td class="paramname"> <em>ch_pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy caching pool, and release all the pools in the recycling list.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ch_pool</em>&nbsp;</td><td>The caching pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafbf5400f191e2095240bc6472754e94f"></a><!-- doxytag: member="pool.h::pj_caching_pool_init" ref="gafbf5400f191e2095240bc6472754e94f" args="(pj_caching_pool *ch_pool, const pj_pool_factory_policy *policy, pj_size_t max_capacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_caching_pool_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__caching__pool.htm">pj_caching_pool</a> *&nbsp;</td>
          <td class="paramname"> <em>ch_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>max_capacity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize caching pool.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ch_pool</em>&nbsp;</td><td>The caching pool factory to be initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>policy</em>&nbsp;</td><td>Pool factory policy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_capacity</em>&nbsp;</td><td>The total capacity to be retained in the cache. When the pool is returned to the cache, it will be kept in recycling list if the total capacity of pools in this list plus the capacity of the pool is still below this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
