<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PJLIB Reference: IOQueue: I/O Event Dispatching with Proactor Pattern (1.16)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>


<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.htm"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>IOQueue: I/O Event Dispatching with Proactor Pattern<br/>
<small>
[<a class="el" href="group__PJ__IO.htm">Input/Output</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__ioqueue__callback.htm">pj_ioqueue_callback</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gacdcf09fc8599097af2a8932d8df39f36">PJ_IOQUEUE_MAX_EVENTS_IN_SINGLE_POLL</a>&nbsp;&nbsp;&nbsp;(16)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga64cc9963980016a7862bb89d1f9961ca">PJ_IOQUEUE_ALWAYS_ASYNC</a>&nbsp;&nbsp;&nbsp;((<a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>)1 &lt;&lt; (<a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>)31)</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga6ddc0236e7d3b92c6be3fed720bab47b">pj_ioqueue_operation_e</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__PJ__IOQUEUE.htm#gga6ddc0236e7d3b92c6be3fed720bab47bad1d58e0afc2e80cc0c7e0d669dd1cb95">PJ_IOQUEUE_OP_NONE</a> =  0, 
<a class="el" href="group__PJ__IOQUEUE.htm#gga6ddc0236e7d3b92c6be3fed720bab47ba3c9e119e2669740ba965f724d8d7f5a7">PJ_IOQUEUE_OP_READ</a> =  1, 
<a class="el" href="group__PJ__IOQUEUE.htm#gga6ddc0236e7d3b92c6be3fed720bab47ba389865c07fc00b0d7fbd3fad52497715">PJ_IOQUEUE_OP_RECV</a> =  2, 
<a class="el" href="group__PJ__IOQUEUE.htm#gga6ddc0236e7d3b92c6be3fed720bab47ba399794bb902a9b7f8364eb4e76d26f7d">PJ_IOQUEUE_OP_RECV_FROM</a> =  4, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__PJ__IOQUEUE.htm#gga6ddc0236e7d3b92c6be3fed720bab47ba4af94279ce626c3a0767a49bdd0e5836">PJ_IOQUEUE_OP_WRITE</a> =  8, 
<a class="el" href="group__PJ__IOQUEUE.htm#gga6ddc0236e7d3b92c6be3fed720bab47ba658b81e5d5a5308cc35e389b019d27ea">PJ_IOQUEUE_OP_SEND</a> =  16, 
<a class="el" href="group__PJ__IOQUEUE.htm#gga6ddc0236e7d3b92c6be3fed720bab47ba08b34d4e6f387d8cf4d4c32fc6257c6a">PJ_IOQUEUE_OP_SEND_TO</a> =  32, 
<a class="el" href="group__PJ__IOQUEUE.htm#gga6ddc0236e7d3b92c6be3fed720bab47ba760ff32815e4f66b2cb847e19c057a25">PJ_IOQUEUE_OP_ACCEPT</a> =  64, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__PJ__IOQUEUE.htm#gga6ddc0236e7d3b92c6be3fed720bab47ba89257623b7b5a70ee4762c7802aa288e">PJ_IOQUEUE_OP_CONNECT</a> =  128
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga6179808511eccf51f35944c4b7de679e">pj_ioqueue_name</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gaae188673e57ae841d586a738e53cffc5">pj_ioqueue_create</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> max_fd, <a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> **ioqueue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga59f004632b9ae20e43fa573e6b6cb237">pj_ioqueue_destroy</a> (<a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *ioque)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga983c8011148c497b1c7385370c9eb57b">pj_ioqueue_set_lock</a> (<a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *ioque, <a class="el" href="group__PJ__BASIC.htm#ga3dc49084043901d31c7b12e5afc9fb2f">pj_lock_t</a> *lock, <a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> auto_delete)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga61f080c7c8d52bcf5e2d955257fde21e">pj_ioqueue_set_default_concurrency</a> (<a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *ioqueue, <a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> allow)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gada2faae3ca27a917b90f6fa39b758355">pj_ioqueue_register_sock</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *ioque, <a class="el" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a> sock, void *user_data, const <a class="el" href="structpj__ioqueue__callback.htm">pj_ioqueue_callback</a> *cb, <a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> **key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga7c05e3b02e71e7680679c90c2adbe230">pj_ioqueue_unregister</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga238dc908101226262f8ba91393e12efc">pj_ioqueue_get_user_data</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga4bc8e251b19facfe3b0bbcc65117155c">pj_ioqueue_set_user_data</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, void *user_data, void **old_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gac9a11ef3e95391eb85193bb15284af93">pj_ioqueue_set_concurrency</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> allow)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gad418678f2f2444232ad490d258ab3acc">pj_ioqueue_lock_key</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gaa5d5a7ce4360cc2506ef2557f4815522">pj_ioqueue_unlock_key</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga2ef6f3b6077c716793e2b4a488e03fe4">pj_ioqueue_op_key_init</a> (<a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structop__key.htm">op_key</a>, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga740d28a04a46e6c1f7a4ae69ac0670bc">pj_ioqueue_is_pending</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structop__key.htm">op_key</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gad3efb211e789eeb8899e41550bc99006">pj_ioqueue_post_completion</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structop__key.htm">op_key</a>, <a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> bytes_status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gaf7505cc18b3031e43e68c5fd4a7a388e">pj_ioqueue_accept</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structop__key.htm">op_key</a>, <a class="el" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a> *new_sock, <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *local, <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *remote, int *addrlen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gaf73fd64e7fbfa50b2c9ca7b00ceaea0b">pj_ioqueue_connect</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *addr, int addrlen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gac65cc5cb9a04f2008d1fa62709ba2d91">pj_ioqueue_poll</a> (<a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *ioque, const <a class="el" href="structpj__time__val.htm">pj_time_val</a> *timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga71e08c6414a6f0cd1c1d2fde267bccbe">pj_ioqueue_recv</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structop__key.htm">op_key</a>, void *buffer, <a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *length, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga374d409596460c721e6c185e4a13f25d">pj_ioqueue_recvfrom</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structop__key.htm">op_key</a>, void *buffer, <a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *length, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> flags, <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *addr, int *addrlen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gabf96d153949aeda0e7b9dbb742ffcda7">pj_ioqueue_send</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structop__key.htm">op_key</a>, const void *data, <a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *length, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gad9eaa7c7b2668255d6ee1a0bf3afb007">pj_ioqueue_sendto</a> (<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structop__key.htm">op_key</a>, const void *data, <a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *length, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> flags, const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *addr, int addrlen)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga3ed26947c228ad86494baf4c0b9272de">pj_ioqueue_op_key_t::activesock_data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gab06c131ab29b37c027f2400bd5be6045">pj_ioqueue_op_key_t::user_data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#gad79249d319b012a8366921e277299dc7">pj_ioqueue_callback::on_write_complete</a> )(<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structop__key.htm">op_key</a>, <a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> bytes_sent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga4330720fb952bd7c256d2752418bcc66">pj_ioqueue_callback::on_accept_complete</a> )(<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structop__key.htm">op_key</a>, <a class="el" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a> sock, <a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__IOQUEUE.htm#ga268a5bf548a9656a8652e35b567f7776">pj_ioqueue_callback::on_connect_complete</a> )(<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>I/O Queue provides API for performing asynchronous I/O operations. It conforms to proactor pattern, which allows application to submit an asynchronous operation and to be notified later when the operation has completed.</p>
<p>The I/O Queue can work on both socket and file descriptors. For asynchronous file operations however, one must make sure that the correct file I/O back-end is used, because not all file I/O back-end can be used with the ioqueue. Please see <a class="el" href="group__PJ__FILE__IO.htm">File I/O</a> for more details.</p>
<p>The framework works natively in platforms where asynchronous operation API exists, such as in Windows NT with IoCompletionPort/IOCP. In other platforms, the I/O queue abstracts the operating system's event poll API to provide semantics similar to IoCompletionPort with minimal penalties (i.e. per ioqueue and per handle mutex protection).</p>
<p>The I/O queue provides more than just unified abstraction. It also:</p>
<ul>
<li>makes sure that the operation uses the most effective way to utilize the underlying mechanism, to achieve the maximum theoritical throughput possible on a given platform.</li>
<li>choose the most efficient mechanism for event polling on a given platform.</li>
</ul>
<p>Currently, the I/O Queue is implemented using:</p>
<ul>
<li><code><b>select()</b></code>, as the common denominator, but the least efficient. Also the number of descriptor is limited to <code>PJ_IOQUEUE_MAX_HANDLES</code> (which by default is 64).</li>
<li><code><b>/dev/epoll</b></code> on Linux (user mode and kernel mode), a much faster replacement for select() on Linux (and more importantly doesn't have limitation on number of descriptors).</li>
<li><b>I/O Completion ports</b> on Windows NT/2000/XP, which is the most efficient way to dispatch events in Windows NT based OSes, and most importantly, it doesn't have the limit on how many handles to monitor. And it works with files (not only sockets) as well.</li>
</ul>
<h2><a class="anchor" id="pj_ioqueue_concurrency_sec"></a>
Concurrency Rules</h2>
<p>The ioqueue has been fine tuned to allow multiple threads to poll the handles simultaneously, to maximize scalability when the application is running on multiprocessor systems. When more than one threads are polling the ioqueue and there are more than one handles are signaled, more than one threads will execute the callback simultaneously to serve the events. These parallel executions are completely safe when the events happen for two different handles.</p>
<p>However, with multithreading, care must be taken when multiple events happen on the same handle, or when event is happening on a handle (and the callback is being executed) and application is performing unregistration to the handle at the same time.</p>
<p>The treatments of above scenario differ according to the concurrency setting that are applied to the handle.</p>
<h3><a class="anchor" id="pj_ioq_concur_set"></a>
Concurrency Settings for Handles</h3>
<p>Concurrency can be set on per handle (key) basis, by using <a class="el" href="group__PJ__IOQUEUE.htm#gac9a11ef3e95391eb85193bb15284af93">pj_ioqueue_set_concurrency()</a> function. The default key concurrency value for the handle is inherited from the key concurrency setting of the ioqueue, and the key concurrency setting for the ioqueue can be changed by using <a class="el" href="group__PJ__IOQUEUE.htm#ga61f080c7c8d52bcf5e2d955257fde21e">pj_ioqueue_set_default_concurrency()</a>. The default key concurrency setting for ioqueue itself is controlled by compile time setting PJ_IOQUEUE_DEFAULT_ALLOW_CONCURRENCY.</p>
<p>Note that this key concurrency setting only controls whether multiple threads are allowed to operate <b>on the same key</b> at the same time. The ioqueue itself always allows multiple threads to enter the ioqeuue at the same time, and also simultaneous callback calls to <b>differrent keys</b> is always allowed regardless to the key concurrency setting.</p>
<h3><a class="anchor" id="pj_ioq_parallel"></a>
Parallel Callback Executions for the Same Handle</h3>
<p>Note that when key concurrency is enabled (i.e. parallel callback calls on the same key is allowed; this is the default setting), the ioqueue will only perform simultaneous callback executions on the same key when the key has invoked multiple pending operations. This could be done for example by calling <a class="el" href="group__PJ__IOQUEUE.htm#ga374d409596460c721e6c185e4a13f25d">pj_ioqueue_recvfrom()</a> more than once on the same key, each with the same key but different operation key (<a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a>). With this scenario, when multiple packets arrive on the key at the same time, more than one threads may execute the callback simultaneously, each with the same key but different operation key.</p>
<p>When there is only one pending operation on the key (e.g. there is only one <a class="el" href="group__PJ__IOQUEUE.htm#ga374d409596460c721e6c185e4a13f25d">pj_ioqueue_recvfrom()</a> invoked on the key), then events occuring to the same key will be queued by the ioqueue, thus no simultaneous callback calls will be performed.</p>
<h3><a class="anchor" id="pj_ioq_allow_concur"></a>
Concurrency is Enabled (Default Value)</h3>
<p>The default setting for the ioqueue is to allow multiple threads to execute callbacks for the same handle/key. This setting is selected to promote good performance and scalability for application.</p>
<p>However this setting has a major drawback with regard to synchronization, and application MUST carefully follow the following guidelines to ensure that parallel access to the key does not cause problems:</p>
<ul>
<li>Always note that callback may be called simultaneously for the same key.</li>
<li><b>Care must be taken when unregistering a key</b> from the ioqueue. Application must take care that when one thread is issuing an unregistration, other thread is not simultaneously invoking the callback <b>to the same key</b>. <br/>
 This happens because the ioqueue functions are working with a pointer to the key, and there is a possible race condition where the pointer has been rendered invalid by other threads before the ioqueue has a chance to acquire mutex on it.</li>
</ul>
<h3><a class="anchor" id="pj_ioq_disallow_concur"></a>
Concurrency is Disabled</h3>
<p>Alternatively, application may disable key concurrency to make synchronization easier. As noted above, there are three ways to control key concurrency setting:</p>
<ul>
<li>by controlling on per handle/key basis, with <a class="el" href="group__PJ__IOQUEUE.htm#gac9a11ef3e95391eb85193bb15284af93">pj_ioqueue_set_concurrency()</a>.</li>
<li>by changing default key concurrency setting on the ioqueue, with <a class="el" href="group__PJ__IOQUEUE.htm#ga61f080c7c8d52bcf5e2d955257fde21e">pj_ioqueue_set_default_concurrency()</a>.</li>
<li>by changing the default concurrency on compile time, by declaring PJ_IOQUEUE_DEFAULT_ALLOW_CONCURRENCY macro to zero in your config_site.h</li>
</ul>
<h2><a class="anchor" id="pj_ioqeuue_examples_sec"></a>
Examples</h2>
<p>For some examples on how to use the I/O Queue, please see:</p>
<ul>
<li><a class="el" href="page_pjlib_ioqueue_tcp_test.htm">Test: I/O Queue (TCP)</a></li>
<li><a class="el" href="page_pjlib_ioqueue_udp_test.htm">Test: I/O Queue (UDP)</a></li>
<li><a class="el" href="page_pjlib_ioqueue_perf_test.htm">Test: I/O Queue Performance</a> </li>
</ul>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga64cc9963980016a7862bb89d1f9961ca"></a><!-- doxytag: member="ioqueue.h::PJ_IOQUEUE_ALWAYS_ASYNC" ref="ga64cc9963980016a7862bb89d1f9961ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PJ_IOQUEUE_ALWAYS_ASYNC&nbsp;&nbsp;&nbsp;((<a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>)1 &lt;&lt; (<a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>)31)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When this flag is specified in ioqueue's recv() or send() operations, the ioqueue will always mark the operation as asynchronous. </p>

</div>
</div>
<a class="anchor" id="gacdcf09fc8599097af2a8932d8df39f36"></a><!-- doxytag: member="ioqueue.h::PJ_IOQUEUE_MAX_EVENTS_IN_SINGLE_POLL" ref="gacdcf09fc8599097af2a8932d8df39f36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PJ_IOQUEUE_MAX_EVENTS_IN_SINGLE_POLL&nbsp;&nbsp;&nbsp;(16)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro specifies the maximum number of events that can be processed by the ioqueue on a single poll cycle, on implementation that supports it. The value is only meaningfull when specified during PJLIB build. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga6ddc0236e7d3b92c6be3fed720bab47b"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_operation_e" ref="ga6ddc0236e7d3b92c6be3fed720bab47b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PJ__IOQUEUE.htm#ga6ddc0236e7d3b92c6be3fed720bab47b">pj_ioqueue_operation_e</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Types of pending I/O Queue operation. This enumeration is only used internally within the ioqueue. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga6ddc0236e7d3b92c6be3fed720bab47bad1d58e0afc2e80cc0c7e0d669dd1cb95"></a><!-- doxytag: member="PJ_IOQUEUE_OP_NONE" ref="gga6ddc0236e7d3b92c6be3fed720bab47bad1d58e0afc2e80cc0c7e0d669dd1cb95" args="" -->PJ_IOQUEUE_OP_NONE</em>&nbsp;</td><td>
<p>No operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6ddc0236e7d3b92c6be3fed720bab47ba3c9e119e2669740ba965f724d8d7f5a7"></a><!-- doxytag: member="PJ_IOQUEUE_OP_READ" ref="gga6ddc0236e7d3b92c6be3fed720bab47ba3c9e119e2669740ba965f724d8d7f5a7" args="" -->PJ_IOQUEUE_OP_READ</em>&nbsp;</td><td>
<p>read() operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6ddc0236e7d3b92c6be3fed720bab47ba389865c07fc00b0d7fbd3fad52497715"></a><!-- doxytag: member="PJ_IOQUEUE_OP_RECV" ref="gga6ddc0236e7d3b92c6be3fed720bab47ba389865c07fc00b0d7fbd3fad52497715" args="" -->PJ_IOQUEUE_OP_RECV</em>&nbsp;</td><td>
<p>recv() operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6ddc0236e7d3b92c6be3fed720bab47ba399794bb902a9b7f8364eb4e76d26f7d"></a><!-- doxytag: member="PJ_IOQUEUE_OP_RECV_FROM" ref="gga6ddc0236e7d3b92c6be3fed720bab47ba399794bb902a9b7f8364eb4e76d26f7d" args="" -->PJ_IOQUEUE_OP_RECV_FROM</em>&nbsp;</td><td>
<p>recvfrom() operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6ddc0236e7d3b92c6be3fed720bab47ba4af94279ce626c3a0767a49bdd0e5836"></a><!-- doxytag: member="PJ_IOQUEUE_OP_WRITE" ref="gga6ddc0236e7d3b92c6be3fed720bab47ba4af94279ce626c3a0767a49bdd0e5836" args="" -->PJ_IOQUEUE_OP_WRITE</em>&nbsp;</td><td>
<p>write() operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6ddc0236e7d3b92c6be3fed720bab47ba658b81e5d5a5308cc35e389b019d27ea"></a><!-- doxytag: member="PJ_IOQUEUE_OP_SEND" ref="gga6ddc0236e7d3b92c6be3fed720bab47ba658b81e5d5a5308cc35e389b019d27ea" args="" -->PJ_IOQUEUE_OP_SEND</em>&nbsp;</td><td>
<p>send() operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6ddc0236e7d3b92c6be3fed720bab47ba08b34d4e6f387d8cf4d4c32fc6257c6a"></a><!-- doxytag: member="PJ_IOQUEUE_OP_SEND_TO" ref="gga6ddc0236e7d3b92c6be3fed720bab47ba08b34d4e6f387d8cf4d4c32fc6257c6a" args="" -->PJ_IOQUEUE_OP_SEND_TO</em>&nbsp;</td><td>
<p>sendto() operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6ddc0236e7d3b92c6be3fed720bab47ba760ff32815e4f66b2cb847e19c057a25"></a><!-- doxytag: member="PJ_IOQUEUE_OP_ACCEPT" ref="gga6ddc0236e7d3b92c6be3fed720bab47ba760ff32815e4f66b2cb847e19c057a25" args="" -->PJ_IOQUEUE_OP_ACCEPT</em>&nbsp;</td><td>
<p>accept() operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6ddc0236e7d3b92c6be3fed720bab47ba89257623b7b5a70ee4762c7802aa288e"></a><!-- doxytag: member="PJ_IOQUEUE_OP_CONNECT" ref="gga6ddc0236e7d3b92c6be3fed720bab47ba89257623b7b5a70ee4762c7802aa288e" args="" -->PJ_IOQUEUE_OP_CONNECT</em>&nbsp;</td><td>
<p>connect() operation. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf7505cc18b3031e43e68c5fd4a7a388e"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_accept" ref="gaf7505cc18b3031e43e68c5fd4a7a388e" args="(pj_ioqueue_key_t *key, pj_ioqueue_op_key_t *op_key, pj_sock_t *new_sock, pj_sockaddr_t *local, pj_sockaddr_t *remote, int *addrlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>new_sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>remote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>addrlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Instruct I/O Queue to accept incoming connection on the specified listening socket. This function will return immediately (i.e. non-blocking) regardless whether a connection is immediately available. If the function can't complete immediately, the caller will be notified about the incoming connection when it calls <a class="el" href="group__PJ__IOQUEUE.htm#gac65cc5cb9a04f2008d1fa62709ba2d91">pj_ioqueue_poll()</a>. If a new connection is immediately available, the function returns PJ_SUCCESS with the new connection; in this case, the callback WILL NOT be called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key which registered to the server socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structop__key.htm">op_key</a></em>&nbsp;</td><td>An operation specific key to be associated with the pending operation, so that application can keep track of which operation has been completed when the callback is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_sock</em>&nbsp;</td><td>Argument which contain pointer to receive the new socket for the incoming connection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>local</em>&nbsp;</td><td>Optional argument which contain pointer to variable to receive local address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>remote</em>&nbsp;</td><td>Optional argument which contain pointer to variable to receive the remote address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addrlen</em>&nbsp;</td><td>On input, contains the length of the buffer for the address, and on output, contains the actual length of the address. This argument is optional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>PJ_SUCCESS When connection is available immediately, and the parameters will be updated to contain information about the new connection. In this case, a completion callback WILL NOT be called.</li>
<li>PJ_EPENDING If no connection is available immediately. When a new connection arrives, the callback will be called.</li>
<li>non-zero which indicates the appropriate error code. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf73fd64e7fbfa50b2c9ca7b00ceaea0b"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_connect" ref="gaf73fd64e7fbfa50b2c9ca7b00ceaea0b" args="(pj_ioqueue_key_t *key, const pj_sockaddr_t *addr, int addrlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>addrlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate non-blocking socket connect. If the socket can NOT be connected immediately, asynchronous connect() will be scheduled and caller will be notified via completion callback when it calls <a class="el" href="group__PJ__IOQUEUE.htm#gac65cc5cb9a04f2008d1fa62709ba2d91">pj_ioqueue_poll()</a>. If socket is connected immediately, the function returns PJ_SUCCESS and completion callback WILL NOT be called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key associated with TCP socket </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The remote address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addrlen</em>&nbsp;</td><td>The remote address length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>PJ_SUCCESS If socket is connected immediately. In this case, the completion callback WILL NOT be called.</li>
<li>PJ_EPENDING If operation is queued, or</li>
<li>non-zero Indicates the error code. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaae188673e57ae841d586a738e53cffc5"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_create" ref="gaae188673e57ae841d586a738e53cffc5" args="(pj_pool_t *pool, pj_size_t max_fd, pj_ioqueue_t **ioqueue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>max_fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> **&nbsp;</td>
          <td class="paramname"> <em>ioqueue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new I/O Queue framework.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The pool to allocate the I/O queue structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_fd</em>&nbsp;</td><td>The maximum number of handles to be supported, which should not exceed PJ_IOQUEUE_MAX_HANDLES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ioqueue</em>&nbsp;</td><td>Pointer to hold the newly created I/O Queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga59f004632b9ae20e43fa573e6b6cb237"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_destroy" ref="ga59f004632b9ae20e43fa573e6b6cb237" args="(pj_ioqueue_t *ioque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ioque</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the I/O queue.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ioque</em>&nbsp;</td><td>The I/O Queue to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga238dc908101226262f8ba91393e12efc"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_get_user_data" ref="ga238dc908101226262f8ba91393e12efc" args="(pj_ioqueue_key_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pj_ioqueue_get_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get user data associated with an ioqueue key.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key that was previously obtained from registration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The user data associated with the descriptor, or NULL on error or if no data is associated with the key during registration. </dd></dl>

</div>
</div>
<a class="anchor" id="ga740d28a04a46e6c1f7a4ae69ac0670bc"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_is_pending" ref="ga740d28a04a46e6c1f7a4ae69ac0670bc" args="(pj_ioqueue_key_t *key, pj_ioqueue_op_key_t *op_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> pj_ioqueue_is_pending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op_key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if operation is pending on the specified operation key. The <code><a class="el" href="structop__key.htm">op_key</a></code> must have been initialized with <a class="el" href="group__PJ__IOQUEUE.htm#ga2ef6f3b6077c716793e2b4a488e03fe4">pj_ioqueue_op_key_init()</a> or submitted as pending operation before, or otherwise the result is undefined.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structop__key.htm">op_key</a></em>&nbsp;</td><td>The operation key, previously submitted to any of the I/O functions and has returned PJ_EPENDING.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Non-zero if operation is still pending. </dd></dl>

</div>
</div>
<a class="anchor" id="gad418678f2f2444232ad490d258ab3acc"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_lock_key" ref="gad418678f2f2444232ad490d258ab3acc" args="(pj_ioqueue_key_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_lock_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire the key's mutex. When the key's concurrency is disabled, application may call this function to synchronize its operation with the key's callback (i.e. this function will block until the key's callback returns).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key that was previously obtained from registration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6179808511eccf51f35944c4b7de679e"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_name" ref="ga6179808511eccf51f35944c4b7de679e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pj_ioqueue_name </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the name of the ioqueue implementation.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Implementation name. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ef6f3b6077c716793e2b4a488e03fe4"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_op_key_init" ref="ga2ef6f3b6077c716793e2b4a488e03fe4" args="(pj_ioqueue_op_key_t *op_key, pj_size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_ioqueue_op_key_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize operation key.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structop__key.htm">op_key</a></em>&nbsp;</td><td>The operation key to be initialied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the operation key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac65cc5cb9a04f2008d1fa62709ba2d91"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_poll" ref="gac65cc5cb9a04f2008d1fa62709ba2d91" args="(pj_ioqueue_t *ioque, const pj_time_val *timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pj_ioqueue_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ioque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__time__val.htm">pj_time_val</a> *&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Poll the I/O Queue for completed events.</p>
<p>Note: polling the ioqueue is not necessary in Symbian. Please see <a class="el" href="group__PJ__SYMBIAN__OS.htm">Symbian OS Specific</a> for more info.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ioque</em>&nbsp;</td><td>the I/O Queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>polling timeout, or NULL if the thread wishes to wait indefinetely for the event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>zero if timed out (no event).</li>
<li>(&lt;0) if error occured during polling. Callback will NOT be called.</li>
<li>(&gt;1) to indicate numbers of events. Callbacks have been called. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad3efb211e789eeb8899e41550bc99006"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_post_completion" ref="gad3efb211e789eeb8899e41550bc99006" args="(pj_ioqueue_key_t *key, pj_ioqueue_op_key_t *op_key, pj_ssize_t bytes_status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_post_completion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a>&nbsp;</td>
          <td class="paramname"> <em>bytes_status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Post completion status to the specified operation key and call the appropriate callback. When the callback is called, the number of bytes received in read/write callback or the status in accept/connect callback will be set from the <code>bytes_status</code> parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structop__key.htm">op_key</a></em>&nbsp;</td><td>Pending operation key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_status</em>&nbsp;</td><td>Number of bytes or status to be set. A good value to put here is -PJ_ECANCELLED.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if completion status has been successfully sent. </dd></dl>

</div>
</div>
<a class="anchor" id="ga71e08c6414a6f0cd1c1d2fde267bccbe"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_recv" ref="ga71e08c6414a6f0cd1c1d2fde267bccbe" args="(pj_ioqueue_key_t *key, pj_ioqueue_op_key_t *op_key, void *buffer, pj_ssize_t *length, pj_uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Instruct the I/O Queue to read from the specified handle. This function returns immediately (i.e. non-blocking) regardless whether some data has been transfered. If the operation can't complete immediately, caller will be notified about the completion when it calls <a class="el" href="group__PJ__IOQUEUE.htm#gac65cc5cb9a04f2008d1fa62709ba2d91">pj_ioqueue_poll()</a>. If data is immediately available, the function will return PJ_SUCCESS and the callback WILL NOT be called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key that uniquely identifies the handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structop__key.htm">op_key</a></em>&nbsp;</td><td>An operation specific key to be associated with the pending operation, so that application can keep track of which operation has been completed when the callback is called. Caller must make sure that this key remains valid until the function completes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer to hold the read data. The caller MUST make sure that this buffer remain valid until the framework completes reading the handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>On input, it specifies the size of the buffer. If data is available to be read immediately, the function returns PJ_SUCCESS and this argument will be filled with the amount of data read. If the function is pending, caller will be notified about the amount of data read in the callback. This parameter can point to local variable in caller's stack and doesn't have to remain valid for the duration of pending operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Recv flag. If flags has PJ_IOQUEUE_ALWAYS_ASYNC then the function will never return PJ_SUCCESS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>PJ_SUCCESS If immediate data has been received in the buffer. In this case, the callback WILL NOT be called.</li>
<li>PJ_EPENDING If the operation has been queued, and the callback will be called when data has been received.</li>
<li>non-zero The return value indicates the error code. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga374d409596460c721e6c185e4a13f25d"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_recvfrom" ref="ga374d409596460c721e6c185e4a13f25d" args="(pj_ioqueue_key_t *key, pj_ioqueue_op_key_t *op_key, void *buffer, pj_ssize_t *length, pj_uint32_t flags, pj_sockaddr_t *addr, int *addrlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_recvfrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>addrlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function behaves similarly as <a class="el" href="group__PJ__IOQUEUE.htm#ga71e08c6414a6f0cd1c1d2fde267bccbe">pj_ioqueue_recv()</a>, except that it is normally called for socket, and the remote address will also be returned along with the data. Caller MUST make sure that both buffer and addr remain valid until the framework completes reading the data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key that uniquely identifies the handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structop__key.htm">op_key</a></em>&nbsp;</td><td>An operation specific key to be associated with the pending operation, so that application can keep track of which operation has been completed when the callback is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer to hold the read data. The caller MUST make sure that this buffer remain valid until the framework completes reading the handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>On input, it specifies the size of the buffer. If data is available to be read immediately, the function returns PJ_SUCCESS and this argument will be filled with the amount of data read. If the function is pending, caller will be notified about the amount of data read in the callback. This parameter can point to local variable in caller's stack and doesn't have to remain valid for the duration of pending operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Recv flag. If flags has PJ_IOQUEUE_ALWAYS_ASYNC then the function will never return PJ_SUCCESS. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Optional Pointer to buffer to receive the address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addrlen</em>&nbsp;</td><td>On input, specifies the length of the address buffer. On output, it will be filled with the actual length of the address. This argument can be NULL if <code>addr</code> is not specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>PJ_SUCCESS If immediate data has been received. In this case, the callback must have been called before this function returns, and no pending operation is scheduled.</li>
<li>PJ_EPENDING If the operation has been queued.</li>
<li>non-zero The return value indicates the error code. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gada2faae3ca27a917b90f6fa39b758355"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_register_sock" ref="gada2faae3ca27a917b90f6fa39b758355" args="(pj_pool_t *pool, pj_ioqueue_t *ioque, pj_sock_t sock, void *user_data, const pj_ioqueue_callback *cb, pj_ioqueue_key_t **key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_register_sock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ioque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a>&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__ioqueue__callback.htm">pj_ioqueue_callback</a> *&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> **&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a socket to the I/O queue framework. When a socket is registered to the IOQueue, it may be modified to use non-blocking IO. If it is modified, there is no guarantee that this modification will be restored after the socket is unregistered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>To allocate the resource for the specified handle, which must be valid until the handle/key is unregistered from I/O Queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ioque</em>&nbsp;</td><td>The I/O Queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>The socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>User data to be associated with the key, which can be retrieved later. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>Callback to be called when I/O operation completes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Pointer to receive the key to be associated with this socket. Subsequent I/O queue operation will need this key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gabf96d153949aeda0e7b9dbb742ffcda7"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_send" ref="gabf96d153949aeda0e7b9dbb742ffcda7" args="(pj_ioqueue_key_t *key, pj_ioqueue_op_key_t *op_key, const void *data, pj_ssize_t *length, pj_uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Instruct the I/O Queue to write to the handle. This function will return immediately (i.e. non-blocking) regardless whether some data has been transfered. If the function can't complete immediately, the caller will be notified about the completion when it calls <a class="el" href="group__PJ__IOQUEUE.htm#gac65cc5cb9a04f2008d1fa62709ba2d91">pj_ioqueue_poll()</a>. If operation completes immediately and data has been transfered, the function returns PJ_SUCCESS and the callback will NOT be called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key that identifies the handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structop__key.htm">op_key</a></em>&nbsp;</td><td>An operation specific key to be associated with the pending operation, so that application can keep track of which operation has been completed when the callback is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The data to send. Caller MUST make sure that this buffer remains valid until the write operation completes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>On input, it specifies the length of data to send. When data was sent immediately, this function returns PJ_SUCCESS and this parameter contains the length of data sent. If data can not be sent immediately, an asynchronous operation is scheduled and caller will be notified via callback the number of bytes sent. This parameter can point to local variable on caller's stack and doesn't have to remain valid until the operation has completed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Send flags. If flags has PJ_IOQUEUE_ALWAYS_ASYNC then the function will never return PJ_SUCCESS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>PJ_SUCCESS If data was immediately transfered. In this case, no pending operation has been scheduled and the callback WILL NOT be called.</li>
<li>PJ_EPENDING If the operation has been queued. Once data base been transfered, the callback will be called.</li>
<li>non-zero The return value indicates the error code. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad9eaa7c7b2668255d6ee1a0bf3afb007"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_sendto" ref="gad9eaa7c7b2668255d6ee1a0bf3afb007" args="(pj_ioqueue_key_t *key, pj_ioqueue_op_key_t *op_key, const void *data, pj_ssize_t *length, pj_uint32_t flags, const pj_sockaddr_t *addr, int addrlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_sendto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>addrlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Instruct the I/O Queue to write to the handle. This function will return immediately (i.e. non-blocking) regardless whether some data has been transfered. If the function can't complete immediately, the caller will be notified about the completion when it calls <a class="el" href="group__PJ__IOQUEUE.htm#gac65cc5cb9a04f2008d1fa62709ba2d91">pj_ioqueue_poll()</a>. If operation completes immediately and data has been transfered, the function returns PJ_SUCCESS and the callback will NOT be called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key that identifies the handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structop__key.htm">op_key</a></em>&nbsp;</td><td>An operation specific key to be associated with the pending operation, so that application can keep track of which operation has been completed when the callback is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the data to send. Caller MUST make sure that this buffer remains valid until the write operation completes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>On input, it specifies the length of data to send. When data was sent immediately, this function returns PJ_SUCCESS and this parameter contains the length of data sent. If data can not be sent immediately, an asynchronous operation is scheduled and caller will be notified via callback the number of bytes sent. This parameter can point to local variable on caller's stack and doesn't have to remain valid until the operation has completed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>send flags. If flags has PJ_IOQUEUE_ALWAYS_ASYNC then the function will never return PJ_SUCCESS. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Optional remote address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addrlen</em>&nbsp;</td><td>Remote address length, <code>addr</code> is specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>PJ_SUCCESS If data was immediately written.</li>
<li>PJ_EPENDING If the operation has been queued.</li>
<li>non-zero The return value indicates the error code. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac9a11ef3e95391eb85193bb15284af93"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_set_concurrency" ref="gac9a11ef3e95391eb85193bb15284af93" args="(pj_ioqueue_key_t *key, pj_bool_t allow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_set_concurrency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>allow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configure whether the ioqueue is allowed to call the key's callback concurrently/in parallel. The default concurrency setting for the key is controlled by ioqueue's default concurrency value, which can be changed by calling <a class="el" href="group__PJ__IOQUEUE.htm#ga61f080c7c8d52bcf5e2d955257fde21e">pj_ioqueue_set_default_concurrency()</a>.</p>
<p>If concurrency is allowed for the key, it means that if there are more than one pending operations complete simultaneously, more than one threads may call the key's callback at the same time. This generally would promote good scalability for application, at the expense of more complexity to manage the concurrent accesses in application's code.</p>
<p>Alternatively application may disable the concurrent access by setting the <em>allow</em> flag to false. With concurrency disabled, only one thread can call the key's callback at one time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key that was previously obtained from registration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>allow</em>&nbsp;</td><td>Set this to non-zero to allow concurrent callback calls and zero (PJ_FALSE) to disallow it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga61f080c7c8d52bcf5e2d955257fde21e"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_set_default_concurrency" ref="ga61f080c7c8d52bcf5e2d955257fde21e" args="(pj_ioqueue_t *ioqueue, pj_bool_t allow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_set_default_concurrency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ioqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>allow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set default concurrency policy for this ioqueue. If this function is not called, the default concurrency policy for the ioqueue is controlled by compile time setting PJ_IOQUEUE_DEFAULT_ALLOW_CONCURRENCY.</p>
<p>Note that changing the concurrency setting to the ioqueue will only affect subsequent key registrations. To modify the concurrency setting for individual key, use <a class="el" href="group__PJ__IOQUEUE.htm#gac9a11ef3e95391eb85193bb15284af93">pj_ioqueue_set_concurrency()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ioqueue</em>&nbsp;</td><td>The ioqueue instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>allow</em>&nbsp;</td><td>Non-zero to allow concurrent callback calls, or PJ_FALSE to disallow it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga983c8011148c497b1c7385370c9eb57b"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_set_lock" ref="ga983c8011148c497b1c7385370c9eb57b" args="(pj_ioqueue_t *ioque, pj_lock_t *lock, pj_bool_t auto_delete)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_set_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ioque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga3dc49084043901d31c7b12e5afc9fb2f">pj_lock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>auto_delete</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the lock object to be used by the I/O Queue. This function can only be called right after the I/O queue is created, before any handle is registered to the I/O queue.</p>
<p>Initially the I/O queue is created with non-recursive mutex protection. Applications can supply alternative lock to be used by calling this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ioque</em>&nbsp;</td><td>The ioqueue instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock to be used by the ioqueue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auto_delete</em>&nbsp;</td><td>In non-zero, the lock will be deleted by the ioqueue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4bc8e251b19facfe3b0bbcc65117155c"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_set_user_data" ref="ga4bc8e251b19facfe3b0bbcc65117155c" args="(pj_ioqueue_key_t *key, void *user_data, void **old_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_set_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>old_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set or change the user data to be associated with the file descriptor or handle or socket descriptor.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key that was previously obtained from registration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>User data to be associated with the descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_data</em>&nbsp;</td><td>Optional parameter to retrieve the old user data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success or the error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5d5a7ce4360cc2506ef2557f4815522"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_unlock_key" ref="gaa5d5a7ce4360cc2506ef2557f4815522" args="(pj_ioqueue_key_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_unlock_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the lock previously acquired with <a class="el" href="group__PJ__IOQUEUE.htm#gad418678f2f2444232ad490d258ab3acc">pj_ioqueue_lock_key()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key that was previously obtained from registration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c05e3b02e71e7680679c90c2adbe230"></a><!-- doxytag: member="ioqueue.h::pj_ioqueue_unregister" ref="ga7c05e3b02e71e7680679c90c2adbe230" args="(pj_ioqueue_key_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_ioqueue_unregister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unregister from the I/O Queue framework. Caller must make sure that the key doesn't have any pending operations before calling this function, by calling <a class="el" href="group__PJ__IOQUEUE.htm#ga740d28a04a46e6c1f7a4ae69ac0670bc">pj_ioqueue_is_pending()</a> for all previously submitted operations except asynchronous connect, and if necessary call <a class="el" href="group__PJ__IOQUEUE.htm#gad3efb211e789eeb8899e41550bc99006">pj_ioqueue_post_completion()</a> to cancel the pending operations.</p>
<p>Note that asynchronous connect operation will automatically be cancelled during the unregistration.</p>
<p>Also note that when I/O Completion Port backend is used, application MUST close the handle immediately after unregistering the key. This is because there is no unregistering API for IOCP. The only way to unregister the handle from IOCP is to close the handle.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key that was previously obtained from registration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success or the error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__PJ__IOQUEUE.htm#ga740d28a04a46e6c1f7a4ae69ac0670bc">pj_ioqueue_is_pending</a> </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga3ed26947c228ad86494baf4c0b9272de"></a><!-- doxytag: member="pj_ioqueue_op_key_t::activesock_data" ref="ga3ed26947c228ad86494baf4c0b9272de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__PJ__IOQUEUE.htm#ga3ed26947c228ad86494baf4c0b9272de">pj_ioqueue_op_key_t::activesock_data</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Active socket data. </p>

</div>
</div>
<a class="anchor" id="ga4330720fb952bd7c256d2752418bcc66"></a><!-- doxytag: member="pj_ioqueue_callback::on_accept_complete" ref="ga4330720fb952bd7c256d2752418bcc66" args=")(pj_ioqueue_key_t *key, pj_ioqueue_op_key_t *op_key, pj_sock_t sock, pj_status_t status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="group__PJ__IOQUEUE.htm#ga4330720fb952bd7c256d2752418bcc66">pj_ioqueue_callback::on_accept_complete</a>)(<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structop__key.htm">op_key</a>, <a class="el" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a> sock, <a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status)<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This callback is called when <a class="el" href="group__PJ__IOQUEUE.htm#gaf7505cc18b3031e43e68c5fd4a7a388e">pj_ioqueue_accept</a> completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structop__key.htm">op_key</a></em>&nbsp;</td><td>Operation key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>Newly connected socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Zero if the operation completes successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga268a5bf548a9656a8652e35b567f7776"></a><!-- doxytag: member="pj_ioqueue_callback::on_connect_complete" ref="ga268a5bf548a9656a8652e35b567f7776" args=")(pj_ioqueue_key_t *key, pj_status_t status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="group__PJ__IOQUEUE.htm#ga268a5bf548a9656a8652e35b567f7776">pj_ioqueue_callback::on_connect_complete</a>)(<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status)<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This callback is called when <a class="el" href="group__PJ__IOQUEUE.htm#gaf73fd64e7fbfa50b2c9ca7b00ceaea0b">pj_ioqueue_connect</a> completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>PJ_SUCCESS if the operation completes successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad79249d319b012a8366921e277299dc7"></a><!-- doxytag: member="pj_ioqueue_callback::on_write_complete" ref="gad79249d319b012a8366921e277299dc7" args=")(pj_ioqueue_key_t *key, pj_ioqueue_op_key_t *op_key, pj_ssize_t bytes_sent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="group__PJ__IOQUEUE.htm#gad79249d319b012a8366921e277299dc7">pj_ioqueue_callback::on_write_complete</a>)(<a class="el" href="group__PJ__BASIC.htm#ga89da69533fa1109f3a11ef91c489d9ad">pj_ioqueue_key_t</a> *key, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structop__key.htm">op_key</a>, <a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> bytes_sent)<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This callback is called when <a class="el" href="group__PJ__IOQUEUE.htm#gabf96d153949aeda0e7b9dbb742ffcda7">pj_ioqueue_send</a> or <a class="el" href="group__PJ__IOQUEUE.htm#gad9eaa7c7b2668255d6ee1a0bf3afb007">pj_ioqueue_sendto</a> completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structop__key.htm">op_key</a></em>&nbsp;</td><td>Operation key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_sent</em>&nbsp;</td><td>&gt;= 0 to indicate the amount of data written, otherwise negative value containing the error code. To obtain the pj_status_t error code, use (pj_status_t code = -bytes_sent). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab06c131ab29b37c027f2400bd5be6045"></a><!-- doxytag: member="pj_ioqueue_op_key_t::user_data" ref="gab06c131ab29b37c027f2400bd5be6045" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__PJ__IOQUEUE.htm#gab06c131ab29b37c027f2400bd5be6045">pj_ioqueue_op_key_t::user_data</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Application data. </p>

</div>
</div>
</div>
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
