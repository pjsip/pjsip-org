<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PJLIB Reference: Hash Table (1.16)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>


<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.htm"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Hash Table<br/>
<small>
[<a class="el" href="group__PJ__DS.htm">Data Structure.</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#ga625340f199ad845ba3065a200693a3c8">PJ_HASH_KEY_STRING</a>&nbsp;&nbsp;&nbsp;((unsigned)-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#ga2829e5510ddb73f3884f7d927cb88df2">PJ_HASH_ENTRY_BUF_SIZE</a>&nbsp;&nbsp;&nbsp;(3*sizeof(void*) + 2*sizeof(<a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>))</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#ga45bb2b73b34d2b44ee04e09c2172fdd3">pj_hash_entry_buf</a> [((3 *sizeof(void *)+2 *sizeof(<a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>))+sizeof(void *)-1)/(sizeof(void *))]</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#ga8f3ae40f16beca42d94a1779bfdefb60">pj_hash_calc</a> (<a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> hval, const void *key, unsigned keylen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#ga7417d226923aaab18f168f6527a91372">pj_hash_calc_tolower</a> (<a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> hval, char *result, const <a class="el" href="structpj__str__t.htm">pj_str_t</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#ga5d970e939612f2ab45051951fdb04a7e">pj_hash_create</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, unsigned size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#ga0a00949df61a05060c1e0f78445143b6">pj_hash_get</a> (<a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *ht, const void *key, unsigned keylen, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> *hval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#gace64525bc96de059442ccea00edd79fe">pj_hash_get_lower</a> (<a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *ht, const void *key, unsigned keylen, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> *hval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#ga1dd1bbe69d28540f5627ac9aa3ab1502">pj_hash_set</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *ht, const void *key, unsigned keylen, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> hval, void *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#ga80c2439be5d5fa9abd9170f719dbb767">pj_hash_set_lower</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *ht, const void *key, unsigned keylen, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> hval, void *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#ga4d338810058774be3d6668d5c371b88e">pj_hash_set_np</a> (<a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *ht, const void *key, unsigned keylen, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> hval, <a class="el" href="group__PJ__HASH.htm#ga45bb2b73b34d2b44ee04e09c2172fdd3">pj_hash_entry_buf</a> entry_buf, void *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#ga070698c3503cb1b3dd9c128dbc0eba50">pj_hash_set_np_lower</a> (<a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *ht, const void *key, unsigned keylen, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> hval, <a class="el" href="group__PJ__HASH.htm#ga45bb2b73b34d2b44ee04e09c2172fdd3">pj_hash_entry_buf</a> entry_buf, void *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#ga90af48becc01453b3a9b1501e0d0cbe1">pj_hash_count</a> (<a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *ht)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpj__hash__iterator__t.htm">pj_hash_iterator_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#ga8b6502b0d1aab3b583435969feb9f9cf">pj_hash_first</a> (<a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *ht, <a class="el" href="structpj__hash__iterator__t.htm">pj_hash_iterator_t</a> *it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpj__hash__iterator__t.htm">pj_hash_iterator_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#gafdada11ad80a2505b622c8f2dba9416e">pj_hash_next</a> (<a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *ht, <a class="el" href="structpj__hash__iterator__t.htm">pj_hash_iterator_t</a> *it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__HASH.htm#gadf065d2246adc3c3ce9bd771270cdd1c">pj_hash_this</a> (<a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *ht, <a class="el" href="structpj__hash__iterator__t.htm">pj_hash_iterator_t</a> *it)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A hash table is a dictionary in which keys are mapped to array positions by hash functions. Having the keys of more than one item map to the same position is called a collision. In this library, we will chain the nodes that have the same key in a list. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga2829e5510ddb73f3884f7d927cb88df2"></a><!-- doxytag: member="hash.h::PJ_HASH_ENTRY_BUF_SIZE" ref="ga2829e5510ddb73f3884f7d927cb88df2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PJ_HASH_ENTRY_BUF_SIZE&nbsp;&nbsp;&nbsp;(3*sizeof(void*) + 2*sizeof(<a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This indicates the size of of each hash entry. </p>

</div>
</div>
<a class="anchor" id="ga625340f199ad845ba3065a200693a3c8"></a><!-- doxytag: member="hash.h::PJ_HASH_KEY_STRING" ref="ga625340f199ad845ba3065a200693a3c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PJ_HASH_KEY_STRING&nbsp;&nbsp;&nbsp;((unsigned)-1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this constant is used as keylen, then the key is interpreted as NULL terminated string. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga45bb2b73b34d2b44ee04e09c2172fdd3"></a><!-- doxytag: member="hash.h::pj_hash_entry_buf" ref="ga45bb2b73b34d2b44ee04e09c2172fdd3" args="[((3 *sizeof(void *)+2 *sizeof(pj_uint32_t))+sizeof(void *)&#45;1)/(sizeof(void *))]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="group__PJ__HASH.htm#ga45bb2b73b34d2b44ee04e09c2172fdd3">pj_hash_entry_buf</a>[((3 *sizeof(void *)+2 *sizeof(<a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>))+sizeof(void *)-1)/(sizeof(void *))]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type declaration for entry buffer, used by <a class="el" href="group__PJ__HASH.htm#ga4d338810058774be3d6668d5c371b88e">pj_hash_set_np()</a> </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga8f3ae40f16beca42d94a1779bfdefb60"></a><!-- doxytag: member="hash.h::pj_hash_calc" ref="ga8f3ae40f16beca42d94a1779bfdefb60" args="(pj_uint32_t hval, const void *key, unsigned keylen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> pj_hash_calc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>hval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>keylen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the function that is used by the hash table to calculate hash value of the specified key.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hval</em>&nbsp;</td><td>the initial hash value, or zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key to calculate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keylen</em>&nbsp;</td><td>the length of the key, or PJ_HASH_KEY_STRING to treat the key as null terminated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the hash value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7417d226923aaab18f168f6527a91372"></a><!-- doxytag: member="hash.h::pj_hash_calc_tolower" ref="ga7417d226923aaab18f168f6527a91372" args="(pj_uint32_t hval, char *result, const pj_str_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> pj_hash_calc_tolower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>hval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__str__t.htm">pj_str_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert the key to lowercase and calculate the hash value. The resulting string is stored in <code>result</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hval</em>&nbsp;</td><td>The initial hash value, normally zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>Optional. Buffer to store the result, which must be enough to hold the string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The input key to be converted and calculated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The hash value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga90af48becc01453b3a9b1501e0d0cbe1"></a><!-- doxytag: member="hash.h::pj_hash_count" ref="ga90af48becc01453b3a9b1501e0d0cbe1" args="(pj_hash_table_t *ht)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned pj_hash_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the total number of entries in the hash table.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>the hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of entries in the hash table. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d970e939612f2ab45051951fdb04a7e"></a><!-- doxytag: member="hash.h::pj_hash_create" ref="ga5d970e939612f2ab45051951fdb04a7e" args="(pj_pool_t *pool, unsigned size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a>* pj_hash_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a hash table with the specified 'bucket' size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>the pool from which the hash table will be allocated from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the bucket size, which will be round-up to the nearest 2^n-1</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the hash table. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b6502b0d1aab3b583435969feb9f9cf"></a><!-- doxytag: member="hash.h::pj_hash_first" ref="ga8b6502b0d1aab3b583435969feb9f9cf" args="(pj_hash_table_t *ht, pj_hash_iterator_t *it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpj__hash__iterator__t.htm">pj_hash_iterator_t</a>* pj_hash_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__hash__iterator__t.htm">pj_hash_iterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>it</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the iterator to the first element in the hash table.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>the hash table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>the iterator for iterating hash elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the iterator to the hash element, or NULL if no element presents. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a00949df61a05060c1e0f78445143b6"></a><!-- doxytag: member="hash.h::pj_hash_get" ref="ga0a00949df61a05060c1e0f78445143b6" args="(pj_hash_table_t *ht, const void *key, unsigned keylen, pj_uint32_t *hval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pj_hash_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> *&nbsp;</td>
          <td class="paramname"> <em>hval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the value associated with the specified key.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>the hash table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key to look for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keylen</em>&nbsp;</td><td>the length of the key, or PJ_HASH_KEY_STRING to use the string length of the key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hval</em>&nbsp;</td><td>if this argument is not NULL and the value is not zero, the value will be used as the computed hash value. If the argument is not NULL and the value is zero, it will be filled with the computed hash upon return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value associated with the key, or NULL if the key is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="gace64525bc96de059442ccea00edd79fe"></a><!-- doxytag: member="hash.h::pj_hash_get_lower" ref="gace64525bc96de059442ccea00edd79fe" args="(pj_hash_table_t *ht, const void *key, unsigned keylen, pj_uint32_t *hval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pj_hash_get_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> *&nbsp;</td>
          <td class="paramname"> <em>hval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Variant of <a class="el" href="group__PJ__HASH.htm#ga0a00949df61a05060c1e0f78445143b6">pj_hash_get()</a> with the key being converted to lowercase when calculating the hash value.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__PJ__HASH.htm#ga0a00949df61a05060c1e0f78445143b6">pj_hash_get()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafdada11ad80a2505b622c8f2dba9416e"></a><!-- doxytag: member="hash.h::pj_hash_next" ref="gafdada11ad80a2505b622c8f2dba9416e" args="(pj_hash_table_t *ht, pj_hash_iterator_t *it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpj__hash__iterator__t.htm">pj_hash_iterator_t</a>* pj_hash_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__hash__iterator__t.htm">pj_hash_iterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>it</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the next element from the iterator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>the hash table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>the hash iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the next iterator, or NULL if there's no more element. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1dd1bbe69d28540f5627ac9aa3ab1502"></a><!-- doxytag: member="hash.h::pj_hash_set" ref="ga1dd1bbe69d28540f5627ac9aa3ab1502" args="(pj_pool_t *pool, pj_hash_table_t *ht, const void *key, unsigned keylen, pj_uint32_t hval, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_hash_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>hval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associate/disassociate a value with the specified key. If value is not NULL and entry already exists, the entry's value will be overwritten. If value is not NULL and entry does not exist, a new one will be created with the specified pool. Otherwise if value is NULL, entry will be deleted if it exists.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>the pool to allocate the new entry if a new entry has to be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>the hash table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key. If pool is not specified, the key MUST point to buffer that remains valid for the duration of the entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keylen</em>&nbsp;</td><td>the length of the key, or PJ_HASH_KEY_STRING to use the string length of the key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hval</em>&nbsp;</td><td>if the value is not zero, then the hash table will use this value to search the entry's index, otherwise it will compute the key. This value can be obtained when calling <a class="el" href="group__PJ__HASH.htm#ga0a00949df61a05060c1e0f78445143b6">pj_hash_get()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value to be associated, or NULL to delete the entry with the specified key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga80c2439be5d5fa9abd9170f719dbb767"></a><!-- doxytag: member="hash.h::pj_hash_set_lower" ref="ga80c2439be5d5fa9abd9170f719dbb767" args="(pj_pool_t *pool, pj_hash_table_t *ht, const void *key, unsigned keylen, pj_uint32_t hval, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_hash_set_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>hval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Variant of <a class="el" href="group__PJ__HASH.htm#ga1dd1bbe69d28540f5627ac9aa3ab1502">pj_hash_set()</a> with the key being converted to lowercase when calculating the hash value.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__PJ__HASH.htm#ga1dd1bbe69d28540f5627ac9aa3ab1502">pj_hash_set()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d338810058774be3d6668d5c371b88e"></a><!-- doxytag: member="hash.h::pj_hash_set_np" ref="ga4d338810058774be3d6668d5c371b88e" args="(pj_hash_table_t *ht, const void *key, unsigned keylen, pj_uint32_t hval, pj_hash_entry_buf entry_buf, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_hash_set_np </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>hval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__HASH.htm#ga45bb2b73b34d2b44ee04e09c2172fdd3">pj_hash_entry_buf</a>&nbsp;</td>
          <td class="paramname"> <em>entry_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associate/disassociate a value with the specified key. This function works like <a class="el" href="group__PJ__HASH.htm#ga1dd1bbe69d28540f5627ac9aa3ab1502">pj_hash_set()</a>, except that it doesn't use pool (hence the np -- no pool suffix). If new entry needs to be allocated, it will use the entry_buf.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>the hash table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keylen</em>&nbsp;</td><td>the length of the key, or PJ_HASH_KEY_STRING to use the string length of the key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hval</em>&nbsp;</td><td>if the value is not zero, then the hash table will use this value to search the entry's index, otherwise it will compute the key. This value can be obtained when calling <a class="el" href="group__PJ__HASH.htm#ga0a00949df61a05060c1e0f78445143b6">pj_hash_get()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>entry_buf</em>&nbsp;</td><td>Buffer which will be used for the new entry, when one needs to be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value to be associated, or NULL to delete the entry with the specified key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga070698c3503cb1b3dd9c128dbc0eba50"></a><!-- doxytag: member="hash.h::pj_hash_set_np_lower" ref="ga070698c3503cb1b3dd9c128dbc0eba50" args="(pj_hash_table_t *ht, const void *key, unsigned keylen, pj_uint32_t hval, pj_hash_entry_buf entry_buf, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_hash_set_np_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>hval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__HASH.htm#ga45bb2b73b34d2b44ee04e09c2172fdd3">pj_hash_entry_buf</a>&nbsp;</td>
          <td class="paramname"> <em>entry_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Variant of <a class="el" href="group__PJ__HASH.htm#ga4d338810058774be3d6668d5c371b88e">pj_hash_set_np()</a> with the key being converted to lowercase when calculating the hash value.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__PJ__HASH.htm#ga4d338810058774be3d6668d5c371b88e">pj_hash_set_np()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadf065d2246adc3c3ce9bd771270cdd1c"></a><!-- doxytag: member="hash.h::pj_hash_this" ref="gadf065d2246adc3c3ce9bd771270cdd1c" args="(pj_hash_table_t *ht, pj_hash_iterator_t *it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pj_hash_this </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gac4d75b196e22cb3c80b1c247f8fa8c7b">pj_hash_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__hash__iterator__t.htm">pj_hash_iterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>it</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the value associated with a hash iterator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>the hash table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>the hash iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value associated with the current element in iterator. </dd></dl>

</div>
</div>
</div>
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
