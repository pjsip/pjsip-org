<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PJLIB Reference: Network Address Resolution (1.16)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>


<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.htm"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Network Address Resolution<br/>
<small>
[<a class="el" href="group__PJ__IO.htm">Input/Output</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__hostent.htm">pj_hostent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__addrinfo.htm">pj_addrinfo</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pj__addr__resolve.htm#ga4d04a8261523c8f3473946257c12ce5b">h_addr</a>&nbsp;&nbsp;&nbsp;h_addr_list[0]</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pj__addr__resolve.htm#ga7c8264aa7743594d31766679dbae0b88">pj_gethostbyname</a> (const <a class="el" href="structpj__str__t.htm">pj_str_t</a> *name, <a class="el" href="structpj__hostent.htm">pj_hostent</a> *he)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pj__addr__resolve.htm#ga410b1bd02dcabf108b129e95368beef4">pj_gethostip</a> (int af, <a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pj__addr__resolve.htm#gae9a1ddbc8b068fad022db4661bcb9937">pj_getdefaultipinterface</a> (int af, <a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pj__addr__resolve.htm#gaaf5df28bb11ef770eb4ef5cca7b8f9b2">pj_getaddrinfo</a> (int af, const <a class="el" href="structpj__str__t.htm">pj_str_t</a> *name, unsigned *count, <a class="el" href="structpj__addrinfo.htm">pj_addrinfo</a> ai[])</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This module provides function to resolve Internet address of the specified host name. To resolve a particular host name, application can just call <a class="el" href="group__pj__addr__resolve.htm#ga7c8264aa7743594d31766679dbae0b88">pj_gethostbyname()</a>.</p>
<p>Example: </p>
<pre>
   ...
   <a class="el" href="structpj__hostent.htm">pj_hostent</a> he;
   pj_status_t rc;
   <a class="el" href="structpj__str__t.htm">pj_str_t</a> host = pj_str("host.example.com");</pre><pre>   rc = pj_gethostbyname( &amp;host, &amp;he);
   if (rc != PJ_SUCCESS) {
      char errbuf[80];
      pj_strerror( rc, errbuf, sizeof(errbuf));
      PJ_LOG(2,("sample", "Unable to resolve host, error=%s", errbuf));
      return rc;
   }</pre><pre>   // process address...
   addr.sin_addr.s_addr = *(pj_uint32_t*)he.h_addr;
   ...
 </pre><p>It's pretty simple really... </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga4d04a8261523c8f3473946257c12ce5b"></a><!-- doxytag: member="addr_resolv.h::h_addr" ref="ga4d04a8261523c8f3473946257c12ce5b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define h_addr&nbsp;&nbsp;&nbsp;h_addr_list[0]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shortcut to h_addr_list[0] </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaaf5df28bb11ef770eb4ef5cca7b8f9b2"></a><!-- doxytag: member="addr_resolv.h::pj_getaddrinfo" ref="gaaf5df28bb11ef770eb4ef5cca7b8f9b2" args="(int af, const pj_str_t *name, unsigned *count, pj_addrinfo ai[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__str__t.htm">pj_str_t</a> *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__addrinfo.htm">pj_addrinfo</a>&nbsp;</td>
          <td class="paramname"> <em>ai</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function translates the name of a service location (for example, a host name) and returns a set of addresses and associated information to be used in creating a socket with which to address the specified service.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>af</em>&nbsp;</td><td>The desired address family to query. Valid values are <a class="el" href="group__PJ__SOCK.htm#ga8ea303b95fe973432a361e47e0459086">pj_AF_INET()</a>, <a class="el" href="group__PJ__SOCK.htm#ga60a867be35581f776aa88156505309de">pj_AF_INET6()</a>, or <a class="el" href="group__PJ__SOCK.htm#ga70ea77cd531607c6c3ce586d6fbd007d">pj_AF_UNSPEC()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Descriptive name or an address string, such as host name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>On input, it specifies the number of elements in <em>ai</em> array. On output, this will be set with the number of address informations found for the specified name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ai</em>&nbsp;</td><td>Array of address info to be filled with the information about the host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gae9a1ddbc8b068fad022db4661bcb9937"></a><!-- doxytag: member="addr_resolv.h::pj_getdefaultipinterface" ref="gae9a1ddbc8b068fad022db4661bcb9937" args="(int af, pj_sockaddr *addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_getdefaultipinterface </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IP address of the default interface. Default interface is the interface of the default route.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>af</em>&nbsp;</td><td>The desired address family to query. Valid values are <a class="el" href="group__PJ__SOCK.htm#ga8ea303b95fe973432a361e47e0459086">pj_AF_INET()</a> or <a class="el" href="group__PJ__SOCK.htm#ga60a867be35581f776aa88156505309de">pj_AF_INET6()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>On successful resolution, the address family and address part of this socket address will be filled up with the host IP address, in network byte order. Other parts of the socket address are untouched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c8264aa7743594d31766679dbae0b88"></a><!-- doxytag: member="addr_resolv.h::pj_gethostbyname" ref="ga7c8264aa7743594d31766679dbae0b88" args="(const pj_str_t *name, pj_hostent *he)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_gethostbyname </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpj__str__t.htm">pj_str_t</a> *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__hostent.htm">pj_hostent</a> *&nbsp;</td>
          <td class="paramname"> <em>he</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function fills the structure of type <a class="el" href="structpj__hostent.htm">pj_hostent</a> for a given host name. For host resolution function that also works with IPv6, please see <a class="el" href="group__pj__addr__resolve.htm#gaaf5df28bb11ef770eb4ef5cca7b8f9b2">pj_getaddrinfo()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Host name to resolve. Specifying IPv4 address here may fail on some platforms (e.g. Windows) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>he</em>&nbsp;</td><td>The <a class="el" href="structpj__hostent.htm">pj_hostent</a> structure to be filled. Note that the pointers in this structure points to temporary variables which value will be reset upon subsequent invocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS, or the appropriate error codes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga410b1bd02dcabf108b129e95368beef4"></a><!-- doxytag: member="addr_resolv.h::pj_gethostip" ref="ga410b1bd02dcabf108b129e95368beef4" args="(int af, pj_sockaddr *addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_gethostip </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resolve the primary IP address of local host.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>af</em>&nbsp;</td><td>The desired address family to query. Valid values are <a class="el" href="group__PJ__SOCK.htm#ga8ea303b95fe973432a361e47e0459086">pj_AF_INET()</a> or <a class="el" href="group__PJ__SOCK.htm#ga60a867be35581f776aa88156505309de">pj_AF_INET6()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>On successful resolution, the address family and address part of this socket address will be filled up with the host IP address, in network byte order. Other parts of the socket address are untouched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error code. </dd></dl>

</div>
</div>
</div>
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
