<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Memory Pool Object (2.13)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Memory Pool Object<div class="ingroups"><a class="el" href="group__PJ__POOL__GROUP.htm">Fast Memory Pool</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The memory pool is an opaque object created by pool factory. Application uses this object to request a memory chunk, by calling <a class="el" href="group__PJ__POOL.htm#ga14798f6ba0d0858e4f36cc8a4904bbd9">pj_pool_alloc()</a>, <a class="el" href="group__PJ__POOL.htm#ga4b3004c6b9b742351dcc951bb610ddfb">pj_pool_calloc()</a>, or <a class="el" href="group__PJ__POOL.htm#ga5bedca9c6066f4e1a7254cbb70b4afcc">pj_pool_zalloc()</a>. When the application has finished using the pool, it must call <a class="el" href="group__PJ__POOL.htm#gade0f14f6635ecfccb576ec41c57fede5">pj_pool_release()</a> to free all the chunks previously allocated and release the pool back to the factory.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__block.htm">pj_pool_block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1c2e8be344e0e510145d5888636538be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga1c2e8be344e0e510145d5888636538be">PJ_POOL_SIZE</a>&#160;&#160;&#160;(sizeof(struct <a class="el" href="structpj__pool__t.htm">pj_pool_t</a>))</td></tr>
<tr class="separator:ga1c2e8be344e0e510145d5888636538be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e2da94131c06db0b620d4fc65c6abb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga83e2da94131c06db0b620d4fc65c6abb">PJ_POOL_ALIGNMENT</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ga83e2da94131c06db0b620d4fc65c6abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6763322fc7956e3c1aac87cb250f8b86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga6763322fc7956e3c1aac87cb250f8b86">PJ_POOL_ALLOC_T</a>(pool,  type)&#160;&#160;&#160;            ((type*)<a class="el" href="group__PJ__POOL.htm#ga14798f6ba0d0858e4f36cc8a4904bbd9">pj_pool_alloc</a>(pool, sizeof(type)))</td></tr>
<tr class="separator:ga6763322fc7956e3c1aac87cb250f8b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga405d1dbb6728b1d1bd90ddadb9342b27"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga405d1dbb6728b1d1bd90ddadb9342b27">PJ_POOL_ZALLOC_T</a>(pool,  type)&#160;&#160;&#160;            ((type*)<a class="el" href="group__PJ__POOL.htm#ga5bedca9c6066f4e1a7254cbb70b4afcc">pj_pool_zalloc</a>(pool, sizeof(type)))</td></tr>
<tr class="separator:ga405d1dbb6728b1d1bd90ddadb9342b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gabffd362d92627d62c4498b7efe0ae62a"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a>(<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td></tr>
<tr class="separator:gabffd362d92627d62c4498b7efe0ae62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4634b31af5eb0a0178481536986f1d15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga4634b31af5eb0a0178481536986f1d15">pj_pool_create</a> (<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, const char *name, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> initial_size, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> increment_size, <a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *callback)</td></tr>
<tr class="separator:ga4634b31af5eb0a0178481536986f1d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade0f14f6635ecfccb576ec41c57fede5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#gade0f14f6635ecfccb576ec41c57fede5">pj_pool_release</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr class="separator:gade0f14f6635ecfccb576ec41c57fede5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6d508fb309458e090d37d4f4260a95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga9d6d508fb309458e090d37d4f4260a95">pj_pool_safe_release</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> **ppool)</td></tr>
<tr class="separator:ga9d6d508fb309458e090d37d4f4260a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga434cf4995ee89d8316eeca1ae87d84fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga434cf4995ee89d8316eeca1ae87d84fb">pj_pool_secure_release</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> **ppool)</td></tr>
<tr class="separator:ga434cf4995ee89d8316eeca1ae87d84fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20d8bc17d629b946f0f84ab4dc381f44"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga20d8bc17d629b946f0f84ab4dc381f44">pj_pool_getobjname</a> (const <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr class="separator:ga20d8bc17d629b946f0f84ab4dc381f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bfe679642e35ec7f1f6704f55a1610c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga8bfe679642e35ec7f1f6704f55a1610c">pj_pool_reset</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr class="separator:ga8bfe679642e35ec7f1f6704f55a1610c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5442c928338775d194cc57c3fb7652a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga5442c928338775d194cc57c3fb7652a2">pj_pool_get_capacity</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr class="separator:ga5442c928338775d194cc57c3fb7652a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga235684dba5b7eb06e2fe9a68a84acfb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga235684dba5b7eb06e2fe9a68a84acfb1">pj_pool_get_used_size</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr class="separator:ga235684dba5b7eb06e2fe9a68a84acfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14798f6ba0d0858e4f36cc8a4904bbd9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga14798f6ba0d0858e4f36cc8a4904bbd9">pj_pool_alloc</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td></tr>
<tr class="separator:ga14798f6ba0d0858e4f36cc8a4904bbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b3004c6b9b742351dcc951bb610ddfb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga4b3004c6b9b742351dcc951bb610ddfb">pj_pool_calloc</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> count, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> elem)</td></tr>
<tr class="separator:ga4b3004c6b9b742351dcc951bb610ddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bedca9c6066f4e1a7254cbb70b4afcc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga5bedca9c6066f4e1a7254cbb70b4afcc">pj_pool_zalloc</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td></tr>
<tr class="separator:ga5bedca9c6066f4e1a7254cbb70b4afcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga210b946b76f73ecb242974b6e1c87c3a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga210b946b76f73ecb242974b6e1c87c3a">pj_pool_alloc_from_block</a> (<a class="el" href="structpj__pool__block.htm">pj_pool_block</a> *block, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td></tr>
<tr class="separator:ga210b946b76f73ecb242974b6e1c87c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96eb77cff80e61964a441116c27fe069"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm#ga96eb77cff80e61964a441116c27fe069">pj_pool_allocate_find</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td></tr>
<tr class="separator:ga96eb77cff80e61964a441116c27fe069"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >The memory pool is an opaque object created by pool factory. Application uses this object to request a memory chunk, by calling <a class="el" href="group__PJ__POOL.htm#ga14798f6ba0d0858e4f36cc8a4904bbd9">pj_pool_alloc()</a>, <a class="el" href="group__PJ__POOL.htm#ga4b3004c6b9b742351dcc951bb610ddfb">pj_pool_calloc()</a>, or <a class="el" href="group__PJ__POOL.htm#ga5bedca9c6066f4e1a7254cbb70b4afcc">pj_pool_zalloc()</a>. When the application has finished using the pool, it must call <a class="el" href="group__PJ__POOL.htm#gade0f14f6635ecfccb576ec41c57fede5">pj_pool_release()</a> to free all the chunks previously allocated and release the pool back to the factory. </p>
<p >A memory pool is initialized with an initial amount of memory, which is called a block. Pool can be configured to dynamically allocate more memory blocks when it runs out of memory.</p>
<p >The pool doesn't keep track of individual memory allocations by user, and the user doesn't have to free these indidual allocations. This makes memory allocation simple and very fast. All the memory allocated from the pool will be destroyed when the pool itself is destroyed.</p>
<h1><a class="anchor" id="PJ_POOL_THREADING_SEC"></a>
More on Threading Policies</h1>
<ul>
<li>By design, memory allocation from a pool is not thread safe. We assumed that a pool will be owned by an object, and thread safety should be handled by that object. Thus these functions are not thread safe:<ul>
<li><a class="el" href="group__PJ__POOL.htm#ga14798f6ba0d0858e4f36cc8a4904bbd9">pj_pool_alloc</a>,</li>
<li><a class="el" href="group__PJ__POOL.htm#ga4b3004c6b9b742351dcc951bb610ddfb">pj_pool_calloc</a>,</li>
<li>and other pool statistic functions.</li>
</ul>
</li>
<li>Threading in the pool factory is decided by the policy set for the factory when it was created.</li>
</ul>
<h1><a class="anchor" id="PJ_POOL_EXAMPLES_SEC"></a>
Examples</h1>
<p >For some sample codes on how to use the pool, please see:</p><ul>
<li><a class="el" href="page_pjlib_pool_test.htm">Test: Pool</a> </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga83e2da94131c06db0b620d4fc65c6abb" name="ga83e2da94131c06db0b620d4fc65c6abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83e2da94131c06db0b620d4fc65c6abb">&#9670;&nbsp;</a></span>PJ_POOL_ALIGNMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PJ_POOL_ALIGNMENT&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Pool memory alignment (must be power of 2). </p>

</div>
</div>
<a id="ga6763322fc7956e3c1aac87cb250f8b86" name="ga6763322fc7956e3c1aac87cb250f8b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6763322fc7956e3c1aac87cb250f8b86">&#9670;&nbsp;</a></span>PJ_POOL_ALLOC_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PJ_POOL_ALLOC_T</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;            ((type*)<a class="el" href="group__PJ__POOL.htm#ga14798f6ba0d0858e4f36cc8a4904bbd9">pj_pool_alloc</a>(pool, sizeof(type)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This macro allocates memory from the pool and returns the instance of the specified type. It provides a stricker type safety than <a class="el" href="group__PJ__POOL.htm#ga14798f6ba0d0858e4f36cc8a4904bbd9">pj_pool_alloc()</a> since the return value of this macro will be type-casted to the specified type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool </td></tr>
    <tr><td class="paramname">type</td><td>The type of object to be allocated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory buffer of the specified type. </dd></dl>

</div>
</div>
<a id="ga1c2e8be344e0e510145d5888636538be" name="ga1c2e8be344e0e510145d5888636538be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c2e8be344e0e510145d5888636538be">&#9670;&nbsp;</a></span>PJ_POOL_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PJ_POOL_SIZE&#160;&#160;&#160;(sizeof(struct <a class="el" href="structpj__pool__t.htm">pj_pool_t</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Guidance on how much memory required for initial pool administrative data. </p>

</div>
</div>
<a id="ga405d1dbb6728b1d1bd90ddadb9342b27" name="ga405d1dbb6728b1d1bd90ddadb9342b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga405d1dbb6728b1d1bd90ddadb9342b27">&#9670;&nbsp;</a></span>PJ_POOL_ZALLOC_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PJ_POOL_ZALLOC_T</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;            ((type*)<a class="el" href="group__PJ__POOL.htm#ga5bedca9c6066f4e1a7254cbb70b4afcc">pj_pool_zalloc</a>(pool, sizeof(type)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This macro allocates memory from the pool, zeroes the buffer, and returns the instance of the specified type. It provides a stricker type safety than <a class="el" href="group__PJ__POOL.htm#ga5bedca9c6066f4e1a7254cbb70b4afcc">pj_pool_zalloc()</a> since the return value of this macro will be type-casted to the specified type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool </td></tr>
    <tr><td class="paramname">type</td><td>The type of object to be allocated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory buffer of the specified type. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gabffd362d92627d62c4498b7efe0ae62a" name="gabffd362d92627d62c4498b7efe0ae62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabffd362d92627d62c4498b7efe0ae62a">&#9670;&nbsp;</a></span>pj_pool_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void pj_pool_callback(<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The type for function to receive callback from the pool when it is unable to allocate memory. The elegant way to handle this condition is to throw exception, and this is what is expected by most of this library components. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga14798f6ba0d0858e4f36cc8a4904bbd9" name="ga14798f6ba0d0858e4f36cc8a4904bbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14798f6ba0d0858e4f36cc8a4904bbd9">&#9670;&nbsp;</a></span>pj_pool_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pj_pool_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allocate storage with the specified size from the pool. If there's no storage available in the pool, then the pool can allocate more blocks if the increment size is larger than the requested size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool. </td></tr>
    <tr><td class="paramname">size</td><td>the requested size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the allocated memory.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__PJ__POOL.htm#ga6763322fc7956e3c1aac87cb250f8b86">PJ_POOL_ALLOC_T</a> </dd></dl>

</div>
</div>
<a id="ga210b946b76f73ecb242974b6e1c87c3a" name="ga210b946b76f73ecb242974b6e1c87c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga210b946b76f73ecb242974b6e1c87c3a">&#9670;&nbsp;</a></span>pj_pool_alloc_from_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pj_pool_alloc_from_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__block.htm">pj_pool_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Internal function </p>

</div>
</div>
<a id="ga96eb77cff80e61964a441116c27fe069" name="ga96eb77cff80e61964a441116c27fe069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96eb77cff80e61964a441116c27fe069">&#9670;&nbsp;</a></span>pj_pool_allocate_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pj_pool_allocate_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Internal function </p>

</div>
</div>
<a id="ga4b3004c6b9b742351dcc951bb610ddfb" name="ga4b3004c6b9b742351dcc951bb610ddfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b3004c6b9b742351dcc951bb610ddfb">&#9670;&nbsp;</a></span>pj_pool_calloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pj_pool_calloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allocate storage from the pool, and initialize it to zero. This function behaves like <a class="el" href="group__PJ__POOL.htm#ga14798f6ba0d0858e4f36cc8a4904bbd9">pj_pool_alloc()</a>, except that the storage will be initialized to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool. </td></tr>
    <tr><td class="paramname">count</td><td>the number of elements in the array. </td></tr>
    <tr><td class="paramname">elem</td><td>the size of individual element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the allocated memory. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__PJ__POOL.htm#ga5bedca9c6066f4e1a7254cbb70b4afcc">pj_pool_zalloc()</a>.</p>

</div>
</div>
<a id="ga4634b31af5eb0a0178481536986f1d15" name="ga4634b31af5eb0a0178481536986f1d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4634b31af5eb0a0178481536986f1d15">&#9670;&nbsp;</a></span>pj_pool_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> * pj_pool_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td>
          <td class="paramname"><em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td>
          <td class="paramname"><em>increment_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a new pool from the pool factory. This wrapper will call create_pool member of the pool factory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The pool factory. </td></tr>
    <tr><td class="paramname">name</td><td>The name to be assigned to the pool. The name should not be longer than PJ_MAX_OBJ_NAME (32 chars), or otherwise it will be truncated. </td></tr>
    <tr><td class="paramname">initial_size</td><td>The size of initial memory blocks taken by the pool. Note that the pool will take 68+20 bytes for administrative area from this block. </td></tr>
    <tr><td class="paramname">increment_size</td><td>the size of each additional blocks to be allocated when the pool is running out of memory. If user requests memory which is larger than this size, then an error occurs. Note that each time a pool allocates additional block, it needs PJ_POOL_SIZE more to store some administrative info. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback to be called when error occurs in the pool. If this value is NULL, then the callback from pool factory policy will be used. Note that when an error occurs during pool creation, the callback itself is not called. Instead, NULL will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The memory pool, or NULL. </dd></dl>

</div>
</div>
<a id="ga5442c928338775d194cc57c3fb7652a2" name="ga5442c928338775d194cc57c3fb7652a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5442c928338775d194cc57c3fb7652a2">&#9670;&nbsp;</a></span>pj_pool_get_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> pj_pool_get_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the pool capacity, that is, the system storage that have been allocated by the pool, and have been used/will be used to allocate user requests. There's no guarantee that the returned value represent a single contiguous block, because the capacity may be spread in several blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the capacity. </dd></dl>

</div>
</div>
<a id="ga235684dba5b7eb06e2fe9a68a84acfb1" name="ga235684dba5b7eb06e2fe9a68a84acfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga235684dba5b7eb06e2fe9a68a84acfb1">&#9670;&nbsp;</a></span>pj_pool_get_used_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> pj_pool_get_used_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the total size of user allocation request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total size. </dd></dl>

</div>
</div>
<a id="ga20d8bc17d629b946f0f84ab4dc381f44" name="ga20d8bc17d629b946f0f84ab4dc381f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20d8bc17d629b946f0f84ab4dc381f44">&#9670;&nbsp;</a></span>pj_pool_getobjname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pj_pool_getobjname </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get pool object name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pool name as NULL terminated string. </dd></dl>

</div>
</div>
<a id="gade0f14f6635ecfccb576ec41c57fede5" name="gade0f14f6635ecfccb576ec41c57fede5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade0f14f6635ecfccb576ec41c57fede5">&#9670;&nbsp;</a></span>pj_pool_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_pool_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Release the pool back to pool factory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Memory pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8bfe679642e35ec7f1f6704f55a1610c" name="ga8bfe679642e35ec7f1f6704f55a1610c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bfe679642e35ec7f1f6704f55a1610c">&#9670;&nbsp;</a></span>pj_pool_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_pool_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reset the pool to its state when it was initialized. This means that if additional blocks have been allocated during runtime, then they will be freed. Only the original block allocated during initialization is retained. This function will also reset the internal counters, such as pool capacity and used size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d6d508fb309458e090d37d4f4260a95" name="ga9d6d508fb309458e090d37d4f4260a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d6d508fb309458e090d37d4f4260a95">&#9670;&nbsp;</a></span>pj_pool_safe_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_pool_safe_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> **&#160;</td>
          <td class="paramname"><em>ppool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Release the pool back to pool factory and set the pool pointer to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppool</td><td>Pointer to memory pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga434cf4995ee89d8316eeca1ae87d84fb" name="ga434cf4995ee89d8316eeca1ae87d84fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga434cf4995ee89d8316eeca1ae87d84fb">&#9670;&nbsp;</a></span>pj_pool_secure_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_pool_secure_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> **&#160;</td>
          <td class="paramname"><em>ppool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Release the pool back to pool factory and set the pool pointer to zero. The memory pool content will be wiped out first before released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppool</td><td>Pointer to memory pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5bedca9c6066f4e1a7254cbb70b4afcc" name="ga5bedca9c6066f4e1a7254cbb70b4afcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bedca9c6066f4e1a7254cbb70b4afcc">&#9670;&nbsp;</a></span>pj_pool_zalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pj_pool_zalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allocate storage from the pool and initialize it to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool. </td></tr>
    <tr><td class="paramname">size</td><td>The size to be allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated memory.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__PJ__POOL.htm#ga405d1dbb6728b1d1bd90ddadb9342b27">PJ_POOL_ZALLOC_T</a> </dd></dl>

<p class="reference">References <a class="el" href="group__PJ__POOL.htm#ga4b3004c6b9b742351dcc951bb610ddfb">pj_pool_calloc()</a>.</p>

</div>
</div>
</div><!-- contents -->
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>
<!--#include virtual="/footer.html" -->
</BODY>
</HTML>
