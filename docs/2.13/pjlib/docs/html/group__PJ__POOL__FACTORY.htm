<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pool Factory and Policy (2.13)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Pool Factory and Policy<div class="ingroups"><a class="el" href="group__PJ__POOL__GROUP.htm">Fast Memory Pool</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A pool object must be created through a factory. A factory not only provides generic interface functions to create and release pool, but also provides strategy to manage the life time of pools. One sample implementation, <em><a class="el" href="structpj__caching__pool.htm">pj_caching_pool</a></em>, can be set to keep the pools released by application for future use as long as the total memory is below the limit.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac5d07e3f819942fb881a9f8b777fd0b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#gac5d07e3f819942fb881a9f8b777fd0b1">pj_NO_MEMORY_EXCEPTION</a> (void)</td></tr>
<tr class="separator:gac5d07e3f819942fb881a9f8b777fd0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac97b3e841c0c8d504d54c989fa415760"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#gac97b3e841c0c8d504d54c989fa415760">pj_pool_factory_get_default_policy</a> (void)</td></tr>
<tr class="separator:gac97b3e841c0c8d504d54c989fa415760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1397e80c0b1bb19a162a4e3d7feb9e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#ga1397e80c0b1bb19a162a4e3d7feb9e87">pj_pool_create_int</a> (<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, const char *name, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> initial_size, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> increment_size, <a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *callback)</td></tr>
<tr class="separator:ga1397e80c0b1bb19a162a4e3d7feb9e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3038a0811c30b68619747334244078f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#gaf3038a0811c30b68619747334244078f">pj_pool_init_int</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, const char *name, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> increment_size, <a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *callback)</td></tr>
<tr class="separator:gaf3038a0811c30b68619747334244078f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9581731588a21cdf4461493829f6b29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#gad9581731588a21cdf4461493829f6b29">pj_pool_destroy_int</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr class="separator:gad9581731588a21cdf4461493829f6b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac01712a96e2e33528f6b4e0c44c229b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#gac01712a96e2e33528f6b4e0c44c229b5">pj_pool_factory_dump</a> (<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *pf, <a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> detail)</td></tr>
<tr class="separator:gac01712a96e2e33528f6b4e0c44c229b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga1e63ea214df265fa5f145e2837552a45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#ga1e63ea214df265fa5f145e2837552a45">PJ_NO_MEMORY_EXCEPTION</a></td></tr>
<tr class="separator:ga1e63ea214df265fa5f145e2837552a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cf758eafb888f318a8de7f396f47ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#ga98cf758eafb888f318a8de7f396f47ca">pj_pool_factory_default_policy</a></td></tr>
<tr class="separator:ga98cf758eafb888f318a8de7f396f47ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >A pool object must be created through a factory. A factory not only provides generic interface functions to create and release pool, but also provides strategy to manage the life time of pools. One sample implementation, <em><a class="el" href="structpj__caching__pool.htm">pj_caching_pool</a></em>, can be set to keep the pools released by application for future use as long as the total memory is below the limit. </p>
<p >// PJ_POOL</p>
<p >The pool factory interface declared in PJLIB is designed to be extensible. Application can define its own strategy by creating it's own pool factory implementation, and this strategy can be used even by existing library without recompilation.</p>
<h1><a class="anchor" id="PJ_POOL_FACTORY_ITF"></a>
Pool Factory Interface</h1>
<p >The pool factory defines the following interface:</p><ul>
<li><em>policy:</em> the memory pool factory policy.</li>
<li><em>create_pool()</em>: create a new memory pool.</li>
<li><em>release_pool()</em>: release memory pool back to factory.</li>
</ul>
<h1><a class="anchor" id="PJ_POOL_FACTORY_POL"></a>
Pool Factory Policy.</h1>
<p >A pool factory only defines functions to create and release pool and how to manage pools, but the rest of the functionalities are controlled by policy. A pool policy defines:</p><ul>
<li>how memory block is allocated and deallocated (the default implementation allocates and deallocate memory by calling malloc() and free()).</li>
<li>callback to be called when memory allocation inside a pool fails (the default implementation will throw PJ_NO_MEMORY_EXCEPTION exception).</li>
<li>concurrency when creating and releasing pool from/to the factory.</li>
</ul>
<p >A pool factory can be given different policy during creation to make it behave differently. For example, caching pool factory can be configured to allocate and deallocate from a static/contiguous/preallocated memory instead of using malloc()/free().</p>
<p >What strategy/factory and what policy to use is not defined by PJLIB, but instead is left to application to make use whichever is most efficient for itself.</p>
<p >The pool factory policy controls the behaviour of memory factories, and defines the following interface:</p><ul>
<li><em>block_alloc()</em>: allocate memory block from backend memory mgmt/system.</li>
<li><em>block_free()</em>: free memory block back to backend memory mgmt/system. </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac5d07e3f819942fb881a9f8b777fd0b1" name="gac5d07e3f819942fb881a9f8b777fd0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d07e3f819942fb881a9f8b777fd0b1">&#9670;&nbsp;</a></span>pj_NO_MEMORY_EXCEPTION()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pj_NO_MEMORY_EXCEPTION </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get <a class="el" href="group__PJ__POOL__FACTORY.htm#ga1e63ea214df265fa5f145e2837552a45">PJ_NO_MEMORY_EXCEPTION</a> constant. </p>

</div>
</div>
<a id="ga1397e80c0b1bb19a162a4e3d7feb9e87" name="ga1397e80c0b1bb19a162a4e3d7feb9e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1397e80c0b1bb19a162a4e3d7feb9e87">&#9670;&nbsp;</a></span>pj_pool_create_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> * pj_pool_create_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td>
          <td class="paramname"><em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td>
          <td class="paramname"><em>increment_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function is intended to be used by pool factory implementors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>Pool factory. </td></tr>
    <tr><td class="paramname">name</td><td>Pool name. </td></tr>
    <tr><td class="paramname">initial_size</td><td>Initial size. </td></tr>
    <tr><td class="paramname">increment_size</td><td>Increment size. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pool object, or NULL. </dd></dl>

</div>
</div>
<a id="gad9581731588a21cdf4461493829f6b29" name="gad9581731588a21cdf4461493829f6b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9581731588a21cdf4461493829f6b29">&#9670;&nbsp;</a></span>pj_pool_destroy_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_pool_destroy_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function is intended to be used by pool factory implementors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The memory pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac01712a96e2e33528f6b4e0c44c229b5" name="gac01712a96e2e33528f6b4e0c44c229b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac01712a96e2e33528f6b4e0c44c229b5">&#9670;&nbsp;</a></span>pj_pool_factory_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_pool_factory_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *&#160;</td>
          <td class="paramname"><em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&#160;</td>
          <td class="paramname"><em>detail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Dump pool factory state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pf</td><td>The pool factory. </td></tr>
    <tr><td class="paramname">detail</td><td>Detail state required. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="structpj__pool__factory.htm#a58915f2e3bf8e239dde371a247d5c99b">pj_pool_factory::dump_status</a>.</p>

</div>
</div>
<a id="gac97b3e841c0c8d504d54c989fa415760" name="gac97b3e841c0c8d504d54c989fa415760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac97b3e841c0c8d504d54c989fa415760">&#9670;&nbsp;</a></span>pj_pool_factory_get_default_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a> * pj_pool_factory_get_default_policy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the default pool factory policy.</p>
<dl class="section return"><dt>Returns</dt><dd>the pool policy. </dd></dl>

</div>
</div>
<a id="gaf3038a0811c30b68619747334244078f" name="gaf3038a0811c30b68619747334244078f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3038a0811c30b68619747334244078f">&#9670;&nbsp;</a></span>pj_pool_init_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_pool_init_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&#160;</td>
          <td class="paramname"><em>increment_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function is intended to be used by pool factory implementors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool. </td></tr>
    <tr><td class="paramname">name</td><td>Pool name. </td></tr>
    <tr><td class="paramname">increment_size</td><td>Increment size. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga1e63ea214df265fa5f145e2837552a45" name="ga1e63ea214df265fa5f145e2837552a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e63ea214df265fa5f145e2837552a45">&#9670;&nbsp;</a></span>PJ_NO_MEMORY_EXCEPTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PJ_NO_MEMORY_EXCEPTION</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This constant denotes the exception number that will be thrown by default memory factory policy when memory allocation fails.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__PJ__POOL__FACTORY.htm#gac5d07e3f819942fb881a9f8b777fd0b1">pj_NO_MEMORY_EXCEPTION()</a> </dd></dl>

</div>
</div>
<a id="ga98cf758eafb888f318a8de7f396f47ca" name="ga98cf758eafb888f318a8de7f396f47ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98cf758eafb888f318a8de7f396f47ca">&#9670;&nbsp;</a></span>pj_pool_factory_default_policy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a> pj_pool_factory_default_policy</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This global variable points to default memory pool factory policy. The behaviour of the default policy is:</p><ul>
<li>block allocation and deallocation use malloc() and free().</li>
<li>callback will raise PJ_NO_MEMORY_EXCEPTION exception.</li>
<li>access to pool factory is not serialized (i.e. not thread safe).</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__PJ__POOL__FACTORY.htm#gac97b3e841c0c8d504d54c989fa415760">pj_pool_factory_get_default_policy</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>
<!--#include virtual="/footer.html" -->
</BODY>
</HTML>
