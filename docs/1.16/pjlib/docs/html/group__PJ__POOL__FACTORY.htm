<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PJLIB Reference: Pool Factory and Policy (1.16)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>


<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.htm"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>Pool Factory and Policy<br/>
<small>
[<a class="el" href="group__PJ__POOL__GROUP.htm">Fast Memory Pool</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>A pool object must be created through a factory. A factory not only provides generic interface functions to create and release pool, but also provides strategy to manage the life time of pools. One sample implementation, <em><a class="el" href="structpj__caching__pool.htm">pj_caching_pool</a></em>, can be set to keep the pools released by application for future use as long as the total memory is below the limit.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#gac5d07e3f819942fb881a9f8b777fd0b1">pj_NO_MEMORY_EXCEPTION</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#gafda24706943d2771cc93549afeb04b5c">pj_pool_factory_get_default_policy</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#ga1abb2de436e6d4c7db3bcc13b8ce967e">pj_pool_create_int</a> (<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *factory, const char *name, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> initial_size, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> increment_size, <a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#gaf3038a0811c30b68619747334244078f">pj_pool_init_int</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, const char *name, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> increment_size, <a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#gad9581731588a21cdf4461493829f6b29">pj_pool_destroy_int</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#gac01712a96e2e33528f6b4e0c44c229b5">pj_pool_factory_dump</a> (<a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *pf, <a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> detail)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#ga1e63ea214df265fa5f145e2837552a45">PJ_NO_MEMORY_EXCEPTION</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm#ga98cf758eafb888f318a8de7f396f47ca">pj_pool_factory_default_policy</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A pool object must be created through a factory. A factory not only provides generic interface functions to create and release pool, but also provides strategy to manage the life time of pools. One sample implementation, <em><a class="el" href="structpj__caching__pool.htm">pj_caching_pool</a></em>, can be set to keep the pools released by application for future use as long as the total memory is below the limit. </p>
<p>// PJ_POOL</p>
<p>The pool factory interface declared in PJLIB is designed to be extensible. Application can define its own strategy by creating it's own pool factory implementation, and this strategy can be used even by existing library without recompilation.</p>
<h2><a class="anchor" id="PJ_POOL_FACTORY_ITF"></a>
Pool Factory Interface</h2>
<p>The pool factory defines the following interface:</p>
<ul>
<li><em>policy:</em> the memory pool factory policy.</li>
<li><em>create_pool()</em>: create a new memory pool.</li>
<li><em>release_pool()</em>: release memory pool back to factory.</li>
</ul>
<h2><a class="anchor" id="PJ_POOL_FACTORY_POL"></a>
Pool Factory Policy.</h2>
<p>A pool factory only defines functions to create and release pool and how to manage pools, but the rest of the functionalities are controlled by policy. A pool policy defines:</p>
<ul>
<li>how memory block is allocated and deallocated (the default implementation allocates and deallocate memory by calling malloc() and free()).</li>
<li>callback to be called when memory allocation inside a pool fails (the default implementation will throw PJ_NO_MEMORY_EXCEPTION exception).</li>
<li>concurrency when creating and releasing pool from/to the factory.</li>
</ul>
<p>A pool factory can be given different policy during creation to make it behave differently. For example, caching pool factory can be configured to allocate and deallocate from a static/contiguous/preallocated memory instead of using malloc()/free().</p>
<p>What strategy/factory and what policy to use is not defined by PJLIB, but instead is left to application to make use whichever is most efficient for itself.</p>
<p>The pool factory policy controls the behaviour of memory factories, and defines the following interface:</p>
<ul>
<li><em>block_alloc()</em>: allocate memory block from backend memory mgmt/system.</li>
<li><em>block_free()</em>: free memory block back to backend memory mgmt/system. </li>
</ul>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gac5d07e3f819942fb881a9f8b777fd0b1"></a><!-- doxytag: member="pool.h::pj_NO_MEMORY_EXCEPTION" ref="gac5d07e3f819942fb881a9f8b777fd0b1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pj_NO_MEMORY_EXCEPTION </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get <a class="el" href="group__PJ__POOL__FACTORY.htm#ga1e63ea214df265fa5f145e2837552a45">PJ_NO_MEMORY_EXCEPTION</a> constant. </p>

</div>
</div>
<a class="anchor" id="ga1abb2de436e6d4c7db3bcc13b8ce967e"></a><!-- doxytag: member="pool.h::pj_pool_create_int" ref="ga1abb2de436e6d4c7db3bcc13b8ce967e" args="(pj_pool_factory *factory, const char *name, pj_size_t initial_size, pj_size_t increment_size, pj_pool_callback *callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a>* pj_pool_create_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>increment_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is intended to be used by pool factory implementors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>factory</em>&nbsp;</td><td>Pool factory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Pool name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>initial_size</em>&nbsp;</td><td>Initial size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>increment_size</em>&nbsp;</td><td>Increment size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pool object, or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="gad9581731588a21cdf4461493829f6b29"></a><!-- doxytag: member="pool.h::pj_pool_destroy_int" ref="gad9581731588a21cdf4461493829f6b29" args="(pj_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_pool_destroy_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is intended to be used by pool factory implementors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The memory pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac01712a96e2e33528f6b4e0c44c229b5"></a><!-- doxytag: member="pool.h::pj_pool_factory_dump" ref="gac01712a96e2e33528f6b4e0c44c229b5" args="(pj_pool_factory *pf, pj_bool_t detail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_pool_factory_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__factory.htm">pj_pool_factory</a> *&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>detail</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dump pool factory state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>The pool factory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detail</em>&nbsp;</td><td>Detail state required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafda24706943d2771cc93549afeb04b5c"></a><!-- doxytag: member="pool.h::pj_pool_factory_get_default_policy" ref="gafda24706943d2771cc93549afeb04b5c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a>* pj_pool_factory_get_default_policy </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the default pool factory policy.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pool policy. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3038a0811c30b68619747334244078f"></a><!-- doxytag: member="pool.h::pj_pool_init_int" ref="gaf3038a0811c30b68619747334244078f" args="(pj_pool_t *pool, const char *name, pj_size_t increment_size, pj_pool_callback *callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_pool_init_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>increment_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__POOL.htm#gabffd362d92627d62c4498b7efe0ae62a">pj_pool_callback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is intended to be used by pool factory implementors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The pool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Pool name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>increment_size</em>&nbsp;</td><td>Increment size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga1e63ea214df265fa5f145e2837552a45"></a><!-- doxytag: member="pool.h::PJ_NO_MEMORY_EXCEPTION" ref="ga1e63ea214df265fa5f145e2837552a45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__PJ__POOL__FACTORY.htm#ga1e63ea214df265fa5f145e2837552a45">PJ_NO_MEMORY_EXCEPTION</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This constant denotes the exception number that will be thrown by default memory factory policy when memory allocation fails. </p>

</div>
</div>
<a class="anchor" id="ga98cf758eafb888f318a8de7f396f47ca"></a><!-- doxytag: member="pool.h::pj_pool_factory_default_policy" ref="ga98cf758eafb888f318a8de7f396f47ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpj__pool__factory__policy.htm">pj_pool_factory_policy</a> <a class="el" href="group__PJ__POOL__FACTORY.htm#ga98cf758eafb888f318a8de7f396f47ca">pj_pool_factory_default_policy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This global variable points to default memory pool factory policy. The behaviour of the default policy is:</p>
<ul>
<li>block allocation and deallocation use malloc() and free().</li>
<li>callback will raise PJ_NO_MEMORY_EXCEPTION exception.</li>
<li>access to pool factory is not serialized (i.e. not thread safe).</li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__PJ__POOL__FACTORY.htm#gafda24706943d2771cc93549afeb04b5c">pj_pool_factory_get_default_policy</a> </dd></dl>

</div>
</div>
</div>
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
