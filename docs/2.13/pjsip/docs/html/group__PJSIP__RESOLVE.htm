<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SIP SRV Server Resolution (RFC 3263 - Locating SIP Servers) (2.13)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJSIP Reference</p>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">SIP SRV Server Resolution (RFC 3263 - Locating SIP Servers)<div class="ingroups"><a class="el" href="group__PJSIP__CORE.htm">Core SIP Library</a> &raquo; <a class="el" href="group__PJSIP__TRANSPORT.htm">Transport</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Framework to resolve SIP servers based on RFC 3263.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpjsip__server__addresses.htm">pjsip_server_addresses</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpjsip__ext__resolver.htm">pjsip_ext_resolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga457e5e9cfc2841e02b67c434d26be065"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJSIP__RESOLVE.htm#ga457e5e9cfc2841e02b67c434d26be065">pjsip_resolver_callback</a>(<a class="elRef" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status, void *token, const struct <a class="el" href="structpjsip__server__addresses.htm">pjsip_server_addresses</a> *addr)</td></tr>
<tr class="separator:ga457e5e9cfc2841e02b67c434d26be065"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5c1e9e313f751fdae679525797df28fa"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJSIP__RESOLVE.htm#ga5c1e9e313f751fdae679525797df28fa">pjsip_resolver_create</a> (<a class="elRef" href="../../../pjlib/docs/html/structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJSIP__TYPES.htm#ga4248a684363e25c3c61e826852056e6c">pjsip_resolver_t</a> **p_res)</td></tr>
<tr class="separator:ga5c1e9e313f751fdae679525797df28fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc5854b846fbcdd709e7e717b6e684d"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJSIP__RESOLVE.htm#gaadc5854b846fbcdd709e7e717b6e684d">pjsip_resolver_set_resolver</a> (<a class="el" href="group__PJSIP__TYPES.htm#ga4248a684363e25c3c61e826852056e6c">pjsip_resolver_t</a> *res, <a class="elRef" href="../../../pjlib-util/docs/html/group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *dns_res)</td></tr>
<tr class="separator:gaadc5854b846fbcdd709e7e717b6e684d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04be85a4c28ed636c095f999cf7c9d4"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJSIP__RESOLVE.htm#gaa04be85a4c28ed636c095f999cf7c9d4">pjsip_resolver_set_ext_resolver</a> (<a class="el" href="group__PJSIP__TYPES.htm#ga4248a684363e25c3c61e826852056e6c">pjsip_resolver_t</a> *res, <a class="el" href="structpjsip__ext__resolver.htm">pjsip_ext_resolver</a> *ext_res)</td></tr>
<tr class="separator:gaa04be85a4c28ed636c095f999cf7c9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aae4ca40257df136f2d35b37d516a48"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="../../../pjlib-util/docs/html/group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJSIP__RESOLVE.htm#ga7aae4ca40257df136f2d35b37d516a48">pjsip_resolver_get_resolver</a> (<a class="el" href="group__PJSIP__TYPES.htm#ga4248a684363e25c3c61e826852056e6c">pjsip_resolver_t</a> *res)</td></tr>
<tr class="separator:ga7aae4ca40257df136f2d35b37d516a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1817745b180ca25dea22166690da327b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJSIP__RESOLVE.htm#ga1817745b180ca25dea22166690da327b">pjsip_resolver_destroy</a> (<a class="el" href="group__PJSIP__TYPES.htm#ga4248a684363e25c3c61e826852056e6c">pjsip_resolver_t</a> *resolver)</td></tr>
<tr class="separator:ga1817745b180ca25dea22166690da327b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd0b21fb0813758386ff2a345f500138"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJSIP__RESOLVE.htm#gadd0b21fb0813758386ff2a345f500138">pjsip_resolve</a> (<a class="el" href="group__PJSIP__TYPES.htm#ga4248a684363e25c3c61e826852056e6c">pjsip_resolver_t</a> *resolver, <a class="elRef" href="../../../pjlib/docs/html/structpj__pool__t.htm">pj_pool_t</a> *pool, const <a class="el" href="structpjsip__host__info.htm">pjsip_host_info</a> *target, void *token, <a class="el" href="group__PJSIP__RESOLVE.htm#ga457e5e9cfc2841e02b67c434d26be065">pjsip_resolver_callback</a> *cb)</td></tr>
<tr class="separator:gadd0b21fb0813758386ff2a345f500138"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="PJSIP_RESOLVE_FEATURES"></a>
Features</h1>
<p >This is the SIP server resolution framework, which is modelled after RFC 3263 - Locating SIP Servers document. The SIP server resolution framework is asynchronous; callback will be called once the server address has been resolved (successfully or with errors).</p>
<h2><a class="anchor" id="PJSIP_RESOLVE_CONFORMANT"></a>
Conformance to RFC 3263</h2>
<p >The SIP server resolution framework is modelled after RFC 3263 (Locating SIP Servers) document, and it provides a single function (<a class="el" href="group__PJSIP__RESOLVE.htm#gadd0b21fb0813758386ff2a345f500138">pjsip_resolve()</a>) to resolve a domain into actual IP addresses of the servers, by querying DNS SRV record and DNS A record where necessary.</p>
<p >The <a class="el" href="group__PJSIP__RESOLVE.htm#gadd0b21fb0813758386ff2a345f500138">pjsip_resolve()</a> function performs the server resolution according to RFC 3263 with some additional fallback mechanisms, as follows:</p><ul>
<li>if the target name is an IP address, the callback will be called immediately with the IP address. If port number was specified, this port number will be used, otherwise the default port number for the transport will be used (5060 for TCP/UDP, 5061 for TLS) if the transport is specified. If the transport is not specified, UDP with port number 5060 will be used.</li>
<li>if target name is not an IP address but it contains port number, then the target name is resolved with DNS A (or AAAA, when IPv6 is supported in the future) query, and the port is taken from the port number argument. The callback will be called once the DNS A resolution completes. If the DNS A resolution returns multiple IP addresses, these IP addresses will be returned to the caller.</li>
<li>if target name is not an IP address and port number is not specified, DNS SRV resolution will be performed for the specified name and transport type (or UDP when transport is not specified), then followed by DNS A (or AAAA, when IPv6 is supported) resolution for each target in the SRV record. If DNS SRV resolution returns error, DNS A (or AAAA) resolution will be performed for the original target (it is assumed that the target domain does not support SRV records). Upon successful completion, application callback will be called with each IP address of the target selected based on the load-balancing and fail-over criteria below.</li>
</ul>
<p >The above server resolution procedure differs from RFC 3263 in these regards:</p><ul>
<li>currently <a class="el" href="group__PJSIP__RESOLVE.htm#gadd0b21fb0813758386ff2a345f500138">pjsip_resolve()</a> doesn't support DNS NAPTR record.</li>
<li>if transport is not specified, it is assumed to be UDP (the proper behavior is to query the NAPTR record, but we don't support this yet).</li>
</ul>
<h2><a class="anchor" id="PJSIP_SIP_RESOLVE_FAILOVER_LOADBALANCE"></a>
Load-Balancing and Fail-Over</h2>
<p >When multiple targets are returned in the DNS SRV response, server entries are selected based on the following rule (which is described in RFC 2782):</p><ul>
<li>targets will be sorted based on the priority first.</li>
<li>for targets with the same priority, <a class="el" href="group__PJSIP__RESOLVE.htm#gadd0b21fb0813758386ff2a345f500138">pjsip_resolve()</a> will select only one target according to its weight. To select this one target, the function associates running-sum for all targets, and generates a random number between zero and the total running-sum (inclusive). The target selected is the first target with running-sum greater than or equal to this random number.</li>
</ul>
<p >The above procedure will select one target for each priority, allowing application to fail-over to the next target when the previous target fails. These targets are returned in the <a class="el" href="structpjsip__server__addresses.htm">pjsip_server_addresses</a> structure argument of the callback.</p>
<h2><a class="anchor" id="PJSIP_SIP_RESOLVE_SIP_FEATURES"></a>
SIP SRV Resolver Features</h2>
<p >Some features of the SIP resolver:</p><ul>
<li>DNS SRV entries are returned on sorted order based on priority to allow failover to the next appropriate server.</li>
<li>The procedure in RFC 2782 is used to select server with the same priority to load-balance the servers load.</li>
<li>A single function (<a class="el" href="group__PJSIP__RESOLVE.htm#gadd0b21fb0813758386ff2a345f500138">pjsip_resolve()</a>) performs all server resolution works, from resolving the SRV records to getting the actual IP addresses of the servers with DNS A (or AAAA) resolution.</li>
<li>When multiple DNS SRV records are returned, parallel DNS A (or AAAA) queries will be issued simultaneously.</li>
<li>The PJLIB-UTIL DNS resolver provides additional functionality such as response caching, query aggregation, parallel nameservers, fallback nameserver, etc., which will be described below.</li>
<li>Enable application to provide its own resolver implementation. <br  />
</li>
</ul>
<h2><a class="anchor" id="PJSIP_RESOLVE_DNS_FEATURES"></a>
DNS Resolver Features</h2>
<p >The PJSIP server resolution framework uses PJLIB-UTIL DNS resolver engine for performing the asynchronous DNS request. The PJLIB-UTIL DNS resolver has some useful features, such as:</p><ul>
<li>queries are asynchronous with configurable timeout,</li>
<li>query aggregation to combine multiple pending queries to the same DNS target into a single DNS request (to save message round-trip and processing),</li>
<li>response caching with TTL negotiated between the minimum TTL found in the response and the maximum TTL allowed in the configuration,</li>
<li>multiple nameservers, with active nameserver is selected from nameserver which provides the best response time,</li>
<li>fallback nameserver, with periodic detection of which name servers are active or down.</li>
<li>etc.</li>
</ul>
<p >Please consult PJLIB-UTIL DNS resolver documentation for more details.</p>
<h1><a class="anchor" id="PJSIP_RESOLVE_USING"></a>
Using the Resolver</h1>
<p >To maintain backward compatibility, the resolver MUST be enabled manually. With the default settings, the resolver WILL NOT perform DNS SRV resolution, as it will just resolve the name with standard <a class="elRef" href="../../../pjlib/docs/html/group__pj__addr__resolve.htm#ga7c8264aa7743594d31766679dbae0b88">pj_gethostbyname()</a> function.</p>
<p >Application can enable the SRV resolver by creating the PJLIB-UTIL DNS resolver with <a class="el" href="group__PJSIP__ENDPT.htm#ga341266ecfb3000a726ca02cba9d468bd">pjsip_endpt_create_resolver()</a>, configure the nameservers of the PJLIB-UTIL DNS resolver object by calling <a class="elRef" href="../../../pjlib-util/docs/html/group__PJ__DNS__RESOLVER.htm#ga4ab10b4a3331a88237a083e3ef23574f">pj_dns_resolver_set_ns()</a> function, and pass the DNS resolver object to <a class="el" href="group__PJSIP__RESOLVE.htm#gaadc5854b846fbcdd709e7e717b6e684d">pjsip_resolver_set_resolver()</a> function.</p>
<p >Once the resolver is set, it will be used automatically by PJSIP everytime PJSIP needs to send SIP request/response messages.</p>
<h1><a class="anchor" id="PJSIP_RESOLVE_EXT_RESOLVER"></a>
External Resolver</h1>
<p >As an alternative to enabling PJLIB-UTIL DNS resolver, application can provide its own resolver implementation by defining the callback in <a class="el" href="structpjsip__ext__resolver.htm">pjsip_ext_resolver</a> and pass the callback to <a class="el" href="group__PJSIP__RESOLVE.htm#gaa04be85a4c28ed636c095f999cf7c9d4">pjsip_resolver_set_ext_resolver()</a> function. Please note that if the implementation needs feature from PJLIB-UTL DNS resolver, it has to create its own PJLIB-UTL DNS resolver instance.</p>
<h1><a class="anchor" id="PJSIP_RESOLVE_REFERENCE"></a>
Reference</h1>
<p >Reference:</p><ul>
<li>RFC 2782: A DNS RR for specifying the location of services (DNS SRV)</li>
<li>RFC 3263: Locating SIP Servers </li>
</ul>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga457e5e9cfc2841e02b67c434d26be065" name="ga457e5e9cfc2841e02b67c434d26be065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga457e5e9cfc2841e02b67c434d26be065">&#9670;&nbsp;</a></span>pjsip_resolver_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void pjsip_resolver_callback(<a class="elRef" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status, void *token, const struct <a class="el" href="structpjsip__server__addresses.htm">pjsip_server_addresses</a> *addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The type of callback function to be called when resolver finishes the job.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>The status of the operation, which is zero on success. </td></tr>
    <tr><td class="paramname">token</td><td>The token that was associated with the job when application call the resolve function. </td></tr>
    <tr><td class="paramname">addr</td><td>The addresses resolved by the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5c1e9e313f751fdae679525797df28fa" name="ga5c1e9e313f751fdae679525797df28fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c1e9e313f751fdae679525797df28fa">&#9670;&nbsp;</a></span>pjsip_resolver_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pjsip_resolver_create </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../../pjlib/docs/html/structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJSIP__TYPES.htm#ga4248a684363e25c3c61e826852056e6c">pjsip_resolver_t</a> **&#160;</td>
          <td class="paramname"><em>p_res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create SIP resolver engine. Note that this function is normally called internally by pjsip_endpoint instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool to allocate memory from. </td></tr>
    <tr><td class="paramname">p_res</td><td>Pointer to receive SIP resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS when resolver can be successfully created. </dd></dl>

</div>
</div>
<a id="gaadc5854b846fbcdd709e7e717b6e684d" name="gaadc5854b846fbcdd709e7e717b6e684d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadc5854b846fbcdd709e7e717b6e684d">&#9670;&nbsp;</a></span>pjsip_resolver_set_resolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pjsip_resolver_set_resolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJSIP__TYPES.htm#ga4248a684363e25c3c61e826852056e6c">pjsip_resolver_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../../pjlib-util/docs/html/group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *&#160;</td>
          <td class="paramname"><em>dns_res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the DNS resolver instance of the SIP resolver engine. Before the DNS resolver is set, the SIP resolver will use standard <a class="elRef" href="../../../pjlib/docs/html/group__pj__addr__resolve.htm#ga7c8264aa7743594d31766679dbae0b88">pj_gethostbyname()</a> to resolve addresses.</p>
<p >Note that application normally will use <a class="el" href="group__PJSIP__ENDPT.htm#gaa783363fa5b0d6d1fd081bfd40d4314b">pjsip_endpt_set_resolver()</a> instead since it does not normally have access to the SIP resolver instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The SIP resolver engine. </td></tr>
    <tr><td class="paramname">dns_res</td><td>The DNS resolver instance to be used by the SIP resolver. This argument can be NULL to reset the internal DNS instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS on success, or the appropriate error code. </dd></dl>

</div>
</div>
<a id="gaa04be85a4c28ed636c095f999cf7c9d4" name="gaa04be85a4c28ed636c095f999cf7c9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa04be85a4c28ed636c095f999cf7c9d4">&#9670;&nbsp;</a></span>pjsip_resolver_set_ext_resolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pjsip_resolver_set_ext_resolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJSIP__TYPES.htm#ga4248a684363e25c3c61e826852056e6c">pjsip_resolver_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpjsip__ext__resolver.htm">pjsip_ext_resolver</a> *&#160;</td>
          <td class="paramname"><em>ext_res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the DNS external resolver implementation to use in the SIP resolver engine. Naturally when implementing its own resolver, application would not need the internal resolver, hence this function will also destroy the PJLIB-UTIL DNS resolver if any (e.g: set using <a class="el" href="group__PJSIP__RESOLVE.htm#gaadc5854b846fbcdd709e7e717b6e684d">pjsip_resolver_set_resolver()</a>). Application that needs it, still be able create its own instance.</p>
<p >Note that application normally will use <a class="el" href="group__PJSIP__ENDPT.htm#ga9b4dbd5940d3388b571eb830884c1786">pjsip_endpt_set_ext_resolver()</a> instead since it does not normally have access to the SIP resolver instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The SIP resolver engine. </td></tr>
    <tr><td class="paramname">ext_res</td><td>The external resolver implementation callback. This argument can be NULL to reset the whole external implementation. However, it is prohibited to reset individual callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PJ_SUCCESS on success, or the appropriate error code. </dd></dl>

</div>
</div>
<a id="ga7aae4ca40257df136f2d35b37d516a48" name="ga7aae4ca40257df136f2d35b37d516a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aae4ca40257df136f2d35b37d516a48">&#9670;&nbsp;</a></span>pjsip_resolver_get_resolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../../../pjlib-util/docs/html/group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> * pjsip_resolver_get_resolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJSIP__TYPES.htm#ga4248a684363e25c3c61e826852056e6c">pjsip_resolver_t</a> *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the DNS resolver instance of the SIP resolver engine.</p>
<p >Note that application normally will use <a class="el" href="group__PJSIP__ENDPT.htm#ga6d1813527291fa846382035d8ce2b9c0">pjsip_endpt_get_resolver()</a> instead since it does not normally have access to the SIP resolver instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The SIP resolver engine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DNS resolver instance (may be NULL) </dd></dl>

</div>
</div>
<a id="ga1817745b180ca25dea22166690da327b" name="ga1817745b180ca25dea22166690da327b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1817745b180ca25dea22166690da327b">&#9670;&nbsp;</a></span>pjsip_resolver_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pjsip_resolver_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJSIP__TYPES.htm#ga4248a684363e25c3c61e826852056e6c">pjsip_resolver_t</a> *&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Destroy resolver engine. Note that this will also destroy the internal DNS resolver inside the engine. If application doesn't want the internal DNS resolver to be destroyed, it should set the internal DNS resolver to NULL before calling this function.</p>
<p >Note that this function will normally called by the SIP endpoint instance when the SIP endpoint instance is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>The resolver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd0b21fb0813758386ff2a345f500138" name="gadd0b21fb0813758386ff2a345f500138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd0b21fb0813758386ff2a345f500138">&#9670;&nbsp;</a></span>pjsip_resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pjsip_resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJSIP__TYPES.htm#ga4248a684363e25c3c61e826852056e6c">pjsip_resolver_t</a> *&#160;</td>
          <td class="paramname"><em>resolver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../../pjlib/docs/html/structpj__pool__t.htm">pj_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpjsip__host__info.htm">pjsip_host_info</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJSIP__RESOLVE.htm#ga457e5e9cfc2841e02b67c434d26be065">pjsip_resolver_callback</a> *&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Asynchronously resolve a SIP target host or domain according to rule specified in RFC 3263 (Locating SIP Servers). When the resolving operation has completed, the callback will be called.</p>
<p >Note that application normally will use <a class="el" href="group__PJSIP__ENDPT.htm#ga96a7ae57882371b0373b5780bea1c6e2">pjsip_endpt_resolve()</a> instead since it does not normally have access to the SIP resolver instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>The resolver engine. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate resolver job. </td></tr>
    <tr><td class="paramname">target</td><td>The target specification to be resolved. </td></tr>
    <tr><td class="paramname">token</td><td>A user defined token to be passed back to callback function. </td></tr>
    <tr><td class="paramname">cb</td><td>The callback function. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="elRef" href="../../../pjlib/docs/html/group__pj__config.htm#gac961f7d199eeed7666ab3ec2442c1b00">PJ_END_DECL</a>.</p>

</div>
</div>
</div><!-- contents -->
<p>&nbsp;</p>
<hr><center>
PJSIP Open Source, high performance, small footprint, and very very portable SIP stack<br>
Copyright (C) 2006-2008 Teluu Inc.
</center>
<!--#include virtual="/footer.html" -->
</BODY>
</HTML>
