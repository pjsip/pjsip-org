<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pj::ContainerNode Class Reference (2.13)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJSIP Reference</p>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepj.htm">pj</a></li><li class="navelem"><a class="el" href="classpj_1_1ContainerNode.htm">ContainerNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">pj::ContainerNode Class Reference<div class="ingroups"><a class="el" href="group__PJSUA2__Ref.htm">pjsua2 API Reference</a> &raquo; <a class="el" href="group__PJSUA2__PERSISTENT.htm">Persistent API</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;persistent.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af50cdb31a66fa0989f137cc84d10f989"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#af50cdb31a66fa0989f137cc84d10f989">hasUnread</a> () const</td></tr>
<tr class="separator:af50cdb31a66fa0989f137cc84d10f989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7881f9807c4a476ba6ccafce27cac12a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#a7881f9807c4a476ba6ccafce27cac12a">unreadName</a> () const  throw (Error)</td></tr>
<tr class="separator:a7881f9807c4a476ba6ccafce27cac12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972c48cb7a9b0ae2fad180b3f84047dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#a972c48cb7a9b0ae2fad180b3f84047dd">readInt</a> (const string &amp;name=&quot;&quot;) const  throw (Error)</td></tr>
<tr class="separator:a972c48cb7a9b0ae2fad180b3f84047dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada5ddee0c037d2f91d49e20ef50f3bb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#aada5ddee0c037d2f91d49e20ef50f3bb">readNumber</a> (const string &amp;name=&quot;&quot;) const  throw (Error)</td></tr>
<tr class="separator:aada5ddee0c037d2f91d49e20ef50f3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab118abb3c6dfd29963fef2968ef2cfa5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#ab118abb3c6dfd29963fef2968ef2cfa5">readBool</a> (const string &amp;name=&quot;&quot;) const  throw (Error)</td></tr>
<tr class="separator:ab118abb3c6dfd29963fef2968ef2cfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa848c5cdefe1924d764a63384d1b19"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#a5fa848c5cdefe1924d764a63384d1b19">readString</a> (const string &amp;name=&quot;&quot;) const  throw (Error)</td></tr>
<tr class="separator:a5fa848c5cdefe1924d764a63384d1b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1dec91a2ba87be8c8c1c73740e97e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJSUA2__TYPES.htm#gaf4b042acfebd1325cae85c758f4482ae">StringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#abb1dec91a2ba87be8c8c1c73740e97e8">readStringVector</a> (const string &amp;name=&quot;&quot;) const  throw (Error)</td></tr>
<tr class="separator:abb1dec91a2ba87be8c8c1c73740e97e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00278a89e264f65118c376a12e1807d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#a00278a89e264f65118c376a12e1807d2">readObject</a> (<a class="el" href="classpj_1_1PersistentObject.htm">PersistentObject</a> &amp;obj) const  throw (Error)</td></tr>
<tr class="separator:a00278a89e264f65118c376a12e1807d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e89cb8328505442e4beddc205787ed6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpj_1_1ContainerNode.htm">ContainerNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#a7e89cb8328505442e4beddc205787ed6">readContainer</a> (const string &amp;name=&quot;&quot;) const  throw (Error)</td></tr>
<tr class="separator:a7e89cb8328505442e4beddc205787ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7663805f8f94bfa8b56a0ba540f4abd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpj_1_1ContainerNode.htm">ContainerNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#ab7663805f8f94bfa8b56a0ba540f4abd">readArray</a> (const string &amp;name=&quot;&quot;) const  throw (Error)</td></tr>
<tr class="separator:ab7663805f8f94bfa8b56a0ba540f4abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b2510b610739503dda42bcfa15b318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#aa7b2510b610739503dda42bcfa15b318">writeNumber</a> (const string &amp;name, float num)  throw (Error)</td></tr>
<tr class="separator:aa7b2510b610739503dda42bcfa15b318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa051e095eb51edea22a24986b274a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#a9aa051e095eb51edea22a24986b274a5">writeInt</a> (const string &amp;name, int num)  throw (Error)</td></tr>
<tr class="separator:a9aa051e095eb51edea22a24986b274a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a960c4ceb350e091c1838a02d3f7e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#af1a960c4ceb350e091c1838a02d3f7e7">writeBool</a> (const string &amp;name, bool value)  throw (Error)</td></tr>
<tr class="separator:af1a960c4ceb350e091c1838a02d3f7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b377f5789e7f624c0e393ca5919389"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#ab5b377f5789e7f624c0e393ca5919389">writeString</a> (const string &amp;name, const string &amp;value)  throw (Error)</td></tr>
<tr class="separator:ab5b377f5789e7f624c0e393ca5919389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3925102847c303d1bc5c462aa692e672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#a3925102847c303d1bc5c462aa692e672">writeStringVector</a> (const string &amp;name, const <a class="el" href="group__PJSUA2__TYPES.htm#gaf4b042acfebd1325cae85c758f4482ae">StringVector</a> &amp;arr)  throw (Error)</td></tr>
<tr class="separator:a3925102847c303d1bc5c462aa692e672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12722c653b967c55144082cfeda41548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#a12722c653b967c55144082cfeda41548">writeObject</a> (const <a class="el" href="classpj_1_1PersistentObject.htm">PersistentObject</a> &amp;obj)  throw (Error)</td></tr>
<tr class="separator:a12722c653b967c55144082cfeda41548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d03493dc7ca00b4a0766f0e6b8ad44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpj_1_1ContainerNode.htm">ContainerNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#a45d03493dc7ca00b4a0766f0e6b8ad44">writeNewContainer</a> (const string &amp;name)  throw (Error)</td></tr>
<tr class="separator:a45d03493dc7ca00b4a0766f0e6b8ad44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fd4e059e0ab71c4e9c85c29af8fa48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpj_1_1ContainerNode.htm">ContainerNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#a57fd4e059e0ab71c4e9c85c29af8fa48">writeNewArray</a> (const string &amp;name)  throw (Error)</td></tr>
<tr class="separator:a57fd4e059e0ab71c4e9c85c29af8fa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ab08ebd39b93ea1c3b4b2daa3aa77116c"><td class="memItemLeft" align="right" valign="top">container_node_op *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#ab08ebd39b93ea1c3b4b2daa3aa77116c">op</a></td></tr>
<tr class="separator:ab08ebd39b93ea1c3b4b2daa3aa77116c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb63a55dceaf7c55da9c9bf51b7332a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpj_1_1container__node__internal__data.htm">container_node_internal_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpj_1_1ContainerNode.htm#a7cb63a55dceaf7c55da9c9bf51b7332a">data</a></td></tr>
<tr class="separator:a7cb63a55dceaf7c55da9c9bf51b7332a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A container node is a placeholder for storing other data elements, which could be boolean, number, string, array of strings, or another container. Each data in the container is basically a name/value pair, with a type internally associated with it so that written data can be read in the correct type. Data is read and written serially, hence the order of reading must be the same as the order of writing.</p>
<p >Application can read data from it by using the various read methods, and write data to it using the various write methods. Alternatively, it may be more convenient to use the provided macros below to read and write the data, because these macros set the name automatically:</p><ul>
<li>NODE_READ_BOOL(node,item)</li>
<li>NODE_READ_UNSIGNED(node,item)</li>
<li>NODE_READ_INT(node,item)</li>
<li>NODE_READ_FLOAT(node,item)</li>
<li>NODE_READ_NUM_T(node,type,item)</li>
<li>NODE_READ_STRING(node,item)</li>
<li>NODE_READ_STRINGV(node,item)</li>
<li>NODE_READ_OBJ(node,item)</li>
<li>NODE_WRITE_BOOL(node,item)</li>
<li>NODE_WRITE_UNSIGNED(node,item)</li>
<li>NODE_WRITE_INT(node,item)</li>
<li>NODE_WRITE_FLOAT(node,item)</li>
<li>NODE_WRITE_NUM_T(node,type,item)</li>
<li>NODE_WRITE_STRING(node,item)</li>
<li>NODE_WRITE_STRINGV(node,item)</li>
<li>NODE_WRITE_OBJ(node,item)</li>
</ul>
<p >Implementation notes:</p>
<p >The <a class="el" href="classpj_1_1ContainerNode.htm">ContainerNode</a> class is subclass-able, but not in the usual C++ way. With the usual C++ inheritance, some methods will be made pure virtual and must be implemented by the actual class. However, doing so will require dynamic instantiation of the <a class="el" href="classpj_1_1ContainerNode.htm">ContainerNode</a> class, which means we will need to pass around the class as pointer, for example as the return value of <a class="el" href="classpj_1_1ContainerNode.htm#a7e89cb8328505442e4beddc205787ed6">readContainer()</a> and <a class="el" href="classpj_1_1ContainerNode.htm#a45d03493dc7ca00b4a0766f0e6b8ad44">writeNewContainer()</a> methods. Then we will need to establish who needs or how to delete these objects, or use shared pointer mechanism, each of which is considered too inconvenient or complicated for the purpose.</p>
<p >So hence we use C style "inheritance", where the methods are declared in container_node_op and the data in <a class="el" href="structpj_1_1container__node__internal__data.htm">container_node_internal_data</a> structures. An implementation of <a class="el" href="classpj_1_1ContainerNode.htm">ContainerNode</a> class will need to set up these members with values that makes sense to itself. The methods in container_node_op contains the pointer to the actual implementation of the operation, which would be specific according to the format of the document. The methods in this <a class="el" href="classpj_1_1ContainerNode.htm">ContainerNode</a> class are just thin wrappers which call the implementation in the container_node_op structure. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af50cdb31a66fa0989f137cc84d10f989" name="af50cdb31a66fa0989f137cc84d10f989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50cdb31a66fa0989f137cc84d10f989">&#9670;&nbsp;</a></span>hasUnread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pj::ContainerNode::hasUnread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine if there is unread element. If yes, then app can use one of the readXxx() functions to read it. </p>

</div>
</div>
<a id="a7881f9807c4a476ba6ccafce27cac12a" name="a7881f9807c4a476ba6ccafce27cac12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7881f9807c4a476ba6ccafce27cac12a">&#9670;&nbsp;</a></span>unreadName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string pj::ContainerNode::unreadName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the name of the next unread element. </p>

</div>
</div>
<a id="a972c48cb7a9b0ae2fad180b3f84047dd" name="a972c48cb7a9b0ae2fad180b3f84047dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972c48cb7a9b0ae2fad180b3f84047dd">&#9670;&nbsp;</a></span>readInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pj::ContainerNode::readInt </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read an integer value from the document and return the value. This will throw <a class="el" href="structpj_1_1Error.htm">Error</a> if the current element is not a number. The read position will be advanced to the next element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>If specified, then the function will check if the name of the next element matches the specified name and throw <a class="el" href="structpj_1_1Error.htm">Error</a> if it doesn't match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value. </dd></dl>

</div>
</div>
<a id="aada5ddee0c037d2f91d49e20ef50f3bb" name="aada5ddee0c037d2f91d49e20ef50f3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada5ddee0c037d2f91d49e20ef50f3bb">&#9670;&nbsp;</a></span>readNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pj::ContainerNode::readNumber </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read a number value from the document and return the value. This will throw <a class="el" href="structpj_1_1Error.htm">Error</a> if the current element is not a number. The read position will be advanced to the next element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>If specified, then the function will check if the name of the next element matches the specified name and throw <a class="el" href="structpj_1_1Error.htm">Error</a> if it doesn't match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value. </dd></dl>

</div>
</div>
<a id="ab118abb3c6dfd29963fef2968ef2cfa5" name="ab118abb3c6dfd29963fef2968ef2cfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab118abb3c6dfd29963fef2968ef2cfa5">&#9670;&nbsp;</a></span>readBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pj::ContainerNode::readBool </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read a boolean value from the container and return the value. This will throw <a class="el" href="structpj_1_1Error.htm">Error</a> if the current element is not a boolean. The read position will be advanced to the next element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>If specified, then the function will check if the name of the next element matches the specified name and throw <a class="el" href="structpj_1_1Error.htm">Error</a> if it doesn't match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value. </dd></dl>

</div>
</div>
<a id="a5fa848c5cdefe1924d764a63384d1b19" name="a5fa848c5cdefe1924d764a63384d1b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa848c5cdefe1924d764a63384d1b19">&#9670;&nbsp;</a></span>readString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string pj::ContainerNode::readString </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read a string value from the container and return the value. This will throw <a class="el" href="structpj_1_1Error.htm">Error</a> if the current element is not a string. The read position will be advanced to the next element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>If specified, then the function will check if the name of the next element matches the specified name and throw <a class="el" href="structpj_1_1Error.htm">Error</a> if it doesn't match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value. </dd></dl>

</div>
</div>
<a id="abb1dec91a2ba87be8c8c1c73740e97e8" name="abb1dec91a2ba87be8c8c1c73740e97e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1dec91a2ba87be8c8c1c73740e97e8">&#9670;&nbsp;</a></span>readStringVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJSUA2__TYPES.htm#gaf4b042acfebd1325cae85c758f4482ae">StringVector</a> pj::ContainerNode::readStringVector </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read a string array from the container. This will throw <a class="el" href="structpj_1_1Error.htm">Error</a> if the current element is not a string array. The read position will be advanced to the next element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>If specified, then the function will check if the name of the next element matches the specified name and throw <a class="el" href="structpj_1_1Error.htm">Error</a> if it doesn't match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value. </dd></dl>

</div>
</div>
<a id="a00278a89e264f65118c376a12e1807d2" name="a00278a89e264f65118c376a12e1807d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00278a89e264f65118c376a12e1807d2">&#9670;&nbsp;</a></span>readObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj::ContainerNode::readObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpj_1_1PersistentObject.htm">PersistentObject</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read the specified object from the container. This is equal to calling PersistentObject.readObject(ContainerNode);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e89cb8328505442e4beddc205787ed6" name="a7e89cb8328505442e4beddc205787ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e89cb8328505442e4beddc205787ed6">&#9670;&nbsp;</a></span>readContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpj_1_1ContainerNode.htm">ContainerNode</a> pj::ContainerNode::readContainer </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read a container from the container. This will throw <a class="el" href="structpj_1_1Error.htm">Error</a> if the current element is not a container. The read position will be advanced to the next element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>If specified, then the function will check if the name of the next element matches the specified name and throw <a class="el" href="structpj_1_1Error.htm">Error</a> if it doesn't match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Container object. </dd></dl>

</div>
</div>
<a id="ab7663805f8f94bfa8b56a0ba540f4abd" name="ab7663805f8f94bfa8b56a0ba540f4abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7663805f8f94bfa8b56a0ba540f4abd">&#9670;&nbsp;</a></span>readArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpj_1_1ContainerNode.htm">ContainerNode</a> pj::ContainerNode::readArray </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read array container from the container. This will throw <a class="el" href="structpj_1_1Error.htm">Error</a> if the current element is not an array. The read position will be advanced to the next element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>If specified, then the function will check if the name of the next element matches the specified name and throw <a class="el" href="structpj_1_1Error.htm">Error</a> if it doesn't match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Container object. </dd></dl>

</div>
</div>
<a id="aa7b2510b610739503dda42bcfa15b318" name="aa7b2510b610739503dda42bcfa15b318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b2510b610739503dda42bcfa15b318">&#9670;&nbsp;</a></span>writeNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj::ContainerNode::writeNumber </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write a number value to the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the value in the container. </td></tr>
    <tr><td class="paramname">num</td><td>The value to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9aa051e095eb51edea22a24986b274a5" name="a9aa051e095eb51edea22a24986b274a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa051e095eb51edea22a24986b274a5">&#9670;&nbsp;</a></span>writeInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj::ContainerNode::writeInt </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write a number value to the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the value in the container. </td></tr>
    <tr><td class="paramname">num</td><td>The value to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1a960c4ceb350e091c1838a02d3f7e7" name="af1a960c4ceb350e091c1838a02d3f7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a960c4ceb350e091c1838a02d3f7e7">&#9670;&nbsp;</a></span>writeBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj::ContainerNode::writeBool </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write a boolean value to the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the value in the container. </td></tr>
    <tr><td class="paramname">value</td><td>The value to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5b377f5789e7f624c0e393ca5919389" name="ab5b377f5789e7f624c0e393ca5919389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b377f5789e7f624c0e393ca5919389">&#9670;&nbsp;</a></span>writeString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj::ContainerNode::writeString </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write a string value to the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the value in the container. </td></tr>
    <tr><td class="paramname">value</td><td>The value to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3925102847c303d1bc5c462aa692e672" name="a3925102847c303d1bc5c462aa692e672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3925102847c303d1bc5c462aa692e672">&#9670;&nbsp;</a></span>writeStringVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj::ContainerNode::writeStringVector </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__PJSUA2__TYPES.htm#gaf4b042acfebd1325cae85c758f4482ae">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write string vector to the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the value in the container. </td></tr>
    <tr><td class="paramname">arr</td><td>The vector to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12722c653b967c55144082cfeda41548" name="a12722c653b967c55144082cfeda41548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12722c653b967c55144082cfeda41548">&#9670;&nbsp;</a></span>writeObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj::ContainerNode::writeObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpj_1_1PersistentObject.htm">PersistentObject</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write an object to the container. This is equal to calling PersistentObject.writeObject(ContainerNode);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45d03493dc7ca00b4a0766f0e6b8ad44" name="a45d03493dc7ca00b4a0766f0e6b8ad44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d03493dc7ca00b4a0766f0e6b8ad44">&#9670;&nbsp;</a></span>writeNewContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpj_1_1ContainerNode.htm">ContainerNode</a> pj::ContainerNode::writeNewContainer </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create and write an empty Object node that can be used as parent for subsequent write operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the new container in the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sub-container. </dd></dl>

</div>
</div>
<a id="a57fd4e059e0ab71c4e9c85c29af8fa48" name="a57fd4e059e0ab71c4e9c85c29af8fa48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fd4e059e0ab71c4e9c85c29af8fa48">&#9670;&nbsp;</a></span>writeNewArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpj_1_1ContainerNode.htm">ContainerNode</a> pj::ContainerNode::writeNewArray </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="structpj_1_1Error.htm">Error</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create and write an empty array node that can be used as parent for subsequent write operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sub-container. </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="ab08ebd39b93ea1c3b4b2daa3aa77116c" name="ab08ebd39b93ea1c3b4b2daa3aa77116c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08ebd39b93ea1c3b4b2daa3aa77116c">&#9670;&nbsp;</a></span>op</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">container_node_op* pj::ContainerNode::op</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method table. <br  />
 </p>

</div>
</div>
<a id="a7cb63a55dceaf7c55da9c9bf51b7332a" name="a7cb63a55dceaf7c55da9c9bf51b7332a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb63a55dceaf7c55da9c9bf51b7332a">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpj_1_1container__node__internal__data.htm">container_node_internal_data</a> pj::ContainerNode::data</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Internal data <br  />
 </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="persistent_8hpp.htm">persistent.hpp</a></li>
</ul>
</div><!-- contents -->
<p>&nbsp;</p>
<hr><center>
PJSIP Open Source, high performance, small footprint, and very very portable SIP stack<br>
Copyright (C) 2006-2008 Teluu Inc.
</center>
<!--#include virtual="/footer.html" -->
</BODY>
</HTML>
