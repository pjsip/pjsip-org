<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PJLIB Reference: Active socket I/O (1.16)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>


<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.htm"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Active socket I/O<br/>
<small>
[<a class="el" href="group__PJ__IO.htm">Input/Output</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Active socket performs active operations on socket.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__activesock__cb.htm">pj_activesock_cb</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga58b5e99dfabf0c15aefc42db69beb2cb">pj_activesock_cfg_default</a> (<a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a> *cfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gaad8adb25f996f1ae75a2b1e98e15e584">pj_activesock_create</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a> sock, int sock_type, const <a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a> *opt, <a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *ioqueue, const <a class="el" href="structpj__activesock__cb.htm">pj_activesock_cb</a> *cb, void *user_data, <a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> **p_asock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gafff5c0d4bb59a5085d2215b7530ace68">pj_activesock_create_udp</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, const <a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *addr, const <a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a> *opt, <a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *ioqueue, const <a class="el" href="structpj__activesock__cb.htm">pj_activesock_cb</a> *cb, void *user_data, <a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> **p_asock, <a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *bound_addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gac8a9253fe6327c82871e92f7e6bcd8d6">pj_activesock_close</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga35500827f3657a40c07a62e2fd423917">pj_activesock_set_user_data</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, void *user_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gac5a45c643541dbdd6d74a633fb28207d">pj_activesock_get_user_data</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gaff5faf21c01d9a606aa014a2f2791183">pj_activesock_start_read</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, unsigned buff_size, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gad392064eddce34de3a4d52a65ce94861">pj_activesock_start_read2</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, unsigned buff_size, void *readbuf[], <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga48dbb84c14a6a0f53adcda91d6d8ae1e">pj_activesock_start_recvfrom</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, unsigned buff_size, <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gad5d12dc84bd0bd35027f104b3edc8437">pj_activesock_start_recvfrom2</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, unsigned buff_size, void *readbuf[], <a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gaaa1bc3760aa6b278e8ace0841a0fd7f5">pj_activesock_send</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structsend__key.htm">send_key</a>, const void *data, <a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *size, unsigned flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga39e1466848c1d13642a65f063423ae44">pj_activesock_sendto</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structsend__key.htm">send_key</a>, const void *data, <a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *size, unsigned flags, const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *addr, int addr_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#gaea8588339a3981d944a8cf14847f1140">pj_activesock_start_accept</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga85245f4b7bfd186a2e2f28611a343133">pj_activesock_start_connect</a> (<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *remaddr, int addr_len)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Active socket performs active operations on socket. </p>
<p>Active socket is a higher level abstraction to the ioqueue. It provides automation to socket operations which otherwise would have to be done manually by the applications. For example with socket recv(), recvfrom(), and accept() operations, application only needs to invoke these operation once, and it will be notified whenever data or incoming TCP connection (in the case of accept()) arrives. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga2374729a4261eb7a1e780110bcef2e37"></a><!-- doxytag: member="activesock.h::pj_activesock_t" ref="ga2374729a4261eb7a1e780110bcef2e37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> <a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This opaque structure describes the active socket. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga58b5e99dfabf0c15aefc42db69beb2cb"></a><!-- doxytag: member="activesock.h::pj_activesock_cfg_default" ref="ga58b5e99dfabf0c15aefc42db69beb2cb" args="(pj_activesock_cfg *cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_activesock_cfg_default </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a> *&nbsp;</td>
          <td class="paramname"> <em>cfg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the active socket configuration with the default values.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cfg</em>&nbsp;</td><td>The configuration to be initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac8a9253fe6327c82871e92f7e6bcd8d6"></a><!-- doxytag: member="activesock.h::pj_activesock_close" ref="gac8a9253fe6327c82871e92f7e6bcd8d6" args="(pj_activesock_t *asock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>asock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the active socket. This will unregister the socket from the ioqueue and ultimately close the socket.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaad8adb25f996f1ae75a2b1e98e15e584"></a><!-- doxytag: member="activesock.h::pj_activesock_create" ref="gaad8adb25f996f1ae75a2b1e98e15e584" args="(pj_pool_t *pool, pj_sock_t sock, int sock_type, const pj_activesock_cfg *opt, pj_ioqueue_t *ioqueue, const pj_activesock_cb *cb, void *user_data, pj_activesock_t **p_asock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a>&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sock_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a> *&nbsp;</td>
          <td class="paramname"> <em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ioqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__activesock__cb.htm">pj_activesock_cb</a> *&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> **&nbsp;</td>
          <td class="paramname"> <em>p_asock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create the active socket for the specified socket. This will register the socket to the specified ioqueue.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>Pool to allocate memory from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>The socket handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sock_type</em>&nbsp;</td><td>Specify socket type, either <a class="el" href="group__PJ__SOCK.htm#gaaa5fa1293ffc11d0970811819b3828dc">pj_SOCK_DGRAM()</a> or <a class="el" href="group__PJ__SOCK.htm#gae224fbf8e8bd55b40030fcd8f9645291">pj_SOCK_STREAM()</a>. The active socket needs this information to handle connection closure for connection oriented sockets. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ioqueue</em>&nbsp;</td><td>The ioqueue to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opt</em>&nbsp;</td><td>Optional settings. When this setting is not specifed, the default values will be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>Pointer to structure containing application callbacks. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>Arbitrary user data to be associated with this active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_asock</em>&nbsp;</td><td>Pointer to receive the active socket instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gafff5c0d4bb59a5085d2215b7530ace68"></a><!-- doxytag: member="activesock.h::pj_activesock_create_udp" ref="gafff5c0d4bb59a5085d2215b7530ace68" args="(pj_pool_t *pool, const pj_sockaddr *addr, const pj_activesock_cfg *opt, pj_ioqueue_t *ioqueue, const pj_activesock_cb *cb, void *user_data, pj_activesock_t **p_asock, pj_sockaddr *bound_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_create_udp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__activesock__cfg.htm">pj_activesock_cfg</a> *&nbsp;</td>
          <td class="paramname"> <em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ioqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__activesock__cb.htm">pj_activesock_cb</a> *&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> **&nbsp;</td>
          <td class="paramname"> <em>p_asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionpj__sockaddr.htm">pj_sockaddr</a> *&nbsp;</td>
          <td class="paramname"> <em>bound_addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create UDP socket descriptor, bind it to the specified address, and create the active socket for the socket descriptor.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>Pool to allocate memory from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Specifies the address family of the socket and the address where the socket should be bound to. If this argument is NULL, then AF_INET is assumed and the socket will be bound to any addresses and port. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opt</em>&nbsp;</td><td>Optional settings. When this setting is not specifed, the default values will be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>Pointer to structure containing application callbacks. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>Arbitrary user data to be associated with this active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_asock</em>&nbsp;</td><td>Pointer to receive the active socket instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bound_addr</em>&nbsp;</td><td>If this argument is specified, it will be filled with the bound address on return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gac5a45c643541dbdd6d74a633fb28207d"></a><!-- doxytag: member="activesock.h::pj_activesock_get_user_data" ref="gac5a45c643541dbdd6d74a633fb28207d" args="(pj_activesock_t *asock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pj_activesock_get_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>asock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the user data previously associated with this active socket.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The user data. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa1bc3760aa6b278e8ace0841a0fd7f5"></a><!-- doxytag: member="activesock.h::pj_activesock_send" ref="gaaa1bc3760aa6b278e8ace0841a0fd7f5" args="(pj_activesock_t *asock, pj_ioqueue_op_key_t *send_key, const void *data, pj_ssize_t *size, unsigned flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>send_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send data using the socket.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structsend__key.htm">send_key</a></em>&nbsp;</td><td>The operation key to send the data, which is useful if application wants to submit multiple pending send operations and want to track which exact data has been sent in the <em>on_data_sent()</em> callback. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The data to be sent. This data must remain valid until the data has been sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to be given to <a class="el" href="group__PJ__IOQUEUE.htm#gabf96d153949aeda0e7b9dbb742ffcda7">pj_ioqueue_send()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if data has been sent immediately, or PJ_EPENDING if data cannot be sent immediately. In this case the <em>on_data_sent()</em> callback will be called when data is actually sent. Any other return value indicates error condition. </dd></dl>

</div>
</div>
<a class="anchor" id="ga39e1466848c1d13642a65f063423ae44"></a><!-- doxytag: member="activesock.h::pj_activesock_sendto" ref="ga39e1466848c1d13642a65f063423ae44" args="(pj_activesock_t *asock, pj_ioqueue_op_key_t *send_key, const void *data, pj_ssize_t *size, unsigned flags, const pj_sockaddr_t *addr, int addr_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_sendto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *&nbsp;</td>
          <td class="paramname"> <em>send_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>addr_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send datagram using the socket.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structsend__key.htm">send_key</a></em>&nbsp;</td><td>The operation key to send the data, which is useful if application wants to submit multiple pending send operations and want to track which exact data has been sent in the <em>on_data_sent()</em> callback. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The data to be sent. This data must remain valid until the data has been sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to be given to <a class="el" href="group__PJ__IOQUEUE.htm#gabf96d153949aeda0e7b9dbb742ffcda7">pj_ioqueue_send()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The destination address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr_len</em>&nbsp;</td><td>The length of the address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if data has been sent immediately, or PJ_EPENDING if data cannot be sent immediately. In this case the <em>on_data_sent()</em> callback will be called when data is actually sent. Any other return value indicates error condition. </dd></dl>

</div>
</div>
<a class="anchor" id="ga35500827f3657a40c07a62e2fd423917"></a><!-- doxytag: member="activesock.h::pj_activesock_set_user_data" ref="ga35500827f3657a40c07a62e2fd423917" args="(pj_activesock_t *asock, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_set_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associate arbitrary data with the active socket. Application may inspect this data in the callbacks and associate it with higher level processing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>The user data to be associated with the active socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea8588339a3981d944a8cf14847f1140"></a><!-- doxytag: member="activesock.h::pj_activesock_start_accept" ref="gaea8588339a3981d944a8cf14847f1140" args="(pj_activesock_t *asock, pj_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_start_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts asynchronous socket accept() operations on this active socket. Application must bind the socket before calling this function. This function will issue <em>async_cnt</em> number of asynchronous <em>accept()</em> operations to the socket and returns back to caller. Incoming connection on the socket will be reported back to application via the <em>on_accept_complete()</em> callback.</p>
<p>Application only needs to call this function once to initiate accept() operations. Further accept() operations will be done automatically by the active socket when <em>on_accept_complete()</em> callback returns non-zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>Pool used to allocate some internal data for the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85245f4b7bfd186a2e2f28611a343133"></a><!-- doxytag: member="activesock.h::pj_activesock_start_connect" ref="ga85245f4b7bfd186a2e2f28611a343133" args="(pj_activesock_t *asock, pj_pool_t *pool, const pj_sockaddr_t *remaddr, int addr_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_start_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>remaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>addr_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts asynchronous socket connect() operation for this socket. Once the connection is done (either successfully or not), the <em>on_connect_complete()</em> callback will be called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The pool to allocate some internal data for the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>remaddr</em>&nbsp;</td><td>Remote address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr_len</em>&nbsp;</td><td>Length of the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if connection can be established immediately, or PJ_EPENDING if connection cannot be established immediately. In this case the <em>on_connect_complete()</em> callback will be called when connection is complete. Any other return value indicates error condition. </dd></dl>

</div>
</div>
<a class="anchor" id="gaff5faf21c01d9a606aa014a2f2791183"></a><!-- doxytag: member="activesock.h::pj_activesock_start_read" ref="gaff5faf21c01d9a606aa014a2f2791183" args="(pj_activesock_t *asock, pj_pool_t *pool, unsigned buff_size, pj_uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_start_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>buff_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts read operation on this active socket. This function will create <em>async_cnt</em> number of buffers (the <em>async_cnt</em> parameter was given in <em><a class="el" href="group__PJ__ACTIVESOCK.htm#gaad8adb25f996f1ae75a2b1e98e15e584">pj_activesock_create()</a></em> function) where each buffer is <em>buff_size</em> long. The buffers are allocated from the specified <em>pool</em>. Once the buffers are created, it then issues <em>async_cnt</em> number of asynchronous <em>recv()</em> operations to the socket and returns back to caller. Incoming data on the socket will be reported back to application via the <em>on_data_read()</em> callback.</p>
<p>Application only needs to call this function once to initiate read operations. Further read operations will be done automatically by the active socket when <em>on_data_read()</em> callback returns non-zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>Pool used to allocate buffers for incoming data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buff_size</em>&nbsp;</td><td>The size of each buffer, in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to be given to <a class="el" href="group__PJ__IOQUEUE.htm#ga71e08c6414a6f0cd1c1d2fde267bccbe">pj_ioqueue_recv()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gad392064eddce34de3a4d52a65ce94861"></a><!-- doxytag: member="activesock.h::pj_activesock_start_read2" ref="gad392064eddce34de3a4d52a65ce94861" args="(pj_activesock_t *asock, pj_pool_t *pool, unsigned buff_size, void *readbuf[], pj_uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_start_read2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>buff_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>readbuf</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <a class="el" href="group__PJ__ACTIVESOCK.htm#gaff5faf21c01d9a606aa014a2f2791183">pj_activesock_start_read()</a>, except that the application supplies the buffers for the read operation so that the acive socket does not have to allocate the buffers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>Pool used to allocate buffers for incoming data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buff_size</em>&nbsp;</td><td>The size of each buffer, in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readbuf</em>&nbsp;</td><td>Array of packet buffers, each has buff_size size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to be given to <a class="el" href="group__PJ__IOQUEUE.htm#ga71e08c6414a6f0cd1c1d2fde267bccbe">pj_ioqueue_recv()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga48dbb84c14a6a0f53adcda91d6d8ae1e"></a><!-- doxytag: member="activesock.h::pj_activesock_start_recvfrom" ref="ga48dbb84c14a6a0f53adcda91d6d8ae1e" args="(pj_activesock_t *asock, pj_pool_t *pool, unsigned buff_size, pj_uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_start_recvfrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>buff_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <a class="el" href="group__PJ__ACTIVESOCK.htm#gaff5faf21c01d9a606aa014a2f2791183">pj_activesock_start_read()</a>, except that this function is used only for datagram sockets, and it will trigger <em>on_data_recvfrom()</em> callback instead.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>Pool used to allocate buffers for incoming data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buff_size</em>&nbsp;</td><td>The size of each buffer, in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to be given to <a class="el" href="group__PJ__IOQUEUE.htm#ga374d409596460c721e6c185e4a13f25d">pj_ioqueue_recvfrom()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gad5d12dc84bd0bd35027f104b3edc8437"></a><!-- doxytag: member="activesock.h::pj_activesock_start_recvfrom2" ref="gad5d12dc84bd0bd35027f104b3edc8437" args="(pj_activesock_t *asock, pj_pool_t *pool, unsigned buff_size, void *readbuf[], pj_uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_activesock_start_recvfrom2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>asock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>buff_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>readbuf</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <a class="el" href="group__PJ__ACTIVESOCK.htm#ga48dbb84c14a6a0f53adcda91d6d8ae1e">pj_activesock_start_recvfrom()</a> except that the recvfrom() operation takes the buffer from the argument rather than creating new ones.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>Pool used to allocate buffers for incoming data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buff_size</em>&nbsp;</td><td>The size of each buffer, in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readbuf</em>&nbsp;</td><td>Array of packet buffers, each has buff_size size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to be given to <a class="el" href="group__PJ__IOQUEUE.htm#ga374d409596460c721e6c185e4a13f25d">pj_ioqueue_recvfrom()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
</div>
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
