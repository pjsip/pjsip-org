<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PJLIB Reference: Timer Heap Management. (1.16)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>


<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.htm"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Timer Heap Management.<br/>
<small>
[<a class="el" href="group__PJ__MISC.htm">Miscelaneous</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>The timer scheduling implementation here is based on ACE library's ACE_Timer_Heap, with only little modification to suit our library's style (I even left most of the comments in the original source).  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga79162cac576ae7615e5b690d1e5e4631">pj_timer_id_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga2f6af5c2177565ccae9dcb50733f8c65">pj_timer_heap_callback</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *timer_heap, struct <a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *entry)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#gab14375d4993080837ae1709c74796ca7">pj_timer_heap_mem_size</a> (<a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#gac23ecc3a7d6779be2183149da9a841d5">pj_timer_heap_create</a> (<a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *pool, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> count, <a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> **ht)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga6bdecba93d049eac4ea080246b674ff5">pj_timer_heap_destroy</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#gadf7b50b4eeda50c860b21198b7de1f86">pj_timer_heap_set_lock</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, <a class="el" href="group__PJ__BASIC.htm#ga3dc49084043901d31c7b12e5afc9fb2f">pj_lock_t</a> *lock, <a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> auto_del)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#gae17c68c92defe06ebf9a8b15b129d83b">pj_timer_heap_set_max_timed_out_per_poll</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, unsigned count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga95852c5f154d79368516e0247f66e538">pj_timer_entry_init</a> (<a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *entry, int id, void *user_data, <a class="el" href="group__PJ__TIMER.htm#ga2f6af5c2177565ccae9dcb50733f8c65">pj_timer_heap_callback</a> *cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga70651768f9361e9cda3c1d24fec924f7">pj_timer_heap_schedule</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, <a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *entry, const <a class="el" href="structpj__time__val.htm">pj_time_val</a> *delay)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga522fb9ade28878a32d7c76e4f90f35ee">pj_timer_heap_cancel</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, <a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *entry)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga0d2e2c0a9fad51dc159848aa412c9b1b">pj_timer_heap_count</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga6a76f7b7d14f3b4ae3dc1534ed57b05d">pj_timer_heap_earliest_time</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, <a class="el" href="structpj__time__val.htm">pj_time_val</a> *timeval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__TIMER.htm#ga591fb436503b441ef00e6a4fe2a3117f">pj_timer_heap_poll</a> (<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *ht, <a class="el" href="structpj__time__val.htm">pj_time_val</a> *next_delay)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The timer scheduling implementation here is based on ACE library's ACE_Timer_Heap, with only little modification to suit our library's style (I even left most of the comments in the original source). </p>
<p>To quote the original quote in ACE_Timer_Heap_T class:</p>
<p>This implementation uses a heap-based callout queue of absolute times. Therefore, in the average and worst case, scheduling, canceling, and expiring timers is O(log N) (where N is the total number of timers). In addition, we can also preallocate as many <em>ACE_Timer_Nodes</em> as there are slots in the heap. This allows us to completely remove the need for dynamic memory allocation, which is important for real-time systems.</p>
<p>You can find the fine ACE library at: <a href="http://www.cs.wustl.edu/~schmidt/ACE.html">http://www.cs.wustl.edu/~schmidt/ACE.html</a></p>
<p>ACE is Copyright (C)1993-2006 Douglas C. Schmidt &lt;<a href="mailto:d.schmidt@vanderbilt.edu">d.schmidt@vanderbilt.edu</a>&gt;</p>
<h2><a class="anchor" id="pj_timer_examples_sec"></a>
Examples</h2>
<p>For some examples on how to use the timer heap, please see the link below.</p>
<ul>
<li><a class="el" href="page_pjlib_timer_test.htm">Test: Timer</a> </li>
</ul>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga2f6af5c2177565ccae9dcb50733f8c65"></a><!-- doxytag: member="timer.h::pj_timer_heap_callback" ref="ga2f6af5c2177565ccae9dcb50733f8c65" args="(pj_timer_heap_t *timer_heap, struct pj_timer_entry *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="group__PJ__TIMER.htm#ga2f6af5c2177565ccae9dcb50733f8c65">pj_timer_heap_callback</a>(<a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *timer_heap, struct <a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *entry)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The type of callback function to be called by timer scheduler when a timer has expired.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer_heap</em>&nbsp;</td><td>The timer heap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>Timer entry which timer's has expired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga79162cac576ae7615e5b690d1e5e4631"></a><!-- doxytag: member="timer.h::pj_timer_id_t" ref="ga79162cac576ae7615e5b690d1e5e4631" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="group__PJ__TIMER.htm#ga79162cac576ae7615e5b690d1e5e4631">pj_timer_id_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The type for internal timer ID. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga95852c5f154d79368516e0247f66e538"></a><!-- doxytag: member="timer.h::pj_timer_entry_init" ref="ga95852c5f154d79368516e0247f66e538" args="(pj_timer_entry *entry, int id, void *user_data, pj_timer_heap_callback *cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a>* pj_timer_entry_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__TIMER.htm#ga2f6af5c2177565ccae9dcb50733f8c65">pj_timer_heap_callback</a> *&nbsp;</td>
          <td class="paramname"> <em>cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize a timer entry. Application should call this function at least once before scheduling the entry to the timer heap, to properly initialize the timer entry.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>The timer entry to be initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>Arbitrary ID assigned by the user/owner of this entry. Applications can use this ID to distinguish multiple timer entries that share the same callback and user_data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>User data to be associated with this entry. Applications normally will put the instance of object that owns the timer entry in this field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>Callback function to be called when the timer elapses.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The timer entry itself. </dd></dl>

</div>
</div>
<a class="anchor" id="ga522fb9ade28878a32d7c76e4f90f35ee"></a><!-- doxytag: member="timer.h::pj_timer_heap_cancel" ref="ga522fb9ade28878a32d7c76e4f90f35ee" args="(pj_timer_heap_t *ht, pj_timer_entry *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pj_timer_heap_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel a previously registered timer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>The timer heap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>The entry to be cancelled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of timer cancelled, which should be one if the entry has really been registered, or zero if no timer was cancelled. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d2e2c0a9fad51dc159848aa412c9b1b"></a><!-- doxytag: member="timer.h::pj_timer_heap_count" ref="ga0d2e2c0a9fad51dc159848aa412c9b1b" args="(pj_timer_heap_t *ht)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> pj_timer_heap_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the number of timer entries.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>The timer heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of timer entries. </dd></dl>

</div>
</div>
<a class="anchor" id="gac23ecc3a7d6779be2183149da9a841d5"></a><!-- doxytag: member="timer.h::pj_timer_heap_create" ref="gac23ecc3a7d6779be2183149da9a841d5" args="(pj_pool_t *pool, pj_size_t count, pj_timer_heap_t **ht)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_timer_heap_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> **&nbsp;</td>
          <td class="paramname"> <em>ht</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a timer heap.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The pool where allocations in the timer heap will be allocated. The timer heap will dynamicly allocate more storate from the pool if the number of timer entries registered is more than the size originally requested when calling this function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The maximum number of timer entries to be supported initially. If the application registers more entries during runtime, then the timer heap will resize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>Pointer to receive the created timer heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS, or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6bdecba93d049eac4ea080246b674ff5"></a><!-- doxytag: member="timer.h::pj_timer_heap_destroy" ref="ga6bdecba93d049eac4ea080246b674ff5" args="(pj_timer_heap_t *ht)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_timer_heap_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the timer heap.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>The timer heap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6a76f7b7d14f3b4ae3dc1534ed57b05d"></a><!-- doxytag: member="timer.h::pj_timer_heap_earliest_time" ref="ga6a76f7b7d14f3b4ae3dc1534ed57b05d" args="(pj_timer_heap_t *ht, pj_time_val *timeval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_timer_heap_earliest_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__time__val.htm">pj_time_val</a> *&nbsp;</td>
          <td class="paramname"> <em>timeval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the earliest time registered in the timer heap. The timer heap MUST have at least one timer being scheduled (application should use <a class="el" href="group__PJ__TIMER.htm#ga0d2e2c0a9fad51dc159848aa412c9b1b">pj_timer_heap_count()</a> before calling this function).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>The timer heap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeval</em>&nbsp;</td><td>The time deadline of the earliest timer entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS, or PJ_ENOTFOUND if no entry is scheduled. </dd></dl>

</div>
</div>
<a class="anchor" id="gab14375d4993080837ae1709c74796ca7"></a><!-- doxytag: member="timer.h::pj_timer_heap_mem_size" ref="gab14375d4993080837ae1709c74796ca7" args="(pj_size_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> pj_timer_heap_mem_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate memory size required to create a timer heap.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of timer entries to be supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Memory size requirement in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga591fb436503b441ef00e6a4fe2a3117f"></a><!-- doxytag: member="timer.h::pj_timer_heap_poll" ref="ga591fb436503b441ef00e6a4fe2a3117f" args="(pj_timer_heap_t *ht, pj_time_val *next_delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned pj_timer_heap_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__time__val.htm">pj_time_val</a> *&nbsp;</td>
          <td class="paramname"> <em>next_delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Poll the timer heap, check for expired timers and call the callback for each of the expired timers.</p>
<p>Note: polling the timer heap is not necessary in Symbian. Please see <a class="el" href="group__PJ__SYMBIAN__OS.htm">Symbian OS Specific</a> for more info.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>The timer heap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>next_delay</em>&nbsp;</td><td>If this parameter is not NULL, it will be filled up with the time delay until the next timer elapsed, or PJ_MAXINT32 in the sec part if no entry exist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of timers expired. </dd></dl>

</div>
</div>
<a class="anchor" id="ga70651768f9361e9cda3c1d24fec924f7"></a><!-- doxytag: member="timer.h::pj_timer_heap_schedule" ref="ga70651768f9361e9cda3c1d24fec924f7" args="(pj_timer_heap_t *ht, pj_timer_entry *entry, const pj_time_val *delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_timer_heap_schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__timer__entry.htm">pj_timer_entry</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__time__val.htm">pj_time_val</a> *&nbsp;</td>
          <td class="paramname"> <em>delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Schedule a timer entry which will expire AFTER the specified delay.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>The timer heap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>The entry to be registered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>The interval to expire. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS, or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf7b50b4eeda50c860b21198b7de1f86"></a><!-- doxytag: member="timer.h::pj_timer_heap_set_lock" ref="gadf7b50b4eeda50c860b21198b7de1f86" args="(pj_timer_heap_t *ht, pj_lock_t *lock, pj_bool_t auto_del)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_timer_heap_set_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga3dc49084043901d31c7b12e5afc9fb2f">pj_lock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>auto_del</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set lock object to be used by the timer heap. By default, the timer heap uses dummy synchronization.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>The timer heap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock object to be used for synchronization. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auto_del</em>&nbsp;</td><td>If nonzero, the lock object will be destroyed when the timer heap is destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae17c68c92defe06ebf9a8b15b129d83b"></a><!-- doxytag: member="timer.h::pj_timer_heap_set_max_timed_out_per_poll" ref="gae17c68c92defe06ebf9a8b15b129d83b" args="(pj_timer_heap_t *ht, unsigned count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned pj_timer_heap_set_max_timed_out_per_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set maximum number of timed out entries to process in a single poll.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ht</em>&nbsp;</td><td>The timer heap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The old number. </dd></dl>

</div>
</div>
</div>
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
