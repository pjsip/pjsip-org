<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PJLIB Reference: pj_activesock_cb Struct Reference (1.16)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>


<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.htm"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.htm"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.htm"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.htm"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<h1>pj_activesock_cb Struct Reference<br/>
<small>
[<a class="el" href="group__PJ__ACTIVESOCK.htm">Active socket I/O</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="pj_activesock_cb" --><table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__activesock__cb.htm#af0b64be6f5cc9d0f86ab10b3fa661abc">on_data_read</a> )(<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, void *data, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size, <a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> *remainder)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__activesock__cb.htm#aff10cd7702198590cf47d230ae3220a2">on_data_recvfrom</a> )(<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, void *data, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size, const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *src_addr, int addr_len, <a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__activesock__cb.htm#a90e1eeb50556994335c97d25776ae11b">on_data_sent</a> )(<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structsend__key.htm">send_key</a>, <a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> sent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__activesock__cb.htm#a81908dea56a4c206bdce1b1cb4f07155">on_accept_complete</a> )(<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a> newsock, const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *src_addr, int src_addr_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__activesock__cb.htm#a0f926bf07c838aa32bc1afd1da3a8fb0">on_connect_complete</a> )(<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This structure contains the callbacks to be called by the active socket. </p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a81908dea56a4c206bdce1b1cb4f07155"></a><!-- doxytag: member="pj_activesock_cb::on_accept_complete" ref="a81908dea56a4c206bdce1b1cb4f07155" args=")(pj_activesock_t *asock, pj_sock_t newsock, const pj_sockaddr_t *src_addr, int src_addr_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>(* <a class="el" href="structpj__activesock__cb.htm#a81908dea56a4c206bdce1b1cb4f07155">pj_activesock_cb::on_accept_complete</a>)(<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a> newsock, const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *src_addr, int src_addr_len)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This callback is called when new connection arrives as the result of <a class="el" href="group__PJ__ACTIVESOCK.htm#gaea8588339a3981d944a8cf14847f1140">pj_activesock_start_accept()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newsock</em>&nbsp;</td><td>The new incoming socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_addr</em>&nbsp;</td><td>The source address of the connection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr_len</em>&nbsp;</td><td>Length of the source address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_TRUE if further accept() is desired, and PJ_FALSE when application no longer wants to accept incoming connection. Application may destroy the active socket in the callback and return PJ_FALSE here. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f926bf07c838aa32bc1afd1da3a8fb0"></a><!-- doxytag: member="pj_activesock_cb::on_connect_complete" ref="a0f926bf07c838aa32bc1afd1da3a8fb0" args=")(pj_activesock_t *asock, pj_status_t status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>(* <a class="el" href="structpj__activesock__cb.htm#a0f926bf07c838aa32bc1afd1da3a8fb0">pj_activesock_cb::on_connect_complete</a>)(<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This callback is called when pending connect operation has been completed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>The connection result. If connection has been successfully established, the status will contain PJ_SUCCESS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Application may destroy the active socket in the callback and return PJ_FALSE here. </dd></dl>

</div>
</div>
<a class="anchor" id="af0b64be6f5cc9d0f86ab10b3fa661abc"></a><!-- doxytag: member="pj_activesock_cb::on_data_read" ref="af0b64be6f5cc9d0f86ab10b3fa661abc" args=")(pj_activesock_t *asock, void *data, pj_size_t size, pj_status_t status, pj_size_t *remainder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>(* <a class="el" href="structpj__activesock__cb.htm#af0b64be6f5cc9d0f86ab10b3fa661abc">pj_activesock_cb::on_data_read</a>)(<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, void *data, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size, <a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> *remainder)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This callback is called when a data arrives as the result of <a class="el" href="group__PJ__ACTIVESOCK.htm#gaff5faf21c01d9a606aa014a2f2791183">pj_activesock_start_read()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The buffer containing the new data, if any. If the status argument is non-PJ_SUCCESS, this argument may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The length of data in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>The status of the read operation. This may contain non-PJ_SUCCESS for example when the TCP connection has been closed. In this case, the buffer may contain left over data from previous callback which the application may want to process. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>remainder</em>&nbsp;</td><td>If application wishes to leave some data in the buffer (common for TCP applications), it should move the remainder data to the front part of the buffer and set the remainder length here. The value of this parameter will be ignored for datagram sockets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_TRUE if further read is desired, and PJ_FALSE when application no longer wants to receive data. Application may destroy the active socket in the callback and return PJ_FALSE here. </dd></dl>

</div>
</div>
<a class="anchor" id="aff10cd7702198590cf47d230ae3220a2"></a><!-- doxytag: member="pj_activesock_cb::on_data_recvfrom" ref="aff10cd7702198590cf47d230ae3220a2" args=")(pj_activesock_t *asock, void *data, pj_size_t size, const pj_sockaddr_t *src_addr, int addr_len, pj_status_t status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>(* <a class="el" href="structpj__activesock__cb.htm#aff10cd7702198590cf47d230ae3220a2">pj_activesock_cb::on_data_recvfrom</a>)(<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, void *data, <a class="el" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size, const <a class="el" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *src_addr, int addr_len, <a class="el" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This callback is called when a packet arrives as the result of <a class="el" href="group__PJ__ACTIVESOCK.htm#ga48dbb84c14a6a0f53adcda91d6d8ae1e">pj_activesock_start_recvfrom()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The buffer containing the packet, if any. If the status argument is non-PJ_SUCCESS, this argument will be set to NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The length of packet in the buffer. If the status argument is non-PJ_SUCCESS, this argument will be set to zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_addr</em>&nbsp;</td><td>Source address of the packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr_len</em>&nbsp;</td><td>Length of the source address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>This contains</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_TRUE if further read is desired, and PJ_FALSE when application no longer wants to receive data. Application may destroy the active socket in the callback and return PJ_FALSE here. </dd></dl>

</div>
</div>
<a class="anchor" id="a90e1eeb50556994335c97d25776ae11b"></a><!-- doxytag: member="pj_activesock_cb::on_data_sent" ref="a90e1eeb50556994335c97d25776ae11b" args=")(pj_activesock_t *asock, pj_ioqueue_op_key_t *send_key, pj_ssize_t sent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>(* <a class="el" href="structpj__activesock__cb.htm#a90e1eeb50556994335c97d25776ae11b">pj_activesock_cb::on_data_sent</a>)(<a class="el" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock, <a class="el" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="el" href="structsend__key.htm">send_key</a>, <a class="el" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> sent)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This callback is called when data has been sent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asock</em>&nbsp;</td><td>The active socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structsend__key.htm">send_key</a></em>&nbsp;</td><td>Key associated with the send operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sent</em>&nbsp;</td><td>If value is positive non-zero it indicates the number of data sent. When the value is negative, it contains the error code which can be retrieved by negating the value (i.e. status=-sent).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Application may destroy the active socket in the callback and return PJ_FALSE here. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="activesock_8h_source.htm">activesock.h</a></li>
</ul>
</div>
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
