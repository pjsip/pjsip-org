<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PJLIB-UTIL Reference: DNS Asynchronous/Caching Resolution Engine (1.16)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB-UTIL Reference</p>


<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>DNS Asynchronous/Caching Resolution Engine<br/>
<small>
[<a class="el" href="group__PJ__DNS.htm">DNS and Asynchronous DNS Resolver</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__dns__settings.htm">pj_dns_settings</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__dns__a__record.htm">pj_dns_a_record</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__PJ__DNS__RESOLVER.htm#gaea59bcae9bdf1243a5781950bc253555">pj_dns_async_query</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaea59bcae9bdf1243a5781950bc253555">pj_dns_async_query</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gafb39cf3c67957bd85483e3a584839762">pj_dns_callback</a> (void *<a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__IOQUEUE.htm#gab06c131ab29b37c027f2400bd5be6045">user_data</a>, <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status, <a class="el" href="structpj__dns__parsed__packet.htm">pj_dns_parsed_packet</a> *response)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#ga945f8f7389644180c49661bf717cc98a">pj_dns_settings_default</a> (<a class="el" href="structpj__dns__settings.htm">pj_dns_settings</a> *s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gab57f99267c018234770698793ebb62ba">pj_dns_resolver_create</a> (<a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/structpj__pool__factory.htm">pj_pool_factory</a> *pf, const char *name, unsigned <a class="elRef" doxygen="pjmedia.tag:../../../pjmedia/docs/html/" href="../../../pjmedia/docs/html/structapp__t_1_1options.htm">options</a>, <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *timer, <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *ioqueue, <a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> **p_resolver)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#ga4ab10b4a3331a88237a083e3ef23574f">pj_dns_resolver_set_ns</a> (<a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *resolver, unsigned count, const <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/structpj__str__t.htm">pj_str_t</a> servers[], const <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga47506d8dde1056c5c96d62f0df6ddf28">pj_uint16_t</a> ports[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaac3bab5d35e49e04c4120591a0001029">pj_dns_resolver_get_settings</a> (<a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *resolver, <a class="el" href="structpj__dns__settings.htm">pj_dns_settings</a> *st)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gae3e17b76af70c3721fbb27110f0562bc">pj_dns_resolver_set_settings</a> (<a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *resolver, const <a class="el" href="structpj__dns__settings.htm">pj_dns_settings</a> *st)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaab6e6e531572f05ee0237365d1ec1053">pj_dns_resolver_handle_events</a> (<a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *resolver, const <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/structpj__time__val.htm">pj_time_val</a> *timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#ga3175a76f40333cfd2bc60f01aba706d7">pj_dns_resolver_destroy</a> (<a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *resolver, <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> notify)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#ga3d35a6679ac5636398ac2e46d891c733">pj_dns_resolver_start_query</a> (<a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *resolver, const <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/structpj__str__t.htm">pj_str_t</a> *name, <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a> type, unsigned <a class="elRef" doxygen="pjmedia.tag:../../../pjmedia/docs/html/" href="../../../pjmedia/docs/html/structapp__t_1_1options.htm">options</a>, <a class="el" href="group__PJ__DNS__RESOLVER.htm#gafb39cf3c67957bd85483e3a584839762">pj_dns_callback</a> *cb, void *<a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__IOQUEUE.htm#gab06c131ab29b37c027f2400bd5be6045">user_data</a>, <a class="el" href="group__PJ__DNS__RESOLVER.htm#gaea59bcae9bdf1243a5781950bc253555">pj_dns_async_query</a> **p_query)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gae72ed8b9fd69aa4a8fe2c5a70725cc87">pj_dns_resolver_cancel_query</a> (<a class="el" href="group__PJ__DNS__RESOLVER.htm#gaea59bcae9bdf1243a5781950bc253555">pj_dns_async_query</a> *query, <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> notify)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gae582cb1000ba91312866011b7ec50a3f">pj_dns_parse_a_response</a> (const <a class="el" href="structpj__dns__parsed__packet.htm">pj_dns_parsed_packet</a> *pkt, <a class="el" href="structpj__dns__a__record.htm">pj_dns_a_record</a> *rec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa9c045e5acf6d0edd9b9555141eadd78">pj_dns_resolver_add_entry</a> (<a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *resolver, const <a class="el" href="structpj__dns__parsed__packet.htm">pj_dns_parsed_packet</a> *pkt, <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> set_ttl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gae6e7b873345b6b297942002a2eee579a">pj_dns_resolver_get_cached_count</a> (<a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *resolver)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__DNS__RESOLVER.htm#ga33a21c791d8c2a9c6f2d841800cb72ab">pj_dns_resolver_dump</a> (<a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *resolver, <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> detail)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This module manages the host/server resolution by performing asynchronous DNS queries and caching the results in the cache. It uses PJLIB-UTIL low-level DNS parsing functions (see <a class="el" href="group__PJ__DNS.htm">DNS and Asynchronous DNS Resolver</a>) and currently supports several types of DNS resource records such as A record (typical query with gethostbyname()) and SRV record.</p>
<h2><a class="anchor" id="PJ_DNS_RESOLVER_FEATURES"></a>
Features</h2>
<h3><a class="anchor" id="PJ_DNS_RESOLVER_FEATURES_ASYNC"></a>
Asynchronous Query and Query Aggregation</h3>
<p>The DNS queries are performed asychronously, with timeout setting configured on per resolver instance basis. Application can issue multiple asynchronous queries simultaneously. Subsequent queries to the same resource (name and DNS resource type) while existing query is still pending will be merged into one query, so that only one DNS request packet is issued.</p>
<h3><a class="anchor" id="PJ_DNS_RESOLVER_FEATURES_RETRANSMISSION"></a>
Query Retransmission</h3>
<p>Asynchronous query will be retransmitted if no response is received within the preconfigured time. Once maximum retransmission count is exceeded and no response is received, the query will time out and the callback will be called when error status.</p>
<h3><a class="anchor" id="PJ_DNS_RESOLVER_FEATURES_CACHING"></a>
Response Caching with TTL</h3>
<p>The resolver instance caches the results returned by nameservers, to enhance the performance by minimizing the message round-trip to the server. The TTL of the cached resposne is calculated from minimum TTL value found across all resource record (RR) TTL in the response and further more it can be limited to some preconfigured maximum TTL in the resolver.</p>
<p>Response caching can be disabled by setting the maximum TTL value of the resolver to zero.</p>
<h3><a class="anchor" id="PJ_DNS_RESOLVER_FEATURES_PARALLEL"></a>
Parallel and Backup Name Servers</h3>
<p>When the resolver is configured with multiple nameservers, initially the queries will be issued to multiple name servers simultaneously to probe which servers are not active. Once the probing stage is done, subsequent queries will be directed to only one ACTIVE server which provides the best response time.</p>
<p>Name servers are probed periodically to see which nameservers are active and which are down. This probing is done when a query is sent, thus no timer is needed to maintain this. Also probing will be done in parallel so that there would be no additional delay for the query.</p>
<h3><a class="anchor" id="PJ_DNS_RESOLVER_FEATURES_REC"></a>
Supported Resource Records</h3>
<p>The low-level DNS parsing utility (see <a class="el" href="group__PJ__DNS.htm">DNS and Asynchronous DNS Resolver</a>) supports parsing of the following DNS resource records (RR):</p>
<ul>
<li>DNS A record</li>
<li>DNS SRV record</li>
<li>DNS PTR record</li>
<li>DNS NS record</li>
<li>DNS CNAME record</li>
</ul>
<p>For other types of record, application can parse the raw resource record data (rdata) from the parsed DNS packet (<a class="el" href="structpj__dns__parsed__packet.htm">pj_dns_parsed_packet</a>).</p>
<h2><a class="anchor" id="PJ_DNS_RESOLVER_USING"></a>
Using the Resolver</h2>
<p>To use the resolver, application first creates the resolver instance by calling <a class="el" href="group__PJ__DNS__RESOLVER.htm#gab57f99267c018234770698793ebb62ba">pj_dns_resolver_create()</a>. If application already has its own timer and ioqueue instances, it can instruct the resolver to use these instances so that application does not need to poll the resolver periodically to process events. If application does not specify the timer and ioqueue instance for the resolver, an internal timer and ioqueue will be created by the resolver. And since the resolver does not create it's own thread, application MUST poll the resolver periodically by calling <a class="el" href="group__PJ__DNS__RESOLVER.htm#gaab6e6e531572f05ee0237365d1ec1053">pj_dns_resolver_handle_events()</a> to allow events (network and timer) to be processed.</p>
<p>Next, application MUST configure the nameservers to be used by the resolver, by calling <a class="el" href="group__PJ__DNS__RESOLVER.htm#ga4ab10b4a3331a88237a083e3ef23574f">pj_dns_resolver_set_ns()</a>.</p>
<p>Application performs asynchronous query by submitting the query with <a class="el" href="group__PJ__DNS__RESOLVER.htm#ga3d35a6679ac5636398ac2e46d891c733">pj_dns_resolver_start_query()</a>. Once the query completes (either successfully or times out), the callback will be called.</p>
<p>Application can cancel a pending query by calling <a class="el" href="group__PJ__DNS__RESOLVER.htm#gae72ed8b9fd69aa4a8fe2c5a70725cc87">pj_dns_resolver_cancel_query()</a>.</p>
<p>Resolver must be destroyed by calling <a class="el" href="group__PJ__DNS__RESOLVER.htm#ga3175a76f40333cfd2bc60f01aba706d7">pj_dns_resolver_destroy()</a> to release all resources back to the system.</p>
<h2><a class="anchor" id="PJ_DNS_RESOLVER_LIMITATIONS"></a>
Resolver Limitations</h2>
<p>Current implementation mainly suffers from a growing memory problem, which mainly is caused by the response caching. Although there is only one cache entry per {query, name} combination, these cache entry will never get deleted since there is no timer is created to invalidate these entries. So the more unique names being queried by application, there more enties will be created in the response cache.</p>
<p>Note that a single response entry will occupy about 600-700 bytes of pool memory (the PJ_DNS_RESOLVER_RES_BUF_SIZE value plus internal structure).</p>
<p>Application can work around this problem by doing one of these:</p>
<ul>
<li>disable caching by setting PJ_DNS_RESOLVER_MAX_TTL and PJ_DNS_RESOLVER_INVALID_TTL to zero.</li>
<li>periodically query <a class="el" href="group__PJ__DNS__RESOLVER.htm#gae6e7b873345b6b297942002a2eee579a">pj_dns_resolver_get_cached_count()</a> and destroy- recreate the resolver to recycle the memory used by the resolver.</li>
</ul>
<p>Note that future improvement may solve this problem by introducing expiration timer to the cached entries.</p>
<h2><a class="anchor" id="PJ_DNS_RESOLVER_REFERENCE"></a>
Reference</h2>
<p>The PJLIB-UTIL resolver was built from the information in the following standards:</p>
<ul>
<li><a href="http://www.faqs.org/rfcs/rfc1035.html">RFC 1035: "Domain names - implementation and specification"</a></li>
<li><a href="http://www.faqs.org/rfcs/rfc2782.html">RFC 2782: "A DNS RR for specifying the location of services (DNS SRV)" </a> </li>
</ul>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaea59bcae9bdf1243a5781950bc253555"></a><!-- doxytag: member="resolver.h::pj_dns_async_query" ref="gaea59bcae9bdf1243a5781950bc253555" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__PJ__DNS__RESOLVER.htm#gaea59bcae9bdf1243a5781950bc253555">pj_dns_async_query</a> <a class="el" href="group__PJ__DNS__RESOLVER.htm#gaea59bcae9bdf1243a5781950bc253555">pj_dns_async_query</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opaque data type for asynchronous DNS query object. </p>

</div>
</div>
<a class="anchor" id="gafb39cf3c67957bd85483e3a584839762"></a><!-- doxytag: member="resolver.h::pj_dns_callback" ref="gafb39cf3c67957bd85483e3a584839762" args="(void *user_data, pj_status_t status, pj_dns_parsed_packet *response)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="group__PJ__DNS__RESOLVER.htm#gafb39cf3c67957bd85483e3a584839762">pj_dns_callback</a>(void *<a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__IOQUEUE.htm#gab06c131ab29b37c027f2400bd5be6045">user_data</a>, <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status, <a class="el" href="structpj__dns__parsed__packet.htm">pj_dns_parsed_packet</a> *response)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type of asynchronous callback which will be called when the asynchronous query completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>The user data set by application when creating the asynchronous query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Status of the DNS resolution. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>response</em>&nbsp;</td><td>The response packet received from the server. This argument may be NULL when status is not PJ_SUCCESS. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa120673c1218fc146a1d7bd340e4ed95"></a><!-- doxytag: member="resolver.h::pj_dns_resolver" ref="gaa120673c1218fc146a1d7bd340e4ed95" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> <a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opaque data type for DNS resolver object. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae582cb1000ba91312866011b7ec50a3f"></a><!-- doxytag: member="resolver.h::pj_dns_parse_a_response" ref="gae582cb1000ba91312866011b7ec50a3f" args="(const pj_dns_parsed_packet *pkt, pj_dns_a_record *rec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_dns_parse_a_response </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpj__dns__parsed__packet.htm">pj_dns_parsed_packet</a> *&nbsp;</td>
          <td class="paramname"> <em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__dns__a__record.htm">pj_dns_a_record</a> *&nbsp;</td>
          <td class="paramname"> <em>rec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A utility function to parse a DNS response containing A records into DNS A record.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>The DNS response packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rec</em>&nbsp;</td><td>The structure to be initialized with the parsed DNS A record from the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if response can be parsed successfully. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9c045e5acf6d0edd9b9555141eadd78"></a><!-- doxytag: member="resolver.h::pj_dns_resolver_add_entry" ref="gaa9c045e5acf6d0edd9b9555141eadd78" args="(pj_dns_resolver *resolver, const pj_dns_parsed_packet *pkt, pj_bool_t set_ttl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_dns_resolver_add_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *&nbsp;</td>
          <td class="paramname"> <em>resolver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__dns__parsed__packet.htm">pj_dns_parsed_packet</a> *&nbsp;</td>
          <td class="paramname"> <em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>set_ttl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put the specified DNS packet into DNS cache. This function is mainly used for testing the resolver, however it can also be used to inject entries into the resolver.</p>
<p>The packet MUST contain either answer section or query section so that it can be indexed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resolver</em>&nbsp;</td><td>The resolver instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>DNS packet to be added to the DNS cache. If the packet matches existing entry, it will update the entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>set_ttl</em>&nbsp;</td><td>If the value is PJ_FALSE, the entry will not expire (so use with care). Otherwise cache expiration will be calculated based on the TTL of the answeres.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gae72ed8b9fd69aa4a8fe2c5a70725cc87"></a><!-- doxytag: member="resolver.h::pj_dns_resolver_cancel_query" ref="gae72ed8b9fd69aa4a8fe2c5a70725cc87" args="(pj_dns_async_query *query, pj_bool_t notify)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_dns_resolver_cancel_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaea59bcae9bdf1243a5781950bc253555">pj_dns_async_query</a> *&nbsp;</td>
          <td class="paramname"> <em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>notify</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel a pending query.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>query</em>&nbsp;</td><td>The pending asynchronous query to be cancelled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>notify</em>&nbsp;</td><td>If non-zero, the callback will be called with failure status to notify that the query has been cancelled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error code, </dd></dl>

</div>
</div>
<a class="anchor" id="gab57f99267c018234770698793ebb62ba"></a><!-- doxytag: member="resolver.h::pj_dns_resolver_create" ref="gab57f99267c018234770698793ebb62ba" args="(pj_pool_factory *pf, const char *name, unsigned options, pj_timer_heap_t *timer, pj_ioqueue_t *ioqueue, pj_dns_resolver **p_resolver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_dns_resolver_create </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/structpj__pool__factory.htm">pj_pool_factory</a> *&nbsp;</td>
          <td class="paramname"> <em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gaec8852c90e22c6868c83d44dcbdecb8a">pj_timer_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ioqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> **&nbsp;</td>
          <td class="paramname"> <em>p_resolver</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create DNS resolver instance. After the resolver is created, application MUST configure the nameservers with <a class="el" href="group__PJ__DNS__RESOLVER.htm#ga4ab10b4a3331a88237a083e3ef23574f">pj_dns_resolver_set_ns()</a>.</p>
<p>When creating the resolver, application may specify both timer heap and ioqueue instance, so that it doesn't need to poll the resolver periodically.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>Pool factory where the memory pool will be created from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Optional resolver name to identify the instance in the log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Optional options, must be zero for now. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>Optional timer heap instance to be used by the resolver. If timer heap is not specified, an internal timer will be created, and application would need to poll the resolver periodically. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ioqueue</em>&nbsp;</td><td>Optional I/O Queue instance to be used by the resolver. If ioqueue is not specified, an internal one will be created, and application would need to poll the resolver periodically. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_resolver</em>&nbsp;</td><td>Pointer to receive the resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error code, </dd></dl>

</div>
</div>
<a class="anchor" id="ga3175a76f40333cfd2bc60f01aba706d7"></a><!-- doxytag: member="resolver.h::pj_dns_resolver_destroy" ref="ga3175a76f40333cfd2bc60f01aba706d7" args="(pj_dns_resolver *resolver, pj_bool_t notify)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_dns_resolver_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *&nbsp;</td>
          <td class="paramname"> <em>resolver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>notify</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy DNS resolver instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resolver</em>&nbsp;</td><td>The resolver object to be destryed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>notify</em>&nbsp;</td><td>If non-zero, all pending asynchronous queries will be cancelled and its callback will be called. If FALSE, then no callback will be called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error code, </dd></dl>

</div>
</div>
<a class="anchor" id="ga33a21c791d8c2a9c6f2d841800cb72ab"></a><!-- doxytag: member="resolver.h::pj_dns_resolver_dump" ref="ga33a21c791d8c2a9c6f2d841800cb72ab" args="(pj_dns_resolver *resolver, pj_bool_t detail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_dns_resolver_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *&nbsp;</td>
          <td class="paramname"> <em>resolver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>detail</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dump resolver state to the log.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resolver</em>&nbsp;</td><td>The resolver instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detail</em>&nbsp;</td><td>Will print detailed entries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae6e7b873345b6b297942002a2eee579a"></a><!-- doxytag: member="resolver.h::pj_dns_resolver_get_cached_count" ref="gae6e7b873345b6b297942002a2eee579a" args="(pj_dns_resolver *resolver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned pj_dns_resolver_get_cached_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *&nbsp;</td>
          <td class="paramname"> <em>resolver</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the total number of response in the response cache.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resolver</em>&nbsp;</td><td>The resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current number of entries being stored in the response cache. </dd></dl>

</div>
</div>
<a class="anchor" id="gaac3bab5d35e49e04c4120591a0001029"></a><!-- doxytag: member="resolver.h::pj_dns_resolver_get_settings" ref="gaac3bab5d35e49e04c4120591a0001029" args="(pj_dns_resolver *resolver, pj_dns_settings *st)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_dns_resolver_get_settings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *&nbsp;</td>
          <td class="paramname"> <em>resolver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__dns__settings.htm">pj_dns_settings</a> *&nbsp;</td>
          <td class="paramname"> <em>st</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the resolver current settings.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resolver</em>&nbsp;</td><td>The resolver instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td>Buffer to be filled up with resolver settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The query timeout setting, in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="gaab6e6e531572f05ee0237365d1ec1053"></a><!-- doxytag: member="resolver.h::pj_dns_resolver_handle_events" ref="gaab6e6e531572f05ee0237365d1ec1053" args="(pj_dns_resolver *resolver, const pj_time_val *timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_dns_resolver_handle_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *&nbsp;</td>
          <td class="paramname"> <em>resolver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/structpj__time__val.htm">pj_time_val</a> *&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Poll for events from the resolver. This function MUST be called periodically when the resolver is using it's own timer or ioqueue (in other words, when NULL is specified as either <em>timer</em> or <em>ioqueue</em> argument in <a class="el" href="group__PJ__DNS__RESOLVER.htm#gab57f99267c018234770698793ebb62ba">pj_dns_resolver_create()</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resolver</em>&nbsp;</td><td>The resolver instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Maximum time to wait for event occurence. If this argument is NULL, this function will wait forever until events occur. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ab10b4a3331a88237a083e3ef23574f"></a><!-- doxytag: member="resolver.h::pj_dns_resolver_set_ns" ref="ga4ab10b4a3331a88237a083e3ef23574f" args="(pj_dns_resolver *resolver, unsigned count, const pj_str_t servers[], const pj_uint16_t ports[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_dns_resolver_set_ns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *&nbsp;</td>
          <td class="paramname"> <em>resolver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/structpj__str__t.htm">pj_str_t</a>&nbsp;</td>
          <td class="paramname"> <em>servers</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga47506d8dde1056c5c96d62f0df6ddf28">pj_uint16_t</a>&nbsp;</td>
          <td class="paramname"> <em>ports</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update the name servers for the DNS resolver. The name servers MUST be configured before any resolution can be done. The order of nameservers specifies their priority; the first name server will be tried first before the next in the list.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resolver</em>&nbsp;</td><td>The resolver instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of name servers in the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>servers</em>&nbsp;</td><td>Array of name server IP addresses or hostnames. If hostname is specified, the hostname must be resolvable with <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__pj__addr__resolve.htm#ga7c8264aa7743594d31766679dbae0b88">pj_gethostbyname()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ports</em>&nbsp;</td><td>Optional array of ports. If this argument is NULL, the nameserver will use default port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error code, </dd></dl>

</div>
</div>
<a class="anchor" id="gae3e17b76af70c3721fbb27110f0562bc"></a><!-- doxytag: member="resolver.h::pj_dns_resolver_set_settings" ref="gae3e17b76af70c3721fbb27110f0562bc" args="(pj_dns_resolver *resolver, const pj_dns_settings *st)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_dns_resolver_set_settings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *&nbsp;</td>
          <td class="paramname"> <em>resolver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__dns__settings.htm">pj_dns_settings</a> *&nbsp;</td>
          <td class="paramname"> <em>st</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify the resolver settings. Application should initialize the settings by retrieving current settings first before applying new settings, to ensure that all fields are initialized properly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resolver</em>&nbsp;</td><td>The resolver instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td>The resolver settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error code, </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d35a6679ac5636398ac2e46d891c733"></a><!-- doxytag: member="resolver.h::pj_dns_resolver_start_query" ref="ga3d35a6679ac5636398ac2e46d891c733" args="(pj_dns_resolver *resolver, const pj_str_t *name, int type, unsigned options, pj_dns_callback *cb, void *user_data, pj_dns_async_query **p_query)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pj_dns_resolver_start_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaa120673c1218fc146a1d7bd340e4ed95">pj_dns_resolver</a> *&nbsp;</td>
          <td class="paramname"> <em>resolver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/structpj__str__t.htm">pj_str_t</a> *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__THREAD.htm#gab600dc33a20a0f36550a4538506d020e">int</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gafb39cf3c67957bd85483e3a584839762">pj_dns_callback</a> *&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJ__DNS__RESOLVER.htm#gaea59bcae9bdf1243a5781950bc253555">pj_dns_async_query</a> **&nbsp;</td>
          <td class="paramname"> <em>p_query</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create and start asynchronous DNS query for a single resource. Depending on whether response cache is available, this function will either start an asynchronous DNS query or call the callback immediately.</p>
<p>If response is not available in the cache, an asynchronous query will be started, and callback will be called at some time later when the query completes. If <em>p_query</em> argument is not NULL, it will be filled with the asynchronous query object.</p>
<p>If response is available in the cache, the callback will be called immediately before this function returns. In this case, if <em>p_query</em> argument is not NULL, the value will be set to NULL since no new query is started.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resolver</em>&nbsp;</td><td>The resolver object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to be resolved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of resource (see <a class="el" href="group__PJ__DNS__PARSING.htm#ga4bd9a9b1fc09ba73f58397f1706436a6">pj_dns_type</a> constants). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Optional options, must be zero for now. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>Callback to be called when the query completes, either successfully or with failure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>Arbitrary user data to be associated with the query, and which will be given back in the callback. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_query</em>&nbsp;</td><td>Optional pointer to receive the query object, if one was started. If this pointer is specified, a NULL may be returned if response cache is available immediately.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if either an asynchronous query has been started successfully or response cache is available and the user callback has been called. </dd></dl>

</div>
</div>
<a class="anchor" id="ga945f8f7389644180c49661bf717cc98a"></a><!-- doxytag: member="resolver.h::pj_dns_settings_default" ref="ga945f8f7389644180c49661bf717cc98a" args="(pj_dns_settings *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pj_dns_settings_default </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__dns__settings.htm">pj_dns_settings</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set default values to the DNS settings.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The DNS settings to be initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<p>&nbsp;</p>
<hr><center>
PJLIB-UTIL Open Source, small footprint, and portable asynchronous/caching DNS resolver, text scanner, STUN client, and XML library<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
