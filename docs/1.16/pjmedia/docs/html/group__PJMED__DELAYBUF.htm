<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PJMEDIA Reference: Adaptive Delay Buffer (1.16)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->

	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJMEDIA Reference</p>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.htm"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Adaptive Delay Buffer<br/>
<small>
[<a class="el" href="group__PJMEDIA__FRAME__OP.htm">Audio Manipulation Algorithms</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Adaptive delay buffer with high-quality time-scale modification.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef typedefPJ_BEGIN_DECL <br class="typebreak"/>
struct <a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJMED__DELAYBUF.htm#gaa469ae0e30d6e8bfb17a185af02b868e">pjmedia_delay_buf_flag</a> { <a class="el" href="group__PJMED__DELAYBUF.htm#ggaa469ae0e30d6e8bfb17a185af02b868ea13b6271763d527deb2e42347673cfe99">PJMEDIA_DELAY_BUF_SIMPLE_FIFO</a> =  1
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJMED__DELAYBUF.htm#ga49de54985a852636200acee75972aadc">pjmedia_delay_buf_create</a> (<a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/structpj__pool__t.htm">pj_pool_t</a> *pool, const char *name, unsigned clock_rate, unsigned samples_per_frame, unsigned channel_count, unsigned max_delay, unsigned options, <a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a> **p_b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJMED__DELAYBUF.htm#gab1319329c660bfcc969900883a3395d5">pjmedia_delay_buf_put</a> (<a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a> *b, <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga1bc332ac2d70cd1a23adef144571790f">pj_int16_t</a> frame[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJMED__DELAYBUF.htm#ga8ba6eae2dedac7c65376bb12e8559578">pjmedia_delay_buf_get</a> (<a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a> *b, <a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga1bc332ac2d70cd1a23adef144571790f">pj_int16_t</a> frame[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJMED__DELAYBUF.htm#gad84507a23ed0093401086203fbe59b48">pjmedia_delay_buf_reset</a> (<a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a> *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJMED__DELAYBUF.htm#gae29d68d4df91b8b23dacc798a9157eb3">pjmedia_delay_buf_destroy</a> (<a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a> *b)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This section describes PJMEDIA's implementation of delay buffer. Delay buffer works quite similarly like a fixed jitter buffer, that is it will delay the frame retrieval by some interval so that caller will get continuous frame from the buffer. This can be useful when the put() and get() operations are not evenly interleaved, for example when caller performs burst of put() operations and then followed by burst of get() operations. With using this delay buffer, the buffer will put the burst frames into a buffer so that get() operations will always get a frame from the buffer (assuming that the number of get() and put() are matched).</p>
<p>The buffer is adaptive, that is it continuously learns the optimal delay to be applied to the audio flow at run-time. Once the optimal delay has been learned, the delay buffer will apply this delay to the audio flow, expanding or shrinking the audio samples as necessary when the actual audio samples in the buffer are too low or too high. It does this without distorting the audio quality of the audio, by using <em>PJMED_WSOLA</em>.</p>
<p>The delay buffer is used in <a class="el" href="group__PJMED__SND__PORT.htm">Sound Device Port</a>, <a class="el" href="group__PJMEDIA__SPLITCOMB.htm">Media channel splitter/combiner</a>, and <a class="el" href="group__PJMEDIA__CONF.htm">Conference Bridge</a>. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga46638da255362b224bb9818a2636b55f"></a><!-- doxytag: member="delaybuf.h::pjmedia_delay_buf" ref="ga46638da255362b224bb9818a2636b55f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef typedefPJ_BEGIN_DECL struct <a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a> <a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opaque declaration for delay buffer. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gaa469ae0e30d6e8bfb17a185af02b868e"></a><!-- doxytag: member="delaybuf.h::pjmedia_delay_buf_flag" ref="gaa469ae0e30d6e8bfb17a185af02b868e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PJMED__DELAYBUF.htm#gaa469ae0e30d6e8bfb17a185af02b868e">pjmedia_delay_buf_flag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delay buffer options. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaa469ae0e30d6e8bfb17a185af02b868ea13b6271763d527deb2e42347673cfe99"></a><!-- doxytag: member="PJMEDIA_DELAY_BUF_SIMPLE_FIFO" ref="ggaa469ae0e30d6e8bfb17a185af02b868ea13b6271763d527deb2e42347673cfe99" args="" -->PJMEDIA_DELAY_BUF_SIMPLE_FIFO</em>&nbsp;</td><td>
<p>Use simple FIFO mechanism for the delay buffer, i.e. without WSOLA for expanding and shrinking audio samples. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga49de54985a852636200acee75972aadc"></a><!-- doxytag: member="delaybuf.h::pjmedia_delay_buf_create" ref="ga49de54985a852636200acee75972aadc" args="(pj_pool_t *pool, const char *name, unsigned clock_rate, unsigned samples_per_frame, unsigned channel_count, unsigned max_delay, unsigned options, pjmedia_delay_buf **p_b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pjmedia_delay_buf_create </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/structpj__pool__t.htm">pj_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>clock_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>samples_per_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>channel_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>max_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a> **&nbsp;</td>
          <td class="paramname"> <em>p_b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create the delay buffer. Once the delay buffer is created, it will enter learning state unless the delay argument is specified, which in this case it will directly enter the running state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>Pool where the delay buffer will be allocated from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Optional name for the buffer for log identification. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clock_rate</em>&nbsp;</td><td>Number of samples processed per second. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>samples_per_frame</em>&nbsp;</td><td>Number of samples per frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel_count</em>&nbsp;</td><td>Number of channel per frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_delay</em>&nbsp;</td><td>Maximum number of delay to be accommodated, in ms, if this value is negative or less than one frame time, default maximum delay used is 400 ms. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Options. If PJMEDIA_DELAY_BUF_SIMPLE_FIFO is specified, then a simple FIFO mechanism will be used instead of the adaptive implementation (which uses WSOLA to expand or shrink audio samples). See <a class="el" href="group__PJMED__DELAYBUF.htm#gaa469ae0e30d6e8bfb17a185af02b868e">pjmedia_delay_buf_flag</a> for other options. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_b</em>&nbsp;</td><td>Pointer to receive the delay buffer instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the delay buffer has been created successfully, otherwise the appropriate error will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1319329c660bfcc969900883a3395d5"></a><!-- doxytag: member="delaybuf.h::pjmedia_delay_buf_put" ref="gab1319329c660bfcc969900883a3395d5" args="(pjmedia_delay_buf *b, pj_int16_t frame[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pjmedia_delay_buf_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga1bc332ac2d70cd1a23adef144571790f">pj_int16_t</a>&nbsp;</td>
          <td class="paramname"> <em>frame</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put one frame into the buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The delay buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame</em>&nbsp;</td><td>Frame to be put into the buffer. This frame must have samples_per_frame length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if frames can be put successfully. PJ_EPENDING if the buffer is still at learning state. PJ_ETOOMANY if the number of frames will exceed maximum delay level, which in this case the new frame will overwrite the oldest frame in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ba6eae2dedac7c65376bb12e8559578"></a><!-- doxytag: member="delaybuf.h::pjmedia_delay_buf_get" ref="ga8ba6eae2dedac7c65376bb12e8559578" args="(pjmedia_delay_buf *b, pj_int16_t frame[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pjmedia_delay_buf_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#ga1bc332ac2d70cd1a23adef144571790f">pj_int16_t</a>&nbsp;</td>
          <td class="paramname"> <em>frame</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get one frame from the buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The delay buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame</em>&nbsp;</td><td>Buffer to receive the frame from the delay buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if frame has been copied successfully. PJ_EPENDING if no frame is available, either because the buffer is still at learning state or no buffer is available during running state. On non-successful return, the frame will be filled with zeroes. </dd></dl>

</div>
</div>
<a class="anchor" id="gad84507a23ed0093401086203fbe59b48"></a><!-- doxytag: member="delaybuf.h::pjmedia_delay_buf_reset" ref="gad84507a23ed0093401086203fbe59b48" args="(pjmedia_delay_buf *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pjmedia_delay_buf_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset delay buffer. This will clear the buffer's content. But keep the learning result.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The delay buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success or the appropriate error. </dd></dl>

</div>
</div>
<a class="anchor" id="gae29d68d4df91b8b23dacc798a9157eb3"></a><!-- doxytag: member="delaybuf.h::pjmedia_delay_buf_destroy" ref="gae29d68d4df91b8b23dacc798a9157eb3" args="(pjmedia_delay_buf *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="pjlib.tag:../../../pjlib/docs/html/" href="../../../pjlib/docs/html/group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> pjmedia_delay_buf_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJMED__DELAYBUF.htm#ga46638da255362b224bb9818a2636b55f">pjmedia_delay_buf</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy delay buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Delay buffer session.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS normally. </dd></dl>

</div>
</div>
</div>
<p>&nbsp;</p>
<hr><center>
PJMEDIA small footprint Open Source media stack<br>
Copyright (C) 2006-2008 Teluu Inc.
</center>
<!--#include virtual="/footer.html" -->
</BODY>
</HTML>
