<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Fast Memory Pool (2.12)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">Fast Memory Pool</div>  </div>
</div><!--header-->
<div class="contents">

<p>Memory pools allow dynamic memory allocation comparable to malloc or the new in operator C++. Those implementations are not desirable for very high performance applications or real-time systems, because of the performance bottlenecks and it suffers from fragmentation issue.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__PJ__POOL"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL.htm">Memory Pool Object</a></td></tr>
<tr class="memdesc:group__PJ__POOL"><td class="mdescLeft">&#160;</td><td class="mdescRight">The memory pool is an opaque object created by pool factory. Application uses this object to request a memory chunk, by calling <a class="el" href="group__PJ__POOL.htm#ga865b3702766960869d1c58429e213cf4">pj_pool_alloc()</a>, <a class="el" href="group__PJ__POOL.htm#gadbfad2994a9bf4a86ce81f5726d4502c">pj_pool_calloc()</a>, or <a class="el" href="group__PJ__POOL.htm#ga4ecb4c956f18e49b20308ffd075b0b40">pj_pool_zalloc()</a>. When the application has finished using the pool, it must call <a class="el" href="group__PJ__POOL.htm#gade0f14f6635ecfccb576ec41c57fede5">pj_pool_release()</a> to free all the chunks previously allocated and release the pool back to the factory. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__PJ__POOL__FACTORY"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__FACTORY.htm">Pool Factory and Policy</a></td></tr>
<tr class="memdesc:group__PJ__POOL__FACTORY"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool object must be created through a factory. A factory not only provides generic interface functions to create and release pool, but also provides strategy to manage the life time of pools. One sample implementation, <em><a class="el" href="structpj__caching__pool.htm">pj_caching_pool</a></em>, can be set to keep the pools released by application for future use as long as the total memory is below the limit. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__PJ__CACHING__POOL"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__CACHING__POOL.htm">Caching Pool Factory</a></td></tr>
<tr class="memdesc:group__PJ__CACHING__POOL"><td class="mdescLeft">&#160;</td><td class="mdescRight">Caching pool is one sample implementation of pool factory where the factory can reuse memory to create a pool. Application defines what the maximum memory the factory can hold, and when a pool is released the factory decides whether to destroy the pool or to keep it for future use. If the total amount of memory in the internal cache is still within the limit, the factory will keep the pool in the internal cache, otherwise the pool will be destroyed, thus releasing the memory back to the system. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__PJ__POOL__BUFFER"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJ__POOL__BUFFER.htm">Stack/Buffer Based Memory Pool Allocator</a></td></tr>
<tr class="memdesc:group__PJ__POOL__BUFFER"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack/buffer based pool. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Memory pools allow dynamic memory allocation comparable to malloc or the new in operator C++. Those implementations are not desirable for very high performance applications or real-time systems, because of the performance bottlenecks and it suffers from fragmentation issue. </p>
<h1><a class="anchor" id="PJ_POOL_INTRO_SEC"></a>
PJLIB's Memory Pool</h1>
<h2><a class="anchor" id="PJ_POOL_ADVANTAGE_SUBSEC"></a>
Advantages</h2>
<p>PJLIB's pool has many advantages over traditional malloc/new operator and over other memory pool implementations, because:</p><ul>
<li>unlike other memory pool implementation, it allows allocation of memory chunks of different sizes,</li>
<li>it's very very fast. <br />
 Memory chunk allocation is not only an O(1) operation, but it's also very simple (just few pointer arithmetic operations) and it doesn't require locking any mutex,</li>
<li>it's memory efficient. <br />
 Pool doesn't keep track individual memory chunks allocated by applications, so there is no additional overhead needed for each memory allocation (other than possible additional of few bytes, up to PJ_POOL_ALIGNMENT-1, for aligning the memory). But see the <a class="el" href="group__PJ__POOL__GROUP.htm#PJ_POOL_CAVEATS_SUBSEC">Caveats</a> below.</li>
<li>it prevents memory leaks. <br />
 Memory pool inherently has garbage collection functionality. In fact, there is no need to free the chunks allocated from the memory pool. All chunks previously allocated from the pool will be freed once the pool itself is destroyed. This would prevent memory leaks that haunt programmers for decades, and it provides additional performance advantage over traditional malloc/new operator.</li>
</ul>
<p>Even more, PJLIB's memory pool provides some additional usability and flexibility for applications:</p><ul>
<li>memory leaks are easily traceable, since memory pool is assigned name, and application can inspect what pools currently active in the system.</li>
<li>by design, memory allocation from a pool is not thread safe. We assumed that a pool will be owned by a higher level object, and thread safety should be handled by that object. This enables very fast pool operations and prevents unnecessary locking operations,</li>
<li>by default, the memory pool API behaves more like C++ new operator, in that it will throw PJ_NO_MEMORY_EXCEPTION exception (see <a class="el" href="group__PJ__EXCEPT.htm">Exception Handling</a>) when memory chunk allocation fails. This enables failure handling to be done on more high level function (instead of checking the result of <a class="el" href="group__PJ__POOL.htm#ga865b3702766960869d1c58429e213cf4">pj_pool_alloc()</a> everytime). If application doesn't like this, the default behavior can be changed on global basis by supplying different policy to the pool factory.</li>
<li>any memory allocation backend allocator/deallocator may be used. By default, the policy uses malloc() and free() to manage the pool's block, but application may use different strategy, for example to allocate memory blocks from a globally static memory location.</li>
</ul>
<h2><a class="anchor" id="PJ_POOL_PERFORMANCE_SUBSEC"></a>
Performance</h2>
<p>The result of PJLIB's memory design and careful implementation is a memory allocation strategy that can speed-up the memory allocations and deallocations by up to <b>30 times</b> compared to standard malloc()/free() (more than 150 million allocations per second on a P4/3.0GHz Linux machine).</p>
<p>(Note: your mileage may vary, of course. You can see how much PJLIB's pool improves the performance over malloc()/free() in your target system by running pjlib-test application).</p>
<h2><a class="anchor" id="PJ_POOL_CAVEATS_SUBSEC"></a>
Caveats</h2>
<p>There are some caveats though!</p>
<p>When creating pool, PJLIB requires applications to specify the initial pool size, and as soon as the pool is created, PJLIB allocates memory from the system by that size. Application designers MUST choose the initial pool size carefully, since choosing too big value will result in wasting system's memory.</p>
<p>But the pool can grow. Application designer can specify how the pool will grow in size, by specifying the size increment when creating the pool.</p>
<p>The pool, however, <b>cannot</b> shrink! Since there is <b>no</b> function to deallocate memory chunks, there is no way for the pool to release back unused memory to the system. Application designers must be aware that constant memory allocations from pool that has infinite life-time may cause the memory usage of the application to grow over time.</p>
<h1><a class="anchor" id="PJ_POOL_USING_SEC"></a>
Using Memory Pool</h1>
<p>This section describes how to use PJLIB's memory pool framework. As we hope the readers will witness, PJLIB's memory pool API is quite straightforward.</p>
<h2><a class="anchor" id="PJ_POOL_USING_F"></a>
Create Pool Factory</h2>
<p>First, application needs to initialize a pool factory (this normally only needs to be done once in one application). PJLIB provides a pool factory implementation called caching pool (see <a class="el" href="group__PJ__CACHING__POOL.htm">Caching Pool Factory</a>), and it is initialized by calling <a class="el" href="group__PJ__CACHING__POOL.htm#gafbf5400f191e2095240bc6472754e94f">pj_caching_pool_init()</a>.</p>
<h2><a class="anchor" id="PJ_POOL_USING_P"></a>
Create The Pool</h2>
<p>Then application creates the pool object itself with <a class="el" href="group__PJ__POOL.htm#gaf58c3ba26a1314c0e0be103960ba4a5e">pj_pool_create()</a>, specifying among other thing the pool factory where the pool should be created from, the pool name, initial size, and increment/expansion size.</p>
<h2><a class="anchor" id="PJ_POOL_USING_M"></a>
Allocate Memory as Required</h2>
<p>Then whenever application needs to allocate dynamic memory, it would call <a class="el" href="group__PJ__POOL.htm#ga865b3702766960869d1c58429e213cf4">pj_pool_alloc()</a>, <a class="el" href="group__PJ__POOL.htm#gadbfad2994a9bf4a86ce81f5726d4502c">pj_pool_calloc()</a>, or <a class="el" href="group__PJ__POOL.htm#ga4ecb4c956f18e49b20308ffd075b0b40">pj_pool_zalloc()</a> to allocate memory chunks from the pool.</p>
<h2><a class="anchor" id="PJ_POOL_USING_DP"></a>
Destroy the Pool</h2>
<p>When application has finished with the pool, it should call <a class="el" href="group__PJ__POOL.htm#gade0f14f6635ecfccb576ec41c57fede5">pj_pool_release()</a> to release the pool object back to the factory. Depending on the types of the factory, this may release the memory back to the operating system.</p>
<h2><a class="anchor" id="PJ_POOL_USING_Dc"></a>
Destroy the Pool Factory</h2>
<p>And finally, before application quites, it should deinitialize the pool factory, to make sure that all memory blocks allocated by the factory are released back to the operating system. After this, of course no more memory pool allocation can be requested.</p>
<h2><a class="anchor" id="PJ_POOL_USING_EX"></a>
Example</h2>
<p>Below is a sample complete program that utilizes PJLIB's memory pool.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;pjlib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define THIS_FILE    &quot;pool_sample.c&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> my_perror(<span class="keyword">const</span> <span class="keywordtype">char</span> *title, <a class="code" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status)</div><div class="line">{</div><div class="line">     <a class="code" href="group__pj__errno.htm#gacb73514c3158bdeda93488e8624e7b42">PJ_PERROR</a>(1,(THIS_FILE, status, title));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> pool_demo_1(<a class="code" href="structpj__pool__factory.htm">pj_pool_factory</a> *pfactory)</div><div class="line">{</div><div class="line">     <span class="keywordtype">unsigned</span> i;</div><div class="line">     <a class="code" href="structpj__pool__t.htm">pj_pool_t</a> *pool;</div><div class="line"></div><div class="line">     <span class="comment">// Must create pool before we can allocate anything</span></div><div class="line">     pool = <a class="code" href="group__PJ__POOL.htm#gaf58c3ba26a1314c0e0be103960ba4a5e">pj_pool_create</a>(pfactory,     <span class="comment">// the factory</span></div><div class="line">                      <span class="stringliteral">&quot;pool1&quot;</span>,   <span class="comment">// pool&#39;s name</span></div><div class="line">                      4000,      <span class="comment">// initial size</span></div><div class="line">                      4000,      <span class="comment">// increment size</span></div><div class="line">                      NULL);     <span class="comment">// use default callback.</span></div><div class="line">     <span class="keywordflow">if</span> (pool == NULL) {</div><div class="line">         my_perror(<span class="stringliteral">&quot;Error creating pool&quot;</span>, <a class="code" href="group__pj__errnum.htm#ga9a16214b8d54a8ee9d6bce378d116beb">PJ_ENOMEM</a>);</div><div class="line">         <span class="keywordflow">return</span>;</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="comment">// Demo: allocate some memory chunks</span></div><div class="line">     <span class="keywordflow">for</span> (i=0; i&lt;1000; ++i) {</div><div class="line">         <span class="keywordtype">void</span> *p;</div><div class="line"></div><div class="line">         p = <a class="code" href="group__PJ__POOL.htm#ga865b3702766960869d1c58429e213cf4">pj_pool_alloc</a>(pool, (<a class="code" href="group__PJ__RAND.htm#ga654f8cb013a1312b87000df1a1d03398">pj_rand</a>()+1) % 512);</div><div class="line"></div><div class="line">         <span class="comment">// Do something with p</span></div><div class="line">         ...</div><div class="line"></div><div class="line">         <span class="comment">// Look! No need to free p!!</span></div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="comment">// Done with silly demo, must free pool to release all memory.</span></div><div class="line">     <a class="code" href="group__PJ__POOL.htm#gade0f14f6635ecfccb576ec41c57fede5">pj_pool_release</a>(pool);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">     <a class="code" href="structpj__caching__pool.htm">pj_caching_pool</a> cp;</div><div class="line">     <a class="code" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status;</div><div class="line"></div><div class="line">     <span class="comment">// Must init PJLIB before anything else</span></div><div class="line">     status = <a class="code" href="group__PJ__BASIC.htm#ga069615152140fa2df009cebc8a36b769">pj_init</a>();</div><div class="line">     <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#gga65c74a186d2c92fe9f088f3e1e8688bea312497101cf4a5d856e77d5302059935">PJ_SUCCESS</a>) {</div><div class="line">         my_perror(<span class="stringliteral">&quot;Error initializing PJLIB&quot;</span>, status);</div><div class="line">         <span class="keywordflow">return</span> 1;</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="comment">// Create the pool factory, in this case, a caching pool,</span></div><div class="line">     <span class="comment">// using default pool policy.</span></div><div class="line">     <a class="code" href="group__PJ__CACHING__POOL.htm#gafbf5400f191e2095240bc6472754e94f">pj_caching_pool_init</a>(&amp;cp, NULL, 1024*1024 );</div><div class="line"></div><div class="line">     <span class="comment">// Do a demo</span></div><div class="line">     pool_demo_1(&amp;cp.<a class="code" href="structpj__caching__pool.htm#a0849ace123d8760dfab52418c2732af3">factory</a>);</div><div class="line"></div><div class="line">     <span class="comment">// Done with demos, destroy caching pool before exiting app.</span></div><div class="line">     <a class="code" href="group__PJ__CACHING__POOL.htm#ga4c912e7d9e08dae33c2fecea9f1949bc">pj_caching_pool_destroy</a>(&amp;cp);</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>More information about pool factory, the pool object, and caching pool can be found on the Module Links below. </p>
</div><!-- contents -->
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>
<!--#include virtual="/footer.html" -->
</BODY>
</HTML>
