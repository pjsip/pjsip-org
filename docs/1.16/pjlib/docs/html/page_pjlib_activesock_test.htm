<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PJLIB Reference: Test: Active Socket (1.16)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; PJLIB Reference</p>


<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.htm"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Test: Active Socket </h1>  </div>
</div>
<div class="contents">
<p>This file is <b>pjlib-test/activesock.c</b></p>
<div class="fragment"><pre class="fragment"><span class="comment">/* $Id: activesock.c 4387 2013-02-27 10:16:08Z ming $ */</span>
<span class="comment">/* </span>
<span class="comment"> * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)</span>
<span class="comment"> * Copyright (C) 2003-2008 Benny Prijono &lt;benny@prijono.org&gt;</span>
<span class="comment"> *</span>
<span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="comment"> * (at your option) any later version.</span>
<span class="comment"> *</span>
<span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="comment"> * GNU General Public License for more details.</span>
<span class="comment"> *</span>
<span class="comment"> * You should have received a copy of the GNU General Public License</span>
<span class="comment"> * along with this program; if not, write to the Free Software</span>
<span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA </span>
<span class="comment"> */</span>
<span class="preprocessor">#include &quot;test.h&quot;</span>
<span class="preprocessor">#include &lt;pjlib.h&gt;</span>

<span class="preprocessor">#if INCLUDE_ACTIVESOCK_TEST</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define THIS_FILE   &quot;activesock.c&quot;</span>
<span class="preprocessor"></span>

<span class="comment">/*******************************************************************</span>
<span class="comment"> * Simple UDP echo server.</span>
<span class="comment"> */</span>
<span class="keyword">struct </span><a class="code" href="structudp__echo__srv.htm">udp_echo_srv</a>
{
    <a class="code" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a>     *asock;
    <a class="code" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>            echo_enabled;
    <a class="code" href="group__PJ__BASIC.htm#ga47506d8dde1056c5c96d62f0df6ddf28">pj_uint16_t</a>          port;
    <a class="code" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a>  <a class="code" href="structsend__key.htm">send_key</a>;
    <a class="code" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a>          status;
    <span class="keywordtype">unsigned</span>             rx_cnt;
    <span class="keywordtype">unsigned</span>             rx_err_cnt, tx_err_cnt;
};

<span class="keyword">static</span> <span class="keywordtype">void</span> udp_echo_err(<span class="keyword">const</span> <span class="keywordtype">char</span> *title, <a class="code" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status)
{
    <span class="keywordtype">char</span> errmsg[PJ_ERR_MSG_SIZE];

    <a class="code" href="group__pj__errno.htm#ga7d2616aded0d61924fb31f4fd6ee45c0">pj_strerror</a>(status, errmsg, <span class="keyword">sizeof</span>(errmsg));
    <a class="code" href="group__PJ__LOG.htm#ga767b9231bf7c2b57274771cdc4bca818">PJ_LOG</a>(3,(THIS_FILE, <span class="stringliteral">&quot;   error: %s: %s&quot;</span>, title, errmsg));
}

<span class="keyword">static</span> <a class="code" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> udp_echo_srv_on_data_recvfrom(<a class="code" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock,
                                               <span class="keywordtype">void</span> *data,
                                               <a class="code" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size,
                                               <span class="keyword">const</span> <a class="code" href="group__PJ__BASIC.htm#gab18aea853290263f8563e171cde31514">pj_sockaddr_t</a> *src_addr,
                                               <span class="keywordtype">int</span> addr_len,
                                               <a class="code" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status)
{
    <span class="keyword">struct </span><a class="code" href="structudp__echo__srv.htm">udp_echo_srv</a> *srv;
    <a class="code" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> sent;


    srv = (<span class="keyword">struct </span><a class="code" href="structudp__echo__srv.htm">udp_echo_srv</a>*) <a class="code" href="group__PJ__ACTIVESOCK.htm#gac5a45c643541dbdd6d74a633fb28207d">pj_activesock_get_user_data</a>(asock);

    <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
        srv-&gt;status = status;
        srv-&gt;rx_err_cnt++;
        udp_echo_err(<span class="stringliteral">&quot;recvfrom() callback&quot;</span>, status);
        <span class="keywordflow">return</span> PJ_TRUE;
    }

    srv-&gt;rx_cnt++;

    <span class="comment">/* Send back if echo is enabled */</span>
    <span class="keywordflow">if</span> (srv-&gt;echo_enabled) {
        sent = size;
        srv-&gt;status = <a class="code" href="group__PJ__ACTIVESOCK.htm#ga39e1466848c1d13642a65f063423ae44">pj_activesock_sendto</a>(asock, &amp;srv-&gt;send_key, data, 
                                           &amp;sent, 0,
                                           src_addr, addr_len);
        <span class="keywordflow">if</span> (srv-&gt;status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
            srv-&gt;tx_err_cnt++;
            udp_echo_err(<span class="stringliteral">&quot;sendto()&quot;</span>, status);
        }
    }

    <span class="keywordflow">return</span> PJ_TRUE;
}


<span class="keyword">static</span> <a class="code" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> udp_echo_srv_create(<a class="code" href="structpj__pool__t.htm">pj_pool_t</a> *pool,
                                       <a class="code" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *ioqueue,
                                       <a class="code" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> enable_echo,
                                       <span class="keyword">struct</span> <a class="code" href="structudp__echo__srv.htm">udp_echo_srv</a> **p_srv)
{
    <span class="keyword">struct </span><a class="code" href="structudp__echo__srv.htm">udp_echo_srv</a> *srv;
    <a class="code" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a> sock_fd = PJ_INVALID_SOCKET;
    <a class="code" href="unionpj__sockaddr.htm">pj_sockaddr</a> addr;
    <span class="keywordtype">int</span> addr_len;
    <a class="code" href="structpj__activesock__cb.htm">pj_activesock_cb</a> activesock_cb;
    <a class="code" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status;

    srv = <a class="code" href="group__PJ__POOL.htm#ga405d1dbb6728b1d1bd90ddadb9342b27">PJ_POOL_ZALLOC_T</a>(pool, <span class="keyword">struct</span> <a class="code" href="structudp__echo__srv.htm">udp_echo_srv</a>);
    srv-&gt;echo_enabled = enable_echo;

    <a class="code" href="group__PJ__SOCK.htm#gae6169f27eb956287681a46ca9fecdafc">pj_sockaddr_in_init</a>(&amp;addr.<a class="code" href="unionpj__sockaddr.htm#ab25ec448ae63acfdd2aa0f3ef2fd10b8">ipv4</a>, NULL, 0);
    addr_len = <span class="keyword">sizeof</span>(addr);

    <a class="code" href="group__PJ__PSTR.htm#gafa92001573289c87313c660146369fa3">pj_bzero</a>(&amp;activesock_cb, <span class="keyword">sizeof</span>(activesock_cb));
    activesock_cb.<a class="code" href="structpj__activesock__cb.htm#aff10cd7702198590cf47d230ae3220a2">on_data_recvfrom</a> = &amp;udp_echo_srv_on_data_recvfrom;

    status = <a class="code" href="group__PJ__ACTIVESOCK.htm#gafff5c0d4bb59a5085d2215b7530ace68">pj_activesock_create_udp</a>(pool, &amp;addr, NULL, ioqueue, &amp;activesock_cb, 
                                      srv, &amp;srv-&gt;asock, &amp;addr);
    <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
        <a class="code" href="group__PJ__SOCK.htm#ga2f8faea76a64620b13a720227df927bb">pj_sock_close</a>(sock_fd);
        udp_echo_err(<span class="stringliteral">&quot;pj_activesock_create()&quot;</span>, status);
        <span class="keywordflow">return</span> status;
    }

    srv-&gt;port = <a class="code" href="group__PJ__SOCK.htm#ga879824dfc39cf8897aa2607e086ec013">pj_ntohs</a>(addr.<a class="code" href="unionpj__sockaddr.htm#ab25ec448ae63acfdd2aa0f3ef2fd10b8">ipv4</a>.<a class="code" href="structpj__sockaddr__in.htm#a0e60b93d03fa052211bb6131e64bdda1">sin_port</a>);

    <a class="code" href="group__PJ__IOQUEUE.htm#ga2ef6f3b6077c716793e2b4a488e03fe4">pj_ioqueue_op_key_init</a>(&amp;srv-&gt;send_key, <span class="keyword">sizeof</span>(srv-&gt;send_key));

    status = <a class="code" href="group__PJ__ACTIVESOCK.htm#ga48dbb84c14a6a0f53adcda91d6d8ae1e">pj_activesock_start_recvfrom</a>(srv-&gt;asock, pool, 32, 0);
    <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
        <a class="code" href="group__PJ__ACTIVESOCK.htm#gac8a9253fe6327c82871e92f7e6bcd8d6">pj_activesock_close</a>(srv-&gt;asock);
        udp_echo_err(<span class="stringliteral">&quot;pj_activesock_start_recvfrom()&quot;</span>, status);
        <span class="keywordflow">return</span> status;
    }


    *p_srv = srv;
    <span class="keywordflow">return</span> PJ_SUCCESS;
}

<span class="keyword">static</span> <span class="keywordtype">void</span> udp_echo_srv_destroy(<span class="keyword">struct</span> <a class="code" href="structudp__echo__srv.htm">udp_echo_srv</a> *srv)
{
    <a class="code" href="group__PJ__ACTIVESOCK.htm#gac8a9253fe6327c82871e92f7e6bcd8d6">pj_activesock_close</a>(srv-&gt;asock);
}

<span class="comment">/*******************************************************************</span>
<span class="comment"> * UDP ping pong test (send packet back and forth between two UDP echo</span>
<span class="comment"> * servers.</span>
<span class="comment"> */</span>
<span class="keyword">static</span> <span class="keywordtype">int</span> udp_ping_pong_test(<span class="keywordtype">void</span>)
{
    <a class="code" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *ioqueue = NULL;
    <a class="code" href="structpj__pool__t.htm">pj_pool_t</a> *pool = NULL;
    <span class="keyword">struct </span><a class="code" href="structudp__echo__srv.htm">udp_echo_srv</a> *srv1=NULL, *srv2=NULL;
    <a class="code" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> need_send = PJ_TRUE;
    <span class="keywordtype">unsigned</span> data = 0;
    <span class="keywordtype">int</span> count, ret;
    <a class="code" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status;

    pool = <a class="code" href="group__PJ__POOL.htm#gaf58c3ba26a1314c0e0be103960ba4a5e">pj_pool_create</a>(mem, <span class="stringliteral">&quot;pingpong&quot;</span>, 512, 512, NULL);
    <span class="keywordflow">if</span> (!pool)
        <span class="keywordflow">return</span> -10;

    status = <a class="code" href="group__PJ__IOQUEUE.htm#gaae188673e57ae841d586a738e53cffc5">pj_ioqueue_create</a>(pool, 4, &amp;ioqueue);
    <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
        ret = -20;
        udp_echo_err(<span class="stringliteral">&quot;pj_ioqueue_create()&quot;</span>, status);
        <span class="keywordflow">goto</span> on_return;
    }

    status = udp_echo_srv_create(pool, ioqueue, <a class="code" href="group__PJ__BASIC.htm#gac8d6a18466c2489aae935c44f15edb5b">PJ_TRUE</a>, &amp;srv1);
    <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
        ret = -30;
        <span class="keywordflow">goto</span> on_return;
    }

    status = udp_echo_srv_create(pool, ioqueue, <a class="code" href="group__PJ__BASIC.htm#gac8d6a18466c2489aae935c44f15edb5b">PJ_TRUE</a>, &amp;srv2);
    <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
        ret = -40;
        <span class="keywordflow">goto</span> on_return;
    }

    <span class="comment">/* initiate the first send */</span>
    <span class="keywordflow">for</span> (count=0; count&lt;1000; ++count) {
        <span class="keywordtype">unsigned</span> last_rx1, last_rx2;
        <span class="keywordtype">unsigned</span> i;

        <span class="keywordflow">if</span> (need_send) {
            <a class="code" href="structpj__str__t.htm">pj_str_t</a> loopback;
            <a class="code" href="structpj__sockaddr__in.htm">pj_sockaddr_in</a> addr;
            <a class="code" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> sent;

            ++data;

            sent = <span class="keyword">sizeof</span>(data);
            loopback = <a class="code" href="group__PJ__PSTR.htm#ga20fa0c4d9ccddd0822a775730cf4a867">pj_str</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>);
            <a class="code" href="group__PJ__SOCK.htm#gae6169f27eb956287681a46ca9fecdafc">pj_sockaddr_in_init</a>(&amp;addr, &amp;loopback, srv2-&gt;port);
            status = <a class="code" href="group__PJ__ACTIVESOCK.htm#ga39e1466848c1d13642a65f063423ae44">pj_activesock_sendto</a>(srv1-&gt;asock, &amp;srv1-&gt;send_key,
                                          &amp;data, &amp;sent, 0,
                                          &amp;addr, <span class="keyword">sizeof</span>(addr));
            <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a> &amp;&amp; status != <a class="code" href="group__pj__errnum.htm#ga8706796879339b5dc875e2af631d6fe7">PJ_EPENDING</a>) {
                ret = -50;
                udp_echo_err(<span class="stringliteral">&quot;sendto()&quot;</span>, status);
                <span class="keywordflow">goto</span> on_return;
            }

            need_send = PJ_FALSE;
        }

        last_rx1 = srv1-&gt;rx_cnt;
        last_rx2 = srv2-&gt;rx_cnt;

        <span class="keywordflow">for</span> (i=0; i&lt;10 &amp;&amp; last_rx1 == srv1-&gt;rx_cnt &amp;&amp; last_rx2 == srv2-&gt;rx_cnt; ++i) {
            <a class="code" href="structpj__time__val.htm">pj_time_val</a> delay = {0, 10};
<span class="preprocessor">#ifdef PJ_SYMBIAN</span>
<span class="preprocessor"></span>            <a class="code" href="group__pj__config.htm#ga7523f8576efd271c22b188eab05d7870">PJ_UNUSED_ARG</a>(delay);
            <a class="code" href="group__PJ__SYMBIAN__OS.htm#ga275984ae4a88fbf747275284fee70f62">pj_symbianos_poll</a>(-1, 100);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>            <a class="code" href="group__PJ__IOQUEUE.htm#gac65cc5cb9a04f2008d1fa62709ba2d91">pj_ioqueue_poll</a>(ioqueue, &amp;delay);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        }

        <span class="keywordflow">if</span> (srv1-&gt;rx_err_cnt+srv1-&gt;tx_err_cnt != 0 ||
            srv2-&gt;rx_err_cnt+srv2-&gt;tx_err_cnt != 0)
        {
            <span class="comment">/* Got error */</span>
            ret = -60;
            <span class="keywordflow">goto</span> on_return;
        }

        <span class="keywordflow">if</span> (last_rx1 == srv1-&gt;rx_cnt &amp;&amp; last_rx2 == srv2-&gt;rx_cnt) {
            <span class="comment">/* Packet lost */</span>
            ret = -70;
            udp_echo_err(<span class="stringliteral">&quot;packets have been lost&quot;</span>, <a class="code" href="group__pj__errnum.htm#ga643886ed0bd4cd271fb8155552906fbc">PJ_ETIMEDOUT</a>);
            <span class="keywordflow">goto</span> on_return;
        }
    }

    ret = 0;

on_return:
    <span class="keywordflow">if</span> (srv2)
        udp_echo_srv_destroy(srv2);
    <span class="keywordflow">if</span> (srv1)
        udp_echo_srv_destroy(srv1);
    <span class="keywordflow">if</span> (ioqueue)
        <a class="code" href="group__PJ__IOQUEUE.htm#ga59f004632b9ae20e43fa573e6b6cb237">pj_ioqueue_destroy</a>(ioqueue);
    <span class="keywordflow">if</span> (pool)
        <a class="code" href="group__PJ__POOL.htm#gade0f14f6635ecfccb576ec41c57fede5">pj_pool_release</a>(pool);
    
    <span class="keywordflow">return</span> ret;
}



<span class="preprocessor">#define SIGNATURE   0xdeadbeef</span>
<span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structtcp__pkt.htm">tcp_pkt</a>
{
    <a class="code" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> signature;
    <a class="code" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> seq;
    <span class="keywordtype">char</span>        fill[513];
};

<span class="keyword">struct </span><a class="code" href="structtcp__state.htm">tcp_state</a>
{
    <a class="code" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>   err;
    <a class="code" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a>   sent;
    <a class="code" href="group__PJ__BASIC.htm#gafbfd2fd08c6041ea3cb217310c0b5b48">pj_uint32_t</a> next_recv_seq;
    <a class="code" href="group__PJ__BASIC.htm#ga03cd006c29b1d24580f5df4db912749e">pj_uint8_t</a>  pkt[600];
};

<span class="keyword">struct </span><a class="code" href="structsend__key.htm">send_key</a>
{
    <a class="code" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> <a class="code" href="structop__key.htm">op_key</a>;
};


<span class="keyword">static</span> <a class="code" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> tcp_on_data_read(<a class="code" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock,
                                  <span class="keywordtype">void</span> *data,
                                  <a class="code" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> size,
                                  <a class="code" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status,
                                  <a class="code" href="group__PJ__BASIC.htm#ga9fdb3ceb491cd888cd30ca30d78026e8">pj_size_t</a> *remainder)
{
    <span class="keyword">struct </span><a class="code" href="structtcp__state.htm">tcp_state</a> *st = (<span class="keyword">struct </span><a class="code" href="structtcp__state.htm">tcp_state</a>*) <a class="code" href="group__PJ__ACTIVESOCK.htm#gac5a45c643541dbdd6d74a633fb28207d">pj_activesock_get_user_data</a>(asock);
    <span class="keywordtype">char</span> *next = (<span class="keywordtype">char</span>*) data;

    <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a> &amp;&amp; status != <a class="code" href="group__pj__errnum.htm#ga8706796879339b5dc875e2af631d6fe7">PJ_EPENDING</a>) {
        <a class="code" href="group__PJ__LOG.htm#ga767b9231bf7c2b57274771cdc4bca818">PJ_LOG</a>(1,(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;   err: status=%d&quot;</span>, status));
        st-&gt;err = PJ_TRUE;
        <span class="keywordflow">return</span> PJ_FALSE;
    }

    <span class="keywordflow">while</span> (size &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structtcp__pkt.htm">tcp_pkt</a>)) {
        <span class="keyword">struct </span><a class="code" href="structtcp__pkt.htm">tcp_pkt</a> *<a class="code" href="structtcp__pkt.htm">tcp_pkt</a> = (<span class="keyword">struct </span>tcp_pkt*) next;

        <span class="keywordflow">if</span> (tcp_pkt-&gt;signature != SIGNATURE) {
            <a class="code" href="group__PJ__LOG.htm#ga767b9231bf7c2b57274771cdc4bca818">PJ_LOG</a>(1,(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;   err: invalid signature at seq=%d&quot;</span>, 
                          st-&gt;next_recv_seq));
            st-&gt;err = PJ_TRUE;
            <span class="keywordflow">return</span> PJ_FALSE;
        }
        <span class="keywordflow">if</span> (tcp_pkt-&gt;seq != st-&gt;next_recv_seq) {
            <a class="code" href="group__PJ__LOG.htm#ga767b9231bf7c2b57274771cdc4bca818">PJ_LOG</a>(1,(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;   err: wrong sequence&quot;</span>));
            st-&gt;err = PJ_TRUE;
            <span class="keywordflow">return</span> PJ_FALSE;
        }

        st-&gt;next_recv_seq++;
        next += <span class="keyword">sizeof</span>(<span class="keyword">struct </span>tcp_pkt);
        size -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span>tcp_pkt);
    }

    <span class="keywordflow">if</span> (size) {
        <a class="code" href="group__PJ__PSTR.htm#gafd9c91c61bc9dbcbc5420d298fa968e3">pj_memmove</a>(data, next, size);
        *remainder = size;
    }

    <span class="keywordflow">return</span> PJ_TRUE;
}

<span class="keyword">static</span> <a class="code" href="group__PJ__BASIC.htm#ga1dc7a356fb36bd2dee2bc7d6c7e817e4">pj_bool_t</a> tcp_on_data_sent(<a class="code" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock,
                                  <a class="code" href="structpj__ioqueue__op__key__t.htm">pj_ioqueue_op_key_t</a> *<a class="code" href="structop__key.htm">op_key</a>,
                                  <a class="code" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> sent)
{
    <span class="keyword">struct </span><a class="code" href="structtcp__state.htm">tcp_state</a> *st=(<span class="keyword">struct </span><a class="code" href="structtcp__state.htm">tcp_state</a>*)<a class="code" href="group__PJ__ACTIVESOCK.htm#gac5a45c643541dbdd6d74a633fb28207d">pj_activesock_get_user_data</a>(asock);

    <a class="code" href="group__pj__config.htm#ga7523f8576efd271c22b188eab05d7870">PJ_UNUSED_ARG</a>(op_key);

    st-&gt;sent = 1;

    <span class="keywordflow">if</span> (sent &lt; 1) {
        st-&gt;err = PJ_TRUE;
        <span class="keywordflow">return</span> PJ_FALSE;
    }

    <span class="keywordflow">return</span> PJ_TRUE;
}

<span class="keyword">static</span> <span class="keywordtype">int</span> tcp_perf_test(<span class="keywordtype">void</span>)
{
    <span class="keyword">enum</span> { COUNT=10000 };
    <a class="code" href="structpj__pool__t.htm">pj_pool_t</a> *pool = NULL;
    <a class="code" href="group__PJ__BASIC.htm#ga26ca218655d86b00d807e1407854128e">pj_ioqueue_t</a> *ioqueue = NULL;
    <a class="code" href="group__PJ__BASIC.htm#ga5ccc87de27d1236bc31ae3673d153984">pj_sock_t</a> sock1=PJ_INVALID_SOCKET, sock2=PJ_INVALID_SOCKET;
    <a class="code" href="group__PJ__ACTIVESOCK.htm#ga2374729a4261eb7a1e780110bcef2e37">pj_activesock_t</a> *asock1 = NULL, *asock2 = NULL;
    <a class="code" href="structpj__activesock__cb.htm">pj_activesock_cb</a> cb;
    <span class="keyword">struct </span><a class="code" href="structtcp__state.htm">tcp_state</a> *state1, *state2;
    <span class="keywordtype">unsigned</span> i;
    <a class="code" href="group__PJ__BASIC.htm#gab43ba3167bd2a2ab4580509dbf79200e">pj_status_t</a> status;

    pool = <a class="code" href="group__PJ__POOL.htm#gaf58c3ba26a1314c0e0be103960ba4a5e">pj_pool_create</a>(mem, <span class="stringliteral">&quot;tcpperf&quot;</span>, 256, 256, NULL);

    status = app_socketpair(<a class="code" href="group__PJ__SOCK.htm#ga8ea303b95fe973432a361e47e0459086">pj_AF_INET</a>(), <a class="code" href="group__PJ__SOCK.htm#gae224fbf8e8bd55b40030fcd8f9645291">pj_SOCK_STREAM</a>(), 0, &amp;sock1, 
                            &amp;sock2);
    <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
        status = -100;
        <span class="keywordflow">goto</span> on_return;
    }

    status = <a class="code" href="group__PJ__IOQUEUE.htm#gaae188673e57ae841d586a738e53cffc5">pj_ioqueue_create</a>(pool, 4, &amp;ioqueue);
    <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
        status = -110;
        <span class="keywordflow">goto</span> on_return;
    }

    <a class="code" href="group__PJ__PSTR.htm#gafa92001573289c87313c660146369fa3">pj_bzero</a>(&amp;cb, <span class="keyword">sizeof</span>(cb));
    cb.<a class="code" href="structpj__activesock__cb.htm#af0b64be6f5cc9d0f86ab10b3fa661abc">on_data_read</a> = &amp;tcp_on_data_read;
    cb.<a class="code" href="structpj__activesock__cb.htm#a90e1eeb50556994335c97d25776ae11b">on_data_sent</a> = &amp;tcp_on_data_sent;

    state1 = <a class="code" href="group__PJ__POOL.htm#ga405d1dbb6728b1d1bd90ddadb9342b27">PJ_POOL_ZALLOC_T</a>(pool, <span class="keyword">struct</span> <a class="code" href="structtcp__state.htm">tcp_state</a>);
    status = <a class="code" href="group__PJ__ACTIVESOCK.htm#gaad8adb25f996f1ae75a2b1e98e15e584">pj_activesock_create</a>(pool, sock1, <a class="code" href="group__PJ__SOCK.htm#gae224fbf8e8bd55b40030fcd8f9645291">pj_SOCK_STREAM</a>(), NULL, ioqueue,
                                  &amp;cb, state1, &amp;asock1);
    <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
        status = -120;
        <span class="keywordflow">goto</span> on_return;
    }

    state2 = <a class="code" href="group__PJ__POOL.htm#ga405d1dbb6728b1d1bd90ddadb9342b27">PJ_POOL_ZALLOC_T</a>(pool, <span class="keyword">struct</span> <a class="code" href="structtcp__state.htm">tcp_state</a>);
    status = <a class="code" href="group__PJ__ACTIVESOCK.htm#gaad8adb25f996f1ae75a2b1e98e15e584">pj_activesock_create</a>(pool, sock2, <a class="code" href="group__PJ__SOCK.htm#gae224fbf8e8bd55b40030fcd8f9645291">pj_SOCK_STREAM</a>(), NULL, ioqueue,
                                  &amp;cb, state2, &amp;asock2);
    <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
        status = -130;
        <span class="keywordflow">goto</span> on_return;
    }

    status = <a class="code" href="group__PJ__ACTIVESOCK.htm#gaff5faf21c01d9a606aa014a2f2791183">pj_activesock_start_read</a>(asock1, pool, 1000, 0);
    <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
        status = -140;
        <span class="keywordflow">goto</span> on_return;
    }

    <span class="comment">/* Send packet as quickly as possible */</span>
    <span class="keywordflow">for</span> (i=0; i&lt;COUNT &amp;&amp; !state1-&gt;err &amp;&amp; !state2-&gt;err; ++i) {
        <span class="keyword">struct </span>tcp_pkt *pkt;
        <span class="keyword">struct </span><a class="code" href="structsend__key.htm">send_key</a> <a class="code" href="structsend__key.htm">send_key</a>[2], *op_key;
        <a class="code" href="group__PJ__BASIC.htm#ga173588cd6381f3ad354c23c26929093a">pj_ssize_t</a> len;

        pkt = (<span class="keyword">struct </span>tcp_pkt*)state2-&gt;pkt;
        pkt-&gt;signature = SIGNATURE;
        pkt-&gt;seq = i;
        <a class="code" href="group__PJ__PSTR.htm#ga4c63a114dcee8ff7f04b3f142d2158f0">pj_memset</a>(pkt-&gt;fill, <span class="charliteral">&#39;a&#39;</span>, <span class="keyword">sizeof</span>(pkt-&gt;fill));

        op_key = &amp;<a class="code" href="structsend__key.htm">send_key</a>[i%2];
        <a class="code" href="group__PJ__IOQUEUE.htm#ga2ef6f3b6077c716793e2b4a488e03fe4">pj_ioqueue_op_key_init</a>(&amp;op_key-&gt;op_key, <span class="keyword">sizeof</span>(*op_key));

        state2-&gt;sent = PJ_FALSE;
        len = <span class="keyword">sizeof</span>(*pkt);
        status = <a class="code" href="group__PJ__ACTIVESOCK.htm#gaaa1bc3760aa6b278e8ace0841a0fd7f5">pj_activesock_send</a>(asock2, &amp;op_key-&gt;op_key, pkt, &amp;len, 0);
        <span class="keywordflow">if</span> (status == <a class="code" href="group__pj__errnum.htm#ga8706796879339b5dc875e2af631d6fe7">PJ_EPENDING</a>) {
            <span class="keywordflow">do</span> {
<span class="preprocessor">#if PJ_SYMBIAN</span>
<span class="preprocessor"></span>                <a class="code" href="group__PJ__SYMBIAN__OS.htm#ga275984ae4a88fbf747275284fee70f62">pj_symbianos_poll</a>(-1, -1);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>                <a class="code" href="group__PJ__IOQUEUE.htm#gac65cc5cb9a04f2008d1fa62709ba2d91">pj_ioqueue_poll</a>(ioqueue, NULL);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>            } <span class="keywordflow">while</span> (!state2-&gt;sent);
        } <span class="keywordflow">else</span> {
<span class="preprocessor">#if PJ_SYMBIAN</span>
<span class="preprocessor"></span>                <span class="comment">/* The Symbian socket always returns PJ_SUCCESS for TCP send,</span>
<span class="comment">                 * eventhough the remote end hasn&#39;t received the data yet.</span>
<span class="comment">                 * If we continue sending, eventually send() will block,</span>
<span class="comment">                 * possibly because the send buffer is full. So we need to</span>
<span class="comment">                 * poll the ioqueue periodically, to let receiver gets the </span>
<span class="comment">                 * data.</span>
<span class="comment">                 */</span>
                <a class="code" href="group__PJ__SYMBIAN__OS.htm#ga275984ae4a88fbf747275284fee70f62">pj_symbianos_poll</a>(-1, 0);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>                <span class="keywordflow">if</span> (status != <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
                    <a class="code" href="group__PJ__LOG.htm#ga767b9231bf7c2b57274771cdc4bca818">PJ_LOG</a>(1,(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;   err: send status=%d&quot;</span>, status));
                    status = -180;
                    <span class="keywordflow">break</span>;
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status == <a class="code" href="group__PJ__BASIC.htm#ga1a7d58698e362566cf64a0c59ab7d4cd">PJ_SUCCESS</a>) {
                    <span class="keywordflow">if</span> (len != <span class="keyword">sizeof</span>(*pkt)) {
                        <a class="code" href="group__PJ__LOG.htm#ga767b9231bf7c2b57274771cdc4bca818">PJ_LOG</a>(1,(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;   err: shouldn&#39;t report partial sent&quot;</span>));
                        status = -190;
                        <span class="keywordflow">break</span>;
                    }
                }
        }

<span class="preprocessor">#ifndef PJ_SYMBIAN</span>
<span class="preprocessor"></span>        <span class="keywordflow">for</span> (;;) {
            <a class="code" href="structpj__time__val.htm">pj_time_val</a> timeout = {0, 10};
            <span class="keywordflow">if</span> (<a class="code" href="group__PJ__IOQUEUE.htm#gac65cc5cb9a04f2008d1fa62709ba2d91">pj_ioqueue_poll</a>(ioqueue, &amp;timeout) &lt; 1)
                <span class="keywordflow">break</span>;
        }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    }

    <span class="comment">/* Wait until everything has been sent/received */</span>
    <span class="keywordflow">if</span> (state1-&gt;next_recv_seq &lt; COUNT) {
<span class="preprocessor">#ifdef PJ_SYMBIAN</span>
<span class="preprocessor"></span>        <span class="keywordflow">while</span> (<a class="code" href="group__PJ__SYMBIAN__OS.htm#ga275984ae4a88fbf747275284fee70f62">pj_symbianos_poll</a>(-1, 1000) == <a class="code" href="group__PJ__BASIC.htm#gac8d6a18466c2489aae935c44f15edb5b">PJ_TRUE</a>)
            ;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        <a class="code" href="structpj__time__val.htm">pj_time_val</a> delay = {0, 100};
        <span class="keywordflow">while</span> (<a class="code" href="group__PJ__IOQUEUE.htm#gac65cc5cb9a04f2008d1fa62709ba2d91">pj_ioqueue_poll</a>(ioqueue, &amp;delay) &gt; 0)
            ;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    }

    <span class="keywordflow">if</span> (status == <a class="code" href="group__pj__errnum.htm#ga8706796879339b5dc875e2af631d6fe7">PJ_EPENDING</a>)
        status = PJ_SUCCESS;

    <span class="keywordflow">if</span> (status != 0)
        <span class="keywordflow">goto</span> on_return;

    <span class="keywordflow">if</span> (state1-&gt;err) {
        status = -183;
        <span class="keywordflow">goto</span> on_return;
    }
    <span class="keywordflow">if</span> (state2-&gt;err) {
        status = -186;
        <span class="keywordflow">goto</span> on_return;
    }
    <span class="keywordflow">if</span> (state1-&gt;next_recv_seq != COUNT) {
        <a class="code" href="group__PJ__LOG.htm#ga767b9231bf7c2b57274771cdc4bca818">PJ_LOG</a>(3,(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;   err: only %u packets received, expecting %u&quot;</span>, 
                      state1-&gt;next_recv_seq, COUNT));
        status = -195;
        <span class="keywordflow">goto</span> on_return;
    }

on_return:
    <span class="keywordflow">if</span> (asock2)
        <a class="code" href="group__PJ__ACTIVESOCK.htm#gac8a9253fe6327c82871e92f7e6bcd8d6">pj_activesock_close</a>(asock2);
    <span class="keywordflow">if</span> (asock1)
        <a class="code" href="group__PJ__ACTIVESOCK.htm#gac8a9253fe6327c82871e92f7e6bcd8d6">pj_activesock_close</a>(asock1);
    <span class="keywordflow">if</span> (ioqueue)
        <a class="code" href="group__PJ__IOQUEUE.htm#ga59f004632b9ae20e43fa573e6b6cb237">pj_ioqueue_destroy</a>(ioqueue);
    <span class="keywordflow">if</span> (pool)
        <a class="code" href="group__PJ__POOL.htm#gade0f14f6635ecfccb576ec41c57fede5">pj_pool_release</a>(pool);

    <span class="keywordflow">return</span> status;
}



<span class="keywordtype">int</span> activesock_test(<span class="keywordtype">void</span>)
{
    <span class="keywordtype">int</span> ret;

    <a class="code" href="group__PJ__LOG.htm#ga767b9231bf7c2b57274771cdc4bca818">PJ_LOG</a>(3,(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;..udp ping/pong test&quot;</span>));
    ret = udp_ping_pong_test();
    <span class="keywordflow">if</span> (ret != 0)
        <span class="keywordflow">return</span> ret;

    <a class="code" href="group__PJ__LOG.htm#ga767b9231bf7c2b57274771cdc4bca818">PJ_LOG</a>(3,(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;..tcp perf test&quot;</span>));
    ret = tcp_perf_test();
    <span class="keywordflow">if</span> (ret != 0)
        <span class="keywordflow">return</span> ret;

    <span class="keywordflow">return</span> 0;
}

<span class="preprocessor">#else   </span><span class="comment">/* INCLUDE_ACTIVESOCK_TEST */</span>
<span class="comment">/* To prevent warning about &quot;translation unit is empty&quot;</span>
<span class="comment"> * when this test is disabled. </span>
<span class="comment"> */</span>
<span class="keywordtype">int</span> dummy_active_sock_test;
<span class="preprocessor">#endif  </span><span class="comment">/* INCLUDE_ACTIVESOCK_TEST */</span>

</pre></div> </div>
<p>&nbsp;</p>
<hr><center>
PJLIB Open Source, high performance, small footprint, and very very portable framework<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
